---
title: Специфічність
slug: Web/CSS/Specificity
tags:
  - CSS
  - Example
  - Guide
  - Reference
  - Web
spec-urls: https://drafts.csswg.org/selectors/#specificity-rules
---

{{CSSRef}}

**Специфічність** &mdash; це засіб, за допомогою якого браузери вирішують, які значення CSS-властивостей найбільш відповідні до певного елемента і, таким чином, будуть застосовані. Специфічність заснована на правилах добору, що складені на основі різних видів [CSS-селекторів](/uk/docs/Web/CSS/Reference#selektory).

## Як обчислюється специфічність?

Специфічність &mdash; це вага, що застосовується до певного CSS-оголошення, визначена кількістю кожного з [типів селекторів](#typy-selektoriv) у відповідному селекторі. Коли кілька оголошень мають рівну специфічність, до елементу застосовується останнє з оголошень, присутніх у CSS-коді. Специфічність застосовується лише тоді, коли один елемент є цільовим для багатьох оголошень. Згідно з правилами CSS, [стилі, що спрямовані безпосередньо на елемент](#styli-spriamovani-bezposeredno-na-element-proty-nasliduvanykh-styliv), завжди матимуть перевагу над правилами, успадкованими елементом від свого предка.

> **Примітка:** [Сусідство елементів](#ihnoruvannia-susidstva-po-derevu) у дереві документа не впливає на специфічність.

### Типи селекторів

Список типів селекторів у порядку зростання специфічності

1. [Селектори типу](/uk/docs/Web/CSS/Type_selectors) (наприклад, `h1`) та псевдоелементи (e.g., `::before`).
2. [Селектори класу](/uk/docs/Web/CSS/Class_selectors) (наприклад, `.example`), селектори атрибуту (наприклад, `[type="radio"]`) та псевдокласи (наприклад, `:hover`).
3. [Селектори ідентифікатора](/uk/docs/Web/CSS/ID_selectors) (наприклад, `#example`).

Універсальний селектор ({{CSSxRef("Universal_selectors", "*")}}), комбінатори ({{CSSxRef("Adjacent_sibling_combinator", "+")}}, {{CSSxRef("Child_combinator", "&gt;")}}, {{CSSxRef("General_sibling_combinator", "~")}}, [" "](/uk/docs/Web/CSS/Descendant_combinator), {{CSSxRef("Column_combinator", "||")}}) та псевдоклас заперечення ({{CSSxRef(":not", ":not()")}}) не впливають на специфічність. (Селектори, оголошені _всередині_ `:not()`, втім, впливають.)

Щоб отримати більше інформації, відвідайте: ["Специфічність" у розділі "Каскадність та успадкування"](/uk/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance#spetsyfichnist_2), а також відвідайте: <https://specifishity.com> (англ.).

Вбудовані стилі, напряму додані до елемента (наприклад, `style="font-weight: bold;"`) завжди перезаписують будь-які стилі із зовнішніх листів стилів, і, таким чином, можуть вважатись такими, що мають найвищу специфічність.

### Виняток !important

Коли в оголошенні стилю використовується правило `important`, таке оголошення зневажає будь-які інші оголошення. Втім, технічно `!important` не стосується специфічності, а взаємодіє з нею напряму. Однак, використання `!important` є **шкідливою практикою**, і його слід уникати, адже воно робить зневадження складнішим у зв‘язку з руйнуванням природної [каскадності](/uk/docs/Web/CSS/Cascade) у листах стилів. Коли два конфліктні оголошення із правилом `!important` застосовуються до одного й того ж елемента, буде застосовано оголошення із більшою специфічністю.

**Рекомендовані настанови:**

- **Завжди** шукайте спосіб використати специфічність до того, як навіть розглядати можливість вживання `!important`
- **Винятково** використовуйте `!important` у CSS-коді специфічному для певних сторінок, що відкидає чужий CSS (код зовнішніх бібліотек, як-то Bootstrap чи normalize.css).
- **Ніколи** не використовуйте `!important`, коли пишете плагін чи мешап.
- **Ніколи** не використовуйте `!important` у CSS-коді, що вживатиметься у багатьох місцях вебсайту.

**Замість вживання `!important`, візьміть до уваги:**

1. Краще використайте каскадність CSS
2. Використайте більш специфічні правила. Вказуючи на один чи більше елементів &mdash; предків елемента, що обирається, правило стає більш специфічним та отримує вищий пріоритет:

    ```html
    <div id="test">
      <span>Текст</span>
    </div>
    ```

    ```css
    div#test span {
      color: green;
    }
    div span {
      color: blue;
    }
    span {
      color: red;
    }
    ```

    Незалежно від порядку, текст завжди буде зеленим, тому що відповідне правило має більшу специфічність. (А ще &mdash; правило синього зневажає правило червоного, всупереч порядку правил)

3. Як безглуздий особливий випадок для (2), продублюйте прості селектори, аби збільшити специфічність, коли більше немає чого вказати в селекторі.

    ```css
    #myId#myId span {
      color: yellow;
    }
    .myClass.myClass span {
      color: orange;
    }
    ```

#### Так можна використати !important:

##### A) Відкидання вбудованих стилів

Глобальний CSS-файл, що встановлює візуальні аспекти вашого сайту глобально, може бути зневажений вбудованими стилями, визначеними напряму на окремих елементах. Як вбудовані стилі, так `!important`, &mdash; вважаються шкідливою практикою, однак іноді слід використати друге, щоб пересилити перше.

У такому випадку можна встановити певні стилі у глобальному CSS-файлі як `!important`, таким чином відкидаючи вбудовані стилі, встановлені напряму на елементах.

```html
<div class="foo" style="color: red;">Якого я кольору?</div>
```

```css
.foo[style*='color: red'] {
  color: firebrick !important;
}
```

Чимало Javascript-фреймворків та бібліотек додають вбудовані стилі. Використання `!important` із дуже вузькоспрямованим селектором &mdash; спосіб відкинути такі вбудовані стилі.

##### B) Зневаження високої специфічності

```css
#someElement p {
  color: blue;
}

p.awesome {
  color: red;
}
```

Як змусити `awesome` параграфи завжди ставати червоними, навіть ті, котрі всередині `#someElement`? Без `!important` перше правило мало б більшу специфічність та перемогло б друге правило.

#### Як відкинути `!important`

A) Додати інше правило CSS із `!important` і або надати селектору більшу специфічність (додавши до селектора тег, ідентифікатор чи клас), або додати правило CSS із таким самим селектором у точці, що розташована після вже наявного правила. Це спрацює, адже серед правил з однаковими селекторами перемагає розташоване пізніше.

Приклади із вищою специфічністю:

```css
table td {
  height: 50px !important;
}
.myTable td {
  height: 50px !important;
}
#myTable td {
  height: 50px !important;
}
```

B) Або додаймо такий же селектор після наявного:

```css
td {
  height: 50px !important;
}
```

C) Або краще перепишімо початкове правило, уникаючи використання `!important` узагалі.

```css
[id='someElement'] p {
  color: blue;
}

p.awesome {
  color: red;
}
```

Включення ідентифікатора як частини селектора атрибута замість власне селектора ідентифікатора дає йому таку ж специфічність, як в селекторів класу. Обидва селектори вище тепер мають однакову вагу. Серед правил з однаковими селекторами перемагає розташоване пізніше.

#### Аби отримати більше інформації, відвідайте (англ.):

- <https://stackoverflow.com/questions/3706819/what-are-the-implications-of-using-important-in-css>
- <https://stackoverflow.com/questions/9245353/what-does-important-in-css-mean>
- <https://stackoverflow.com/questions/5701149/when-to-use-important-property-in-css>
- <https://stackoverflow.com/questions/11178673/how-to-override-important>
- <https://stackoverflow.com/questions/2042497/when-to-use-important-to-save-the-day-when-working-with-css>

### Винятки :is() та :not()

Псевдоклас відповідності {{CSSxRef(":is", ":is()")}} {{Experimental_Inline}} та псевдоклас заперечення {{CSSxRef(":not", ":not()")}} _не_ вважаються псевдокласами під час обчислення специфічності. Втім, селектори, вставлені у ці псевдокласи, рахуються як звичайні селектори при підрахунку [типів селекторів](#typy-selektoriv).

Цей шматок CSS-коду...

```css
div.outer p {
  color: orange;
}

div:not(.outer) p {
  color: blueviolet;
}
```

...застосований до наступного HTML...

```html
<div class="outer">
  <p>This is in the outer div.</p>
  <div class="inner">
    <p>This text is in the inner div.</p>
  </div>
</div>
```

...має на екрані такий вигляд:

{{EmbedLiveSample("The_is_and_not_exceptions")}}

### Виняток :where()

Псевдоклас припасування специфічності {{CSSxRef(":where", ":where()")}} {{Experimental_Inline}} завжди вважається таким, що має специфічність рівну нулю.

Цей шматок CSS-коду...

```css
div:where(.outer) p {
  color: orange;
}

div p {
  color: blueviolet;
}
```

```css hidden
#no-where-support {
  margin: 0.5em;
  border: 1px solid red;
}

#no-where-support:where(*) {
  display: none !important;
}
```

...застосований до наступного HTML...

```html hidden
<div id="no-where-support">
  ⚠️ Ваш браузер не підтримує псевдоклас
  <code
    ><a href="https://developer.mozilla.org/docs/Web/CSS/:where" target="_top"
      >:where()</a
    ></code
  >.
</div>
```

```html
<div class="outer">
  <p>Це зовнішній div.</p>
  <div class="inner">
    <p>Цей текст знаходиться у внутрішньому div.</p>
  </div>
</div>
```

...має на екрані такий вигляд:

{{EmbedLiveSample("The_where_exception")}}

### Специфічність на основі форми

Специфічність заснована на формі селектора. У наступному випадку селектор `*[id="foo"]` враховується як селектор атрибута при визначенні специфічності селектора, незалежно від того, що він вказує за ідентифікатором.

Наступні CSS-стилі...

```css
*#foo {
  color: green;
}

*[id='foo'] {
  color: purple;
}
```

...застосовані до наступної розмітки...

```html
<p id="foo">I am a sample text.</p>
```

...зрештою мають такий вигляд:

{{EmbedLiveSample("Form-based_specificity")}}

Так відбувається, бо два селектори відповідають одному й тому ж елементові, але селектор ідентифікатора має вищу специфічність.

### Ігнорування сусідства по дереву

Близькість елемента до інших елементів, на котрі посилається певний селектор, не впливає на специфічність. Наступні оголошення стилів...

```css
body h1 {
  color: green;
}

html h1 {
  color: purple;
}
```

...застосовані до такого HTML...

```html
<html>
  <body>
    <h1>Ось вам заголовок!</h1>
  </body>
</html>
```

...будуть відображені отак:

{{EmbedLiveSample("Tree_proximity_ignorance")}}

Причина цього у тому, що два оголошення мають однакові суми [за типами селекторів](#typy-selektoriv), але, втім, селектор `html h1` оголошений останнім.

### Стилі, спрямовані безпосередньо на елемент, проти наслідуваних стилів

Стилі, які спрямовані безпосередньо на елемент, мають перевагу над наслідуваними стилями, незалежно від специфічності наслідуваного правила. Цей CSS-код...

```css
#parent {
  color: green;
}

h1 {
  color: purple;
}
```

...застосований до наступного HTML...

```html
<html>
  <body id="parent">
    <h1>Ось вам заголовок!</h1>
  </body>
</html>
```

...буде відображений отак:

{{EmbedLiveSample("Directly_targeted_elements_vs._inherited_styles")}}

Причина цього: селектор `h1` націлений саме на елемент, а зелений колір &mdash; лише наслідуваний від предка.

## Специфікації

{{Specifications}}

## Дивіться також

- Калькулятор специфічності: інтерактивний вебсайт для тестування та розуміння CSS-правил (англ.) — <https://specificity.keegan.st/>
- Специфічність селекторів CSS3 (англ.) - [http://www.w3.org/TR/selectors/#specificity](https://www.w3.org/TR/selectors/#specificity)
- {{CSS_Key_Concepts}}
