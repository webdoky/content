---
title: "@layer"
slug: Web/CSS/@layer
page-type: css-at-rule
browser-compat: css.at-rules.layer
---

{{CSSRef}}

[Директива](/uk/docs/Web/CSS/At-rule) [CSS](/uk/docs/Web/CSS) **`@layer`** (шар) використовується для оголошення каскадного шару, а також може вживатися для визначення порядку пріоритету, коли каскадних шарів декілька.

{{EmbedInteractiveExample("pages/tabbed/at-rule-layer.html", "tabbed-standard")}}

## Синтаксис

```css
/* директиви-інструкції */
@layer layer-name;
@layer layer-name, layer-name, layer-name;

/* директиви-блоки */
@layer {rules}
@layer layer-name {rules}
```

де:

- _layer-name_
  - : Це назва каскадного шару.
- _rules_
  - : Це набір правил CSS у каскадному шарі.

## Опис

Правила в межах одного каскадного шару каскадують разом, надаючи веброзробникам більше контролю над каскадом. Стилі, визначені поза шарами, завжди перемагають стилі, оголошені в названих і анонімних шарах.

Наступна діаграма показує пріоритетність шарів, причому шари оголошені послідовно, 1, 2, ..., N.

![Діаграма, що показує пріоритетність каскадних шарів](https://webdoky.github.io/shared-assets/images/diagrams/css/at-rules/layer-cascade.svg)

Порядок оголошення – важливий. Перший оголошений шар отримує найнижчий пріоритет, а останній – найвищий. Проте така пріоритетність перекидається на зворотну, коли вживається позначка [`!important`](/uk/docs/Web/CSS/important).

Директива `@layer` вживається для створення каскадного шару одним із трьох способів.

Перший спосіб – за допомогою директиви-блоку `@layer` створити названий каскадний шар із правилами CSS для цього шару всередині, як показано нижче:

```css
@layer utilities {
  .padding-sm {
    padding: 0.5rem;
  }

  .padding-lg {
    padding: 0.8rem;
  }
}
```

Другий спосіб – скористатися директивою-інструкцією `@layer`, аби створити один або кілька розділених комами каскадних шарів, не присвоюючи їм жодних стилів. Це може бути один шар, як показано нижче:

```css
@layer utilities;
```

Можна зразу визначити декілька шарів, як показано нижче:

```css
@layer theme, layout, utilities;
```

Це корисно, тому що початковий порядок, у якому оголошуються шари, вказує на те, який шар має пріоритет. Як і для оголошень, останній шар у переліку перемагає, якщо оголошення знайдено в декількох шарах. Тому, у попередньому прикладі, якщо конкурентні правила знайдено в `theme` і `utilities`, то перемагає те, що в `utilities`, – воно й застосовується.

Правило в `utilities` буде застосоване, _навіть якщо воно має меншу специфічність_, ніж правило в `theme`. Бо коли сформовано порядок шарів, то специфічність і порядок появи ігноруються. Це дає змогу створювати простіші селектори CSS, оскільки немає потреби перевіряти, що селектор матиме достатньо високу специфічність, аби переважити конкурентні правила; все, що потрібно, – це переконатися, що воно з'являється в пізнішому шарі.

> [!NOTE]
> Після оголошення назв шарів, задавши їх порядок, можна додати до шару правила CSS, повторно оголосивши його назву. Ці стилі будуть додані до шару, а порядок шарів не зміниться.

Третій спосіб – створити неназваний шар, скориставшись директивою-блоком `@layer`, не вказавши в ній назву для шару. Наприклад:

```css
@layer {
  p {
    margin-block: 1rem;
  }
}
```

Це породжує _анонімний каскадний шар_. Такий шар діє так само, як і названі шари; проте йому не можна призначити правила пізніше. Порядок пріоритету для анонімних шарів – це порядок, у якому вони оголошені, незалежно від наявності в них назви, і цей порядок нижчий за стилі, оголошені поза шарами.

Іще один спосіб створити каскадний шар – скористатися {{cssxref("@import")}}. У цьому випадку правила будуть у підключеному списку стилів. Пам'ятайте, що директива `@import` повинна передувати правилам усіх інших типів, крім директив `@charset` і `@layer`.

```css
@import "theme.css" layer(utilities);
```

### Вкладені шари

Шари можна вкладати один в одного. Наприклад:

```css
@layer framework {
  @layer layout {
  }
}
```

Щоб додати правила до шару `layout` всередині `framework`, необхідно об'єднати дві назви `.` (крапкою).

```css
@layer framework.layout {
  p {
    margin-block: 1rem;
  }
}
```

## Формальний синтаксис

{{csssyntax}}

## Приклади

### Простий приклад

У наступному прикладі створюються два правила CSS. Одне для елемента {{htmlelement("p")}} поза будь-яким шаром і одне всередині шару з назвою `type` для `.box p`.

Якби шарів не було, то селектор `.box p` мав би найвищу специфічність, а отже, текст `Привіт, світе!` виводився б зеленим кольором. Оскільки шар `type` стоїть перед анонімним шаром, створеним для зберігання нешарового вмісту, текст буде фіолетовим.

Також зверніть увагу на порядок. Навіть попри те, що нешаровий стиль оголошено першим, він все одно застосовується _після_ шарових стилів.

#### HTML

```html
<div class="box">
  <p>Привіт, світе!</p>
</div>
```

#### CSS

```css
p {
  color: rebeccapurple;
}

@layer type {
  .box p {
    font-weight: bold;
    font-size: 1.3em;
    color: green;
  }
}
```

#### Результат

{{EmbedLiveSample("prostyi-pryklad")}}

### Призначення правил наявним шарам

У наступному прикладі створюються два шари без правил, а потім до них застосовуються правила CSS. Шар `base` визначає `color`, `border`, `font-size` і `padding`. Шар `special` визначає інший колір. Оскільки `special` стоїть останнім при визначенні шарів, використовується колір, який він надає, і текст виводиться з використанням `rebeccapurple`. Всі інші правила з `base` все ж застосовуються.

#### HTML

```html
<div class="item">
  Я виводжуся з <code>color: rebeccapurple</code>, тому що шар
  <code>special</code> стоїть після шару <code>base</code>. Мої зелена межа,
  розмір шрифту та внутрішній відступ надходять з шару <code>base</code>.
</div>
```

#### CSS

```css
@layer base, special;

@layer special {
  .item {
    color: rebeccapurple;
  }
}

@layer base {
  .item {
    color: green;
    border: 5px solid green;
    font-size: 1.3em;
    padding: 0.5em;
  }
}
```

#### Результат

{{EmbedLiveSample("pryznachennia-pravyl-naiavnym-sharam")}}

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

## Дивіться також

- [`@import`](/uk/docs/Web/CSS/@import)
- {{domxref("CSSLayerBlockRule")}}
- {{domxref("CSSLayerStatementRule")}}
- [`!important`](/uk/docs/Web/CSS/important)
- [`revert-layer`](/uk/docs/Web/CSS/revert-layer)
- [Знайомство з Каскадом CSS](/uk/docs/Web/CSS/Cascade)
- [Каскад, специфічність і успадкування](/uk/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance)
- [Каскадні шари](/uk/docs/Learn/CSS/Building_blocks/Cascade_layers)
- [Майбутнє CSS – каскадні шари](https://www.bram.us/2021/09/15/the-future-of-css-cascade-layers-css-at-layer/) на bram.us (2021)
