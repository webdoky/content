---
title: Типи даних та структури даних JavaScript
slug: Web/JavaScript/Data_structures
page-type: guide
---

{{jsSidebar("More")}}

Усі мови програмування мають вбудовані структури даних, але вони поміж цих мов нерідко різняться. Ця стаття має на меті перелічити вбудовані структури даних, доступні в JavaScript, та притаманні їм властивості. На основі них можна будувати інші структури даних.

[Огляд мови](/uk/docs/Web/JavaScript/Language_overview) пропонує подібний підсумок загальновживаних типів даних, але містить більше порівнянь з іншими мовами програмування.

## Динамічна і слабка типізація

JavaScript – це [динамічна](https://uk.wikipedia.org/wiki/%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D1%96%D1%87%D0%BD%D0%B0_%D0%BC%D0%BE%D0%B2%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F) мова програмування з [динамічними типами](https://uk.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%82%D0%B8%D0%BF%D1%96%D0%B7%D0%B0%D1%86%D1%96%D1%97#%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D1%96%D1%87%D0%BD%D0%B0_%D1%82%D0%B8%D0%BF%D1%96%D0%B7%D0%B0%D1%86%D1%96%D1%8F). Змінні в JavaScript не пов'язані напряму з жодним конкретним типом даних, і будь-якій змінній можуть бути присвоєні (й присвоєні знову) значення всіх типів:

```js
let foo = 42; // тепер foo – число
foo = "bar"; // тепер foo – рядок
foo = true; // тепер foo – булеве значення
```

Крім того, JavaScript – це [слабко типізована (англ.)](https://en.wikipedia.org/wiki/Strong_and_weak_typing) мова, тобто вона дозволяє неявне приведення типів, коли операція залучає типи, що не збігаються, замість викидання помилок типів.

```js
const foo = 42; // foo є числом
const result = foo + "1"; // JavaScript зводить foo до рядка, щоб його можна було склеїти з іншим операндом
console.log(result); // 421
```

Неявне зведення типів – це дуже зручно, але воно може призводити до неочевидних вад, коли перетворення відбуваються там, де не очікуються, або там, де повинні були б відбутися в протилежному напрямку (наприклад, рядків до чисел, а не чисел до рядків). Для [символів](#typ-symbol) та [BigInt](#typ-bigint) JavaScript свідомо забороняє певні неявні перетворення типів.

## Примітивні значення

Усі типи, крім [Object](#obiekty), визначають [незмінні](/uk/docs/Glossary/Immutable) значення, безпосередньо представлені на найнижчому рівні мови. Значення цих типів звуть _примітивними значеннями_.

Усі примітивні типи, окрім [`null`](/uk/docs/Web/JavaScript/Reference/Operators/null), можна перевірити за допомогою оператора [`typeof`](/uk/docs/Web/JavaScript/Reference/Operators/typeof). `typeof null` повертає `"object"`, тож для перевірки на `null` слід використовувати `=== null`.

Усі примітивні типи, крім [`null`](/uk/docs/Web/JavaScript/Reference/Operators/null) і [`undefined`](/uk/docs/Web/JavaScript/Reference/Global_Objects/undefined), мають власні типи об'єктів-обгорток, котрі надають корисні методи для роботи з примітивними значеннями. Наприклад, об'єкт [`Number`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Number) надає методи штибу [`toExponential()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential). Коли відбувається звертання до властивості на примітивному значенні, JavaScript автоматично загортає це значення у відповідний об'єкт-обгортку і звертається до властивості цього об'єкта. Проте звертання до властивості на `null` чи `undefined` викидає виняток `TypeError`, що призвело до запровадження оператора [необов'язкового зв'язування](/uk/docs/Web/JavaScript/Reference/Operators/Optional_chaining).

| Тип                         | Повернене значення `typeof` | Об'єкт-обгортка       |
| --------------------------- | --------------------------- | --------------------- |
| [Null](#typ-null)           | `"object"`                  | Немає                 |
| [Undefined](#typ-undefined) | `"undefined"`               | Немає                 |
| [Boolean](#typ-boolean)     | `"boolean"`                 | {{jsxref("Boolean")}} |
| [Number](#typ-number)       | `"number"`                  | {{jsxref("Number")}}  |
| [BigInt](#typ-bigint)       | `"bigint"`                  | {{jsxref("BigInt")}}  |
| [String](#typ-string)       | `"string"`                  | {{jsxref("String")}}  |
| [Symbol](#typ-symbol)       | `"symbol"`                  | {{jsxref("Symbol")}}  |

Довідкові сторінки класів об'єктів-обгорток містять більше інформації про методи й властивості, доступні для кожного типу, а також детальний опис семантики самих примітивних типів.

### Тип Null

Тип Null населений винятково одним значенням: [`null`](/uk/docs/Web/JavaScript/Reference/Operators/null)

### Тип Undefined

Тип Undefined населений винятково одним значенням: [`undefined`](/uk/docs/Web/JavaScript/Reference/Global_Objects/undefined).

Концептуально `undefined` вказує на відсутність _значення_, натомість `null` вказує на відсутність _об'єкта_ (що може бути певного роду виправданням для [`typeof null === "object"`](/uk/docs/Web/JavaScript/Reference/Operators/typeof#typeof-null)). Мова зазвичай використовує `undefined`, коли щось позбавлено значення:

- Інструкція [`return`](/uk/docs/Web/JavaScript/Reference/Statements/return) без значення (`return;`) неявно повертає `undefined`.
- Звертання до відсутньої властивості [об'єкта](/uk/docs/Web/JavaScript/Reference/Global_Objects/Object) (`obj.iDontExist`) повертає `undefined`.
- Оголошення змінної без її ініціалізації (`let x;`) неявно ініціалізує змінну значенням `undefined`.
- Чимало методів, як то {{jsxref("Array.prototype.find()")}} і {{jsxref("Map.prototype.get()")}}, повертає `undefined`, коли елемент не знайдено.

`null` куди рідше використовується в ядрі мови. Найважливіше місце – кінець [ланцюжка прототипів](/uk/docs/Web/JavaScript/Inheritance_and_the_prototype_chain) – як наслідок, методи, що працюють з прототипами, як то {{jsxref("Object.getPrototypeOf()")}}, {{jsxref("Object.create()")}} тощо, приймають чи повертають `null`, а не `undefined`.

`null` є [ключовим словом](/uk/docs/Web/JavaScript/Reference/Lexical_grammar#kliuchovi-slova), натомість `undefined` є звичайним [ідентифікатором](/uk/docs/Web/JavaScript/Reference/Lexical_grammar#identyfikatory), котрому трапилося стати глобальною властивістю. На практиці різниця незначна, адже `undefined` не повинно бути перевизначено чи затулено.

### Тип Boolean

Тип {{jsxref("Boolean")}} представляє логічну сутність і населений двома значеннями: `true` і `false`.

Булеві значення зазвичай використовується в умовних операціях, серед яких [тернарні оператори](/uk/docs/Web/JavaScript/Reference/Operators/Conditional_operator), [`if...else`](/uk/docs/Web/JavaScript/Reference/Statements/if...else), [`while`](/uk/docs/Web/JavaScript/Reference/Statements/while) тощо.

### Тип Number

Тип {{jsxref("Number")}} є [64-бітовим значенням двійкового формату IEEE 754 подвійної точності](/uk/docs/Web/JavaScript/Reference/Global_Objects/Number#koduvannia-number). Він здатний зберігати додатні числа з рухомою комою між 2<sup>-1074</sup> ({{jsxref("Number.MIN_VALUE")}}) і 2<sup>1023</sup> × (2 - 2<sup>-52</sup>) ({{jsxref("Number.MAX_VALUE")}}), а також від'ємні числа з рухомою комою аналогічного діапазону, але може надійно зберігати цілі числа лише в діапазоні від -(2<sup>53</sup> − 1) ({{jsxref("Number.MIN_SAFE_INTEGER")}}) до 2<sup>53</sup> − 1 ({{jsxref("Number.MAX_SAFE_INTEGER")}}). Поза цим діапазоном JavaScript не може надійно представляти цілі числа; замість цього вони представляються у вигляді наближення з рухомою комою подвійної точності. Перевірити число на попадання в діапазон надійних цілих чисел можна за допомогою {{jsxref("Number.isSafeInteger()")}}.

Значення поза діапазоном, числа якого можна подати з точністю, автоматично перетворюються:

- Додатні значення, більші за {{jsxref("Number.MAX_VALUE")}}, перетворюються на `+Infinity`.
- Додатні значення, менші за {{jsxref("Number.MIN_VALUE")}}, перетворюються на `+0`.
- Від'ємні значення, менші за -{{jsxref("Number.MAX_VALUE")}}, перетворюються на `-Infinity`.
- Від'ємні значення, більші за -{{jsxref("Number.MIN_VALUE")}}, перетворюються на `-0`.

`+Infinity` і `-Infinity` поводяться подібно до математичної нескінченності, але з певними невеликими відмінностями; за подробицями зверніться до {{jsxref("Number.POSITIVE_INFINITY")}} і {{jsxref("Number.NEGATIVE_INFINITY")}}.

Тип Number має лише одне значення з кількома представленнями: `0` представлений і як `-0`, і як `+0` (де `0` – псевдонім для `+0`). На практиці між різними представленнями майже немає різниці; наприклад, `+0 === -0` дає `true`. Проте різницю можна помітити, якщо поділити на нуль:

```js
console.log(42 / +0); // Infinity
console.log(42 / -0); // -Infinity
```

{{jsxref("NaN")}} ("**N**ot **a** **N**umber" – "не число") – числове значення особливого роду, котре зазвичай зустрічається, коли результат арифметичної операції не може бути представлений у вигляді числа. Крім цього, це єдине значення в JavaScript, котре не рівне саме собі.

Попри те, що число концептуально є "математичним значенням" і завжди неявно кодується з рухомою комою, JavaScript пропонує [бітові оператори](/uk/docs/Web/JavaScript/Guide/Expressions_and_operators#bitovi-operatory). При застосуванні бітових операторів число спершу перетворюється на 32-бітове ціле.

> **Примітка:** Попри те, що бітові оператори _можуть_ використовуватися для представлення декількох булевих значень в межах одного числа за допомогою [бітового маскування](<https://uk.wikipedia.org/wiki/%D0%9C%D0%B0%D1%81%D0%BA%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F)>), такий код зазвичай вважається недоброю практикою. JavaScript надає інші засоби для представлення набору булевих значень (як то масив булевих значень чи об'єкт з булевими значеннями, присвоєними іменованим властивостям). Бітове маскування має тенденцію до ускладнення читання, розуміння й підтримки коду.

Такі методики можуть знадобитися в украй обмежених середовищах, як то при намаганні справитись з обмеженнями локального сховища, або в крайніх випадках (як то коли грає роль кожен переданий через мережу біт). Така методика повинна розглядатися лише тоді, коли це останній доступний для оптимізації розміру варіант.

### Тип BigInt

Тип {{jsxref("BigInt")}} – числовий примітив JavaScript, що може представляти цілі числа з довільною точністю. За допомогою BigInt можна надійно зберігати й використовувати великі цілі числа, котрі лежать поза межею надійних цілих чисел ({{jsxref("Number.MAX_SAFE_INTEGER")}}) для Number.

Значення BigInt створюється шляхом додавання `n` у кінець цілого числа чи викликом функції [`BigInt()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/BigInt/BigInt).

Наступний приклад показує, як збільшення {{jsxref("Number.MAX_SAFE_INTEGER")}} на одиницю повертає очікуваний результат

```js
// BigInt
const x = BigInt(Number.MAX_SAFE_INTEGER); // 9007199254740991n
x + 1n === x + 2n; // false, адже 9007199254740992n і 9007199254740993n не рівні одне одному

// Number
Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2; // true, адже обидва значення рівні 9007199254740992
```

З BigInt можна використовувати більшість операторів, у тому числі `+`, `*`, `-`, `**` і `%`: єдиний заборонений оператор – [`>>>`](/uk/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift). BigInt не має [строгої рівності](/uk/docs/Web/JavaScript/Reference/Operators/Strict_equality) щодо Number з таким само математичним значенням, але має [нестрогу](/uk/docs/Web/JavaScript/Reference/Operators/Equality).

Значення BigInt не є ані завжди більш точними, ані завжди менш точними за звичайні числа, адже BigInt не може представляти дробові числа, зате може з більшою точністю представляти великі цілі. Жоден з цих типів не тягне за собою інший, і вони не є взаємозамінними. Викидається {{jsxref("TypeError")}}, коли значення BigInt змішуються зі звичайними числами в арифметичних виразах, або коли ці типи [неявно перетворюються](/uk/docs/Web/JavaScript/Reference/Global_Objects/Number#zvedennia-do-chysla) один на одного.

### Тип String

Тип {{jsxref("String")}} представляє текстові дані й кодується як послідовність 16-бітових беззнакових цілочислових значень, що представляють [кодові одиниці UTF-16](/uk/docs/Web/JavaScript/Reference/Global_Objects/String#symvoly-utf-16-kodovi-tochky-unicode-ta-hrafemni-klastery). Кожний елемент рядка займає в ньому якусь позицію. Перший елемент розташований за індексом `0`, наступний – за індексом `1`, і так далі. [Довжина](/uk/docs/Web/JavaScript/Reference/Global_Objects/String/length) рядка – число кодових одиниць UTF-16 у ньому, що може не відповідати реальній кількості символів Unicode; дивіться подробиці на довідковій сторінці [`String`](/uk/docs/Web/JavaScript/Reference/Global_Objects/String#symvoly-utf-16-kodovi-tochky-unicode-ta-hrafemni-klastery).

Рядки JavaScript є незмінними. Це означає, що відколи рядок створений, його неможливо змінити. Методи рядка створюють нові рядки на основі вмісту поточного – наприклад:

- Підрядок вихідного рядка – за допомогою [`substring()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/String/substring).
- Зчеплення двох рядків за допомогою оператора зчеплення (`+`) або метода [`concat()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/String/concat).

#### Обережно з "рядковим типуванням" коду!

Використання рядків для представлення складних даних може здаватись спокусливим. Це надає короткострокові переваги:

- Легко формувати складні рядки за допомогою зчеплення.
- Рядки легко зневаджувати (те, що надруковано – завжди саме те, що знаходиться в рядку).
- Рядки є спільним знаменником багатьох API ([полів введення](/uk/docs/Web/API/HTMLInputElement), значень [локального сховища](/uk/docs/Web/API/Web_Storage_API), відповідей [`fetch()`](/uk/docs/Web/API/fetch) при використанні {{domxref("Response.text()")}} тощо), і може здаватись спокусливим працювати лише з рядками.

За допомогою певних домовленостей можна представити будь-яку структуру даних як рядок. Проте це не робить таку ідею доброю. Наприклад, можна імітувати список за допомогою розділювача (при тому, що масив JavaScript є більш підхожим). На жаль, коли розділювач зустрічається в одному з елементів "списку", список буде зламано. Можна обрати символ екранування тощо. Все це вимагає домовленостей і накладає зайвий тягар підтримування.

Рядки слід використовувати для текстових даних. При представленні складних даних слід _розбирати_ рядки й використовувати відповідну абстракцію.

### Тип Symbol

Символ – це **унікальне** та **незмінне** примітивне значення, що може використовуватися як ключ властивості об'єкта (дивіться нижче). У певних мовах програмування символи звуть "атомами". Призначення символів – утворювати унікальні ключі властивостей, котрі гарантовано не конфліктують з ключами іншого коду.

## Об'єкти

В комп'ютерній науці об'єкт – це значення в пам'яті, на котре може існувати посилання за допомогою [ідентифікатора](/uk/docs/Glossary/Identifier). У JavaScript об'єкти – єдині [мінливі](/uk/docs/Glossary/Mutable) значення. [Функції](/uk/docs/Web/JavaScript/Reference/Functions) фактично також є об'єктами, з додатковою можливістю – _викличністю_.

### Властивості

У JavaScript об'єкти можуть розглядатися як колекції властивостей. За допомогою [синтаксису об'єктного літерала](/uk/docs/Web/JavaScript/Guide/Grammar_and_types#literaly-obiektiv) ініціалізується обмежений набір властивостей; після цього властивості можна додавати й видаляти. Властивості об'єктів рівносильні парам ключ-значення. Ключі властивостей є або [рядками](#typ-string), або [символами](#typ-symbol). Коли для індексування об'єктів використовуються інші типи (наприклад, число), то такі значення неявно перетворюються на рядки. Значення властивостей можуть бути значеннями будь-яких типів, включно з іншими об'єктами, що дає змогу вибудовувати складні структури даних.

Є два типи властивостей об'єкта: [властивість _даних_](#vlastyvist-danykh) і [властивість _доступу_](#vlastyvist-dostupu). Кожна властивість має відповідні _атрибути_. Рушій JavaScript внутрішньо звертається до кожного атрибута, задати ж ці атрибути можна за допомогою {{jsxref("Object.defineProperty()")}}, а отримати – за допомогою {{jsxref("Object.getOwnPropertyDescriptor()")}}. Більше про різні нюанси – на сторінці {{jsxref("Object.defineProperty()")}}.

#### Властивість даних

Властивості даних пов'язують ключ зі значенням. Вони можуть бути описані наступними атрибутами:

- `value`
  - : Значення, отримане звертанням для отримання властивості. Може бути будь-яким значенням JavaScript.
- `writable`
  - : Булеве значення, котре вказує, чи може властивість бути змінена шляхом присвоєння.
- `enumerable`
  - : Булеве значення, котре вказує, чи може властивість бути перелічена в циклі [`for...in`](/uk/docs/Web/JavaScript/Reference/Statements/for...in). Про те, як перелічуваність взаємодіє з іншими функціями й синтаксичними конструкціями – на сторінці [Перелічуваність та власність властивостей](/uk/docs/Web/JavaScript/Enumerability_and_ownership_of_properties).
- `configurable`
  - : Булеве значення, котре вказує, чи може властивість бути видалена, перетворена на властивість доступу і чи можуть бути змінені її атрибути.

#### Властивість доступу

Зв'язує ключ з однією чи двома функціями доступу (`get` і `set`) для отримання чи збереження значення.

> **Примітка:** Важливо розуміти, що мова про _властивість_ доступу – не _метод_ доступу. Можна додати об'єктові JavaScript функції доступу, як в класу, шляхом використання функцій як значень – але це не зробить об'єкт класом.

Властивість доступу має наступні атрибути:

- `get`
  - : Функція, що викликається з порожнім списком аргументів для отримання значення властивості, коли виконується операція отримання значення. Більше - на сторінці [гетерів](/uk/docs/Web/JavaScript/Reference/Functions/get). Може мати значення `undefined`.
- `set`
  - : Функція, що викликається з аргументом, котрий містить присвоюване значення. Виконується щоразу, коли відповідну властивість намагаються змінити. Більше – на сторінці [сетерів](/uk/docs/Web/JavaScript/Reference/Functions/set). Може мати значення `undefined`.
- `enumerable`
  - : Булеве значення, що вказує, чи може властивість бути перелічена в циклі [`for...in`](/uk/docs/Web/JavaScript/Reference/Statements/for...in). Про те, як перелічуваність взаємодіє з іншими функціями й синтаксичними конструкціями – на сторінці [Перелічуваність та власність властивостей](/uk/docs/Web/JavaScript/Enumerability_and_ownership_of_properties).
- `configurable`
  - : Булеве значення, що вказує, чи може властивість бути видалена, перетворена на властивість даних і чи можуть її атрибути бути змінені.

[Прототип](/uk/docs/Web/JavaScript/Inheritance_and_the_prototype_chain) об'єкта вказує на інший об'єкт або на `null` – це концептуально прихована властивість об'єкта, загальноприйнято представлена як `[[Prototype]]`. До властивостей `[[Prototype]]` об'єкта можна звернутися також на самому об'єкті.

Об'єкти – пари ключ-значення, тож вони нерідко використовуються як відображення. Проте це може складати проблему щодо ергономіки, безпеки та швидкодії. Замість цього слід використовувати для зберігання довільних даних {{jsxref("Map")}}. [Довідка `Map`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Map#porivniannia-object-ta-map) містить більш докладне обговорення переваг і недоліків використання простих об'єктів та відображень для запису асоціацій ключ-значення.

### Дати

Для представлення дат у JavaScript найкращим варіантом є використання вбудованих значень [`Date`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Date).

### Індексовані колекції: масиви й типізовані масиви

[Масиви](/uk/docs/Web/JavaScript/Reference/Global_Objects/Array) – звичайні об'єкти, для котрих є особливий зв'язок між цілочисловими властивостями й властивістю `length`.

Крім того, масиви успадковують прототип `Array.prototype`, котрий надає жменю зручних методів для обробки масивів. Наприклад, [`indexOf()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) шукає значення в масиві, [`push()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Array/push) додає елемент до масиву, і так далі. Це робить масиви досконалим кандидатом для представлення впорядкованих списків.

[Типізовані масиви](/uk/docs/Web/JavaScript/Guide/Typed_arrays) пропонують подібний до масиву прихований двійковий буфер даних і чимало методів, що мають семантику, що нагадує семантику їх аналогів для масиву. "Типізований масив" – узагальнення низки структур даних, в тому числі `Int8Array`, `Float32Array` тощо. Докладніше про це на сторінці [типізованого масиву](/uk/docs/Web/JavaScript/Guide/Typed_arrays). Типізовані масиви нерідко використовуються у поєднанні з {{jsxref("ArrayBuffer")}} і {{jsxref("DataView")}}.

### Ключеві колекції: Map, Set, WeakMap, WeakSet

Ці структури даних приймають посилання на об'єкти за ключі. {{jsxref("Set")}} і {{jsxref("WeakSet")}} представляють колекції унікальних значень, а {{jsxref("Map")}} і {{jsxref("WeakMap")}} — колекції асоціацій ключ-значення.

Різниця між `Map` і `WeakMap` у тому, що в першій ключі об'єкта можуть бути перелічені. Це дозволяє оптимізувати прибирання сміття у випадку другої структури.

`Map` і `Set` можна реалізувати самотужки. Проте оскільки об'єкти не можуть порівнюватися (в тому розумінні, в якому порівнює, наприклад, `<` "менше ніж"), а також оскільки рушій не дає доступу до його геш-функції для об'єктів, швидкодія операції пошуку обов'язково буде лінійною. Нативні реалізації цих структур даних (включно з `WeakMap`) можуть мати швидкодію пошуку, що лежить між логарифмічною та сталою.

Зазвичай для пов'язування даних з вузлом DOM можна задавати властивості напряму на об'єкті, або використовувати атрибути `data-*`. Недолік такого підходу – те, що такі дані доступні будь-якому сценарієві, котрий працює в тому самому контексті. `Map` і `WeakMap` дають змогу легко і _приватно_ пов'язати дані з об'єктом.

`WeakMap` і `WeakSet` дозволяють як ключі виключно значення, що можуть бути прибрані збирачем сміття, тобто або об'єкти, або [нереєстрові символи](/uk/docs/Web/JavaScript/Reference/Global_Objects/Symbol#spilni-symvoly-u-hlobalnomu-reiestri-symvoliv), і такі ключі можуть бути прибрані навіть тоді, коли ще присутні в колекції. Такі колекції використовуються спеціально для [оптимізації використання пам'яті](/uk/docs/Web/JavaScript/Memory_management#struktury-danykh-shcho-dopomahaiut-z-upravlinniam-pamiattiu).

### Структуровані дані: JSON

JSON (**J**ava**S**cript **O**bject **N**otation – запис об'єктів JavaScript) – це легковагий формат обміну даних, похідний від JavaScript, що, однак, використовується в багатьох мовах програмування. JSON вибудовує універсальні структури даних, що можуть бути передані між різними середовищами, і навіть між різними мовами. Дивіться подробиці в {{jsxref("JSON")}}.

### Більше об'єктів стандартної бібліотеки

JavaScript має стандартну бібліотеку вбудованих об'єктів. Прочитайте [довідник](/uk/docs/Web/JavaScript/Reference/Global_Objects), аби дізнатися більше про вбудовані об'єкти.

## Зведення типів

Як згадувалося вище, JavaScript є [слабко типізованою](#dynamichna-i-slabka-typizatsiia) мовою. Це означає, що нерідко можна використати значення одного типу там, де очікується інший тип, і мова перетворить значення до коректного типу за вас. Для цієї потреби JavaScript визначає певні правила зведення.

### Зведення до примітива

Процес [зведення до примітива](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-toprimitive) використовується, коли очікується примітивне значення, але немає конкретних вимог щодо того, якого саме типу має бути це значення. Так трапляється зазвичай тоді, коли однаково прийнятними є [рядок](#typ-string), [число](#typ-number) і [BigInt](#typ-bigint). Наприклад:

- Конструктор [`Date()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Date/Date), коли він отримує один аргумент, що не є примірником `Date`: рядки представляють рядки дат, натомість числа – мітки часу.
- Оператор [`+`](/uk/docs/Web/JavaScript/Reference/Operators/Addition): якщо один з операндів є рядком, то виконується зчеплення, інакше – арифметичне додавання.
- Оператор [`==`](/uk/docs/Web/JavaScript/Reference/Operators/Equality): якщо один з операндів є примітивом, а інший – об'єктом, то об'єкт перетворюється на примітивне значення без преференцій у бік конкретного типу.

Ця операція не виконує жодних перетворень, якщо значення вже є примітивом. Об'єкти перетворюються на примітиви шляхом виклику їх методів [`[Symbol.toPrimitive]()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive) (з підказкою `"default"`), `valueOf()` та `toString()` – у такому порядку. Зверніть увагу, що перетворення на примітив викликає `valueOf()` раніше, ніж `toString()`, що подібно до логіки [зведення до числа](/uk/docs/Web/JavaScript/Reference/Global_Objects/Number#zvedennia-do-chysla), але відрізняється від [зведення до рядка](/uk/docs/Web/JavaScript/Reference/Global_Objects/String#zvedennia-do-riadka).

Метод `[Symbol.toPrimitive]()`, якщо є, мусить повертати примітив: повернення об'єкта призведе до {{jsxref("TypeError")}}. Що до `valueOf()` і `toString()`, то якщо якийсь із цих методів поверне об'єкт, то таке повернене значення ігнорується, і натомість використовується повернене значення іншого методу. Якщо такого методу немає, або якщо жоден з методів не повернув примітива, то викидається {{jsxref("TypeError")}}. Наприклад, у наступному коді:

```js
console.log({} + []); // "[object Object]"
```

Neither `{}` nor `[]` has a `[Symbol.toPrimitive]()` method. Both `{}` and `[]` inherit `valueOf()` from {{jsxref("Object.prototype.valueOf")}}, which returns the object itself. Since the return value is an object, it is ignored. Therefore, `toString()` is called instead. [`{}.toString()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/toString) returns `"[object Object]"`, while [`[].toString()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Array/toString) returns `""`, so the result is their concatenation: `"[object Object]"`.

Метод `[Symbol.toPrimitive]()` завжди має пріоритет над перетворенням на будь-який конкретний примітивний тип. Перетворення на примітив здебільшого працює як перетворення на число, тому що першим викликається `valueOf()`; проте об'єкти з самописними методами `[Symbol.toPrimitive]()` можуть вирішити повернути будь-який примітив. Об'єкти {{jsxref("Date")}} і {{jsxref("Symbol")}} – єдині вбудовані об'єкти, що визначають власні методи `[Symbol.toPrimitive]()`. [`Date.prototype[Symbol.toPrimitive]()`](<(/uk/docs/Web/JavaScript/Reference/Global_Objects/Date/Symbol.toPrimitive)>) обробляє підказку `"default"` як ніби це `"string"`, натомість [`Symbol.prototype[Symbol.toPrimitive]()`](<(/uk/docs/Web/JavaScript/Reference/Global_Objects/Symbol/Symbol.toPrimitive)>) ігнорує підказку і завжди повертає символ.

### Зведення до числового

Є два числові типи: [Number](#typ-number) і [BigInt](#typ-bigint). Іноді мова очікує конкретно число або конкретно BigInt (наприклад, {{jsxref("Array.prototype.slice()")}}, для якого індекс мусить бути числом); в інших випадках можуть прийматися обидва типи й виконуватися різні операції залежно від типу операнда. Щодо процесів зведення до рядка, котрі не дозволяють неявного перетворення з інших типів, дивіться [зведення до числа](/uk/docs/Web/JavaScript/Reference/Global_Objects/Number#zvedennia-do-chysla) і [зведення до BigInt](/uk/docs/Web/JavaScript/Reference/Global_Objects/BigInt#zvedennia-do-bigint).

Числове зведення – майже таке ж, як [зведення до числа](/uk/docs/Web/JavaScript/Reference/Global_Objects/Number#zvedennia-do-chysla), окрім того, що значення BigInt повертаються як є, а не спричиняють {{jsxref("TypeError")}}. Числове зведення використовується всіма арифметичними операторами, адже вони визначені як для чисел, так і для BigInt. Єдиний виняток – [унарний плюс](/uk/docs/Web/JavaScript/Reference/Operators/Unary_plus), котрий завжди виконує зведення до числа.

### Інші зведення

Усі типи даних, окрім Null, Undefined та Symbol, мають власні процеси зведення. Шукайте подробиці у [зведенні до рядка](/uk/docs/Web/JavaScript/Reference/Global_Objects/String#zvedennia-do-riadka), [зведенні до булевого](/uk/docs/Web/JavaScript/Reference/Global_Objects/Boolean#zvedennia-do-bulevoho) та [зведенні до об'єкта](/uk/docs/Web/JavaScript/Reference/Global_Objects/Object#zvedennia-do-obiekta).

Як можна було помітити, є три відмінні шляхи, якими об'єкти можуть бути перетворені на примітиви:

- [Зведення до примітива](#zvedennia-do-prymityva): `[Symbol.toPrimitive]("default")` → `valueOf()` → `toString()`
- [Зведення до числового](#zvedennia-do-chyslovoho), [зведення до числа](/uk/docs/Web/JavaScript/Reference/Global_Objects/Number#zvedennia-do-chysla), [зведення до BigInt](/uk/docs/Web/JavaScript/Reference/Global_Objects/BigInt#zvedennia-do-bigint): `[Symbol.toPrimitive]("number")` → `valueOf()` → `toString()`
- [Зведення до рядка](/uk/docs/Web/JavaScript/Reference/Global_Objects/String#zvedennia-do-riadka): `[Symbol.toPrimitive]("string")` → `toString()` → `valueOf()`

У всіх випадках властивість `[Symbol.toPrimitive]()`, якщо є, мусить бути викличною та повертати примітив, натомість `valueOf` і `toString` ігноруватимуться, якщо не є викличними або повертають об'єкт. У кінці процесу, якщо він успішний, результат гарантовано є примітивом. Після цього результівний примітив підлягає подальшому зведенню, залежно від контексту.

## Дивіться також

- [Структури даних та алгоритми JavaScript](https://github.com/trekhleb/javascript-algorithms) від Олексія Трехлеба
- [Інформатика в JavaScript](https://github.com/humanwhocodes/computer-science-in-javascript) від Ніколаса Закаса
