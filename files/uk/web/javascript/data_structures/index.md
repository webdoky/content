---
title: Типи даних та структури даних JavaScript
slug: Web/JavaScript/Data_structures
tags:
  - Beginner
  - Guide
  - JavaScript
  - Types
---

{{jsSidebar("More")}}

Усі мови програмування мають вбудовані структури даних, але вони поміж цих мов нерідко різняться. Ця стаття має на меті перелічити вбудовані структури даних, доступні в JavaScript, та притаманні їм властивості. На основі них можна будувати інші структури даних. Там, де це можливо, наведені порівняння з іншими мовами.

## Динамічна і слабка типізація

JavaScript – це [динамічна](https://uk.wikipedia.org/wiki/%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D1%96%D1%87%D0%BD%D0%B0_%D0%BC%D0%BE%D0%B2%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F) мова програмування з [динамічними типами](https://uk.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%82%D0%B8%D0%BF%D1%96%D0%B7%D0%B0%D1%86%D1%96%D1%97#%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D1%96%D1%87%D0%BD%D0%B0_%D1%82%D0%B8%D0%BF%D1%96%D0%B7%D0%B0%D1%86%D1%96%D1%8F). Змінні в JavaScript не пов'язані напряму з жодним конкретним типом даних, і будь-якій змінній можуть бути присвоєні (й присвоєні знову) значення всіх типів:

```js
let foo = 42; // тепер foo – число
foo = "bar"; // тепер foo – рядок
foo = true; // тепер foo – булеве значення
```

Крім того, JavaScript – це [слабко типізована (англ.)](https://en.wikipedia.org/wiki/Strong_and_weak_typing) мова, тобто вона дозволяє неявне приведення типів, коли операція залучає типи, що не збігаються, замість викидання помилок типів.

```js
const foo = 42; // foo є числом
const result = foo + "1"; // JavaScript зводить foo до рядка, щоб його можна було склеїти з іншим операндом
console.log(result); // 421
```

Неявне зведення типів - це дуже зручно, але може призводити до пострілів у ногу, коли розробники не мають на меті зведення, або мають на меті зведення в іншому напрямку (наприклад, рядків до чисел, а не чисел до рядків). Для [символів](#typ-symbol) та [BigInt](#typ-bigint) JavaScript свідомо забороняє певні неявні перетворення типів.

## Типи JavaScript

Палітра типів у мові JavaScript складається з [_примітивних значень_](#prymityvni-znachennia) та [_об'єктів_](#obiekty).

- [Примітивні значення](#prymityvni-znachennia) (незмінні одиниці даних, безпосередньо представлені на найнижчому рівні мови)

  - [Тип Boolean](#typ-boolean)
  - [Тип Null](#typ-null)
  - [Тип Undefined](#typ-undefined)
  - [Тип Number](#typ-number)
  - [Тип BigInt](#typ-bigint)
  - [Тип String](#typ-string)
  - [Тип Symbol](#typ-symbol)

- [Об'єкти](#obiekty) (колекції властивостей)

## Примітивні значення

Всі типи, крім об'єктів, визначають незмінні значення (тобто значення, що не можуть бути змінені). Наприклад, рядки – незмінні. Значення таких типів звуть "_примітивними значеннями_".

### Тип Boolean

Булів тип представляє логічну сутність і може мати два значення: `true` (істинність) і `false` (хибність). Для отримання подробиць дивіться [Boolean](/uk/docs/Glossary/Boolean) і {{jsxref("Boolean")}} for more details.

### Тип Null

Тип Null має виключно одне значення: `null`. Для отримання подробиць дивіться [`null`](/uk/docs/Web/JavaScript/Reference/Operators/null) і [Null](/uk/docs/Glossary/Null).

### Тип Undefined

Змінна, котрій не було присвоєно значення, має значення `undefined`. Для отримання подробиць дивіться {{jsxref("undefined")}} і [Undefined](/uk/docs/Glossary/undefined).

### Числові типи

ECMAScript має два вбудовані числові типи: [Number](#typ-number) і [BigInt](#typ-bigint) — поруч із пов'язаним з ними значенням [NaN](#nan).

#### Тип Number

Тип Number є [64-бітним значенням двійкового формату IEEE 754 подвійної точності](https://uk.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D0%BC%D0%B0%D1%82_%D1%80%D1%83%D1%85%D0%BE%D0%BC%D0%BE%D1%97_%D0%BA%D0%BE%D0%BC%D0%B8_%D0%B7_%D0%BF%D0%BE%D0%B4%D0%B2%D1%96%D0%B9%D0%BD%D0%BE%D1%8E_%D1%82%D0%BE%D1%87%D0%BD%D1%96%D1%81%D1%82%D1%8E). Він здатний зберігати додатні числа з рухомою комою між 2^-1074 ({{jsxref("Number.MIN_VALUE")}}) і 2^1024 ({{jsxref("Number.MAX_VALUE")}}), а також від'ємні числа з рухомою комою між -(2^-1074) і -(2^1024), але може надійно зберігати цілі числа лише в діапазоні від -(2^53 − 1) ({{jsxref("Number.MIN_SAFE_INTEGER")}}) до 2^53 − 1 ({{jsxref("Number.MAX_SAFE_INTEGER")}}).

> **Примітка:** Можна перевірити, чи лежить число в діапазоні надійних цілих чисел, за допомогою {{jsxref("Number.isSafeInteger()")}}. Поза діапазоном між {{jsxref("Number.MIN_SAFE_INTEGER")}} і {{jsxref("Number.MAX_SAFE_INTEGER")}} JavaScript не може гарантувати надійного представлення цілих чисел; натомість вони будуть представлені у вигляді наближення з рухомою комою подвійної точності.

Значення поза діапазоном ±(від 2^-1074 до 2^1024) автоматично перетворюються:

- Додатні значення, більші за {{jsxref("Number.MAX_VALUE")}}, перетворюються на `+Infinity`.
- Додатні значення, менші за {{jsxref("Number.MIN_VALUE")}}, перетворюються на `+0`.
- Від'ємні значення, менші за -{{jsxref("Number.MAX_VALUE")}}, перетворюються на `-Infinity`.
- Від'ємні значення, більші за -{{jsxref("Number.MIN_VALUE")}}, перетворюються на `-0`.

`+Infinity` і `-Infinity` поводяться подібно до математичної нескінченності, але з певними невеликими відмінностями; за подробицями зверніться до {{jsxref("Number.POSITIVE_INFINITY")}} і {{jsxref("Number.NEGATIVE_INFINITY")}}.

Тип Number має лише одне ціле число з кількома представленнями: `0` представлений і як `-0`, і як `+0` (де `0` – псевдонім для `+0`). На практиці між різними представленнями майже немає різниці; наприклад, `+0 === -0` дає `true`. Проте різницю можна помітити, якщо поділити на нуль:

```js
console.log(42 / +0); // Infinity
console.log(42 / -0); // -Infinity
```

Попри те, що число нерідко представляє лише своє значення, JavaScript пропонує [бітові оператори](/uk/docs/Web/JavaScript/Guide/Expressions_and_Operators#bitovi-operatory).

> **Примітка:** Попри те, що бітові оператори _можуть_ використовуватися для представлення декількох булевих значень в межах одного числа за допомогою [бітового маскування](<https://uk.wikipedia.org/wiki/%D0%9C%D0%B0%D1%81%D0%BA%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F)>), такий код зазвичай вважається недоброю практикою. JavaScript надає інші засоби для представлення набору булевих значень (як то масив булевих значень чи об'єкт з булевими значеннями, присвоєними іменованим властивостям). Бітове маскування має тенденцію до ускладнення читання, розуміння й підтримки коду.

Такі методики можуть знадобитися в украй обмежених середовищах, як то при намаганні справитись з обмеженнями локального сховища, або в крайніх випадках (як то коли грає роль кожен переданий через мережу біт). Така методика повинна розглядатися лише тоді, коли це останній доступний для оптимізації розміру варіант.

#### Тип BigInt

Тип BigInt є числовим примітивом JavaScript, що може представляти цілі числа з довільною точністю. За допомогою BigInt можна надійно зберігати й використовувати великі цілі числа, котрі лежать поза межами надійних цілих чисел для Number.

Значення BigInt створюється шляхом додавання `n` у кінець цілого числа чи викликом конструктора.

Найбільше безпечне значення, до котрого можна дійти в межах типу Number, можна отримати за допомогою сталої {{jsxref("Number.MAX_SAFE_INTEGER")}}. Після запровадження BigInt можна працювати з числами за межею {{jsxref("Number.MAX_SAFE_INTEGER")}}.

Наступний приклад показує, як збільшення {{jsxref("Number.MAX_SAFE_INTEGER")}} на одиницю повертає очікуваний результат

```js
// BigInt
const x = BigInt(Number.MAX_SAFE_INTEGER); // 9007199254740991n
x + 1n === x + 2n; // false, адже 9007199254740992n і 9007199254740993n не рівні одне одному

// Number
Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2; // true, адже обидва значення рівні 9007199254740992
```

З BigInt можна використовувати оператори `+`, `*`, `-`, `**` і `%` – як і з Number. BigInt не має строгої рівності щодо Number, але має нестрогу.

BigInt поводиться як Number, коли перетворюється на булеве значення: `if`, `||`, `&&`, `Boolean`, `!`.

Значення `BigInt` не можуть оброблятися як взаємозамінні щодо Number. Замість цього буде викинуто {{jsxref("TypeError")}}.

#### NaN

{{jsxref("NaN")}} ("**N**ot a **N**umber" – "не число") зазвичай зустрічається як результат арифметичної операції, котрий не може бути виражений як число. Крім того, це єдине значення JavaScript, котре не рівне саме собі.

### Тип String

Тип рядка JavaScript використовується для представлення текстових даних. Це набір "елементів" із 16-бітових беззнакових цілих чисел. Кожний елемент String займає позицію в рядку. Перший елемент розташований за індексом `0`, наступний – за індексом `1`, і так далі. Довжина рядка – число елементів у ньому.

Рядки JavaScript є незмінними. Це означає, що відколи рядок створений, його неможливо змінити.

Проте можливо створити інший рядок на основі операції над вихідним рядком. Наприклад:

- Підрядок вихідного – за допомогою вибору окремих літер чи метода [`substring()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/String/substring).
- Зчеплення двох рядків за допомогою оператора зчеплення (`+`) або метода [`concat()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/String/concat).

#### Обережно з "рядковим типуванням" коду!

Може здаватись спокусливим використання рядків для представлення складних даних. Це надає короткострокові переваги:

- Легко формувати складні рядки за допомогою зчеплення.
- Рядки легко зневаджувати (те, що надруковано – завжди саме те, що знаходиться в рядку).
- Рядки є спільним знаменником багатьох API ([полів введення](/uk/docs/Web/API/HTMLInputElement), значень [локального сховища](/uk/docs/Web/API/Web_Storage_API), відповідей [`XMLHttpRequest`](/uk/docs/Web/API/XMLHttpRequest) при використанні `responseText` тощо), і може здаватись спокусливим працювати лише з рядками.

За допомогою певних домовленостей можна представити будь-яку структуру даних як рядок. Проте це не робить таку ідею доброю. Наприклад, можна імітувати список за допомогою розділювача (при тому, що масив JavaScript є більш підхожим). На жаль, коли розділювач зустрічається в одному з елементів "списку", список буде зламано. Можна обрати символ екранування тощо. Все це вимагає домовленостей і накладає зайвий тягар підтримування.

Рядки слід використовувати для текстових даних. При представленні складних даних слід _розбирати_ рядки й використовувати відповідну абстракцію.

### Тип Symbol

Символ – це **унікальне** та **незмінне** примітивне значення, що може використовуватися як ключ властивості об'єкта (дивіться нижче). У певних мовах програмування символи звуть "атомами".

Більше подробиць на довідковій сторінці {{jsxref("Symbol")}}.

## Об'єкти

В комп'ютерній науці об'єкт – це значення в пам'яті, на котре може існувати посилання за допомогою [ідентифікатора](/uk/docs/Glossary/Identifier).

### Властивості

У JavaScript об'єкти можуть розглядатися як колекції властивостей. За допомогою [синтаксису об'єктного літерала](/uk/docs/Web/JavaScript/Guide/Grammar_and_types#obiektni-literaly) ініціалізується обмежений набір властивостей; після цього властивості можна додавати й видаляти. Значення властивостей можуть бути значеннями будь-якого типу, включно з іншими об'єктами, що дає змогу будувати складні структури даних. Властивості ідентифікуються за _ключовими_ значенням. _Ключове_ значення – або {{Glossary("String", "рядкове значення")}}, або [значення Symbol](/uk/docs/Web/JavaScript/Reference/Global_Objects/Symbol).

Є два типи властивостей об'єкта: [властивість _даних_](#vlastyvist-danykh) і [властивість _доступу_](#vlastyvist-dostupu). Кожна властивість має відповідні _атрибути_. Рушій JavaScript внутрішньо звертається до кожного атрибута, задати ж ці атрибути можна за допомогою {{jsxref("Object.defineProperty()")}}, а отримати – за допомогою {{jsxref("Object.getOwnPropertyDescriptor()")}}. Більше про різні нюанси – на сторінці {{jsxref("Object.defineProperty()")}}.

#### Властивість даних

Властивості даних пов'язують ключ зі значенням. Вони можуть бути описані наступними атрибутами:

- `value`
  - : Значення, отримане звертанням для отримання властивості. Може бути будь-яким значенням JavaScript.
- `writable`
  - : Булеве значення, котре вказує, чи може властивість бути змінена шляхом присвоєння.
- `enumerable`
  - : Булеве значення, котре вказує, чи може властивість бути перелічена в циклі [`for...in`](/uk/docs/Web/JavaScript/Reference/Statements/for...in). Про те, як перелічуваність взаємодіє з іншими функціями й синтаксичними конструкціями – на сторінці [Перелічуваність та власність властивостей](/uk/docs/Web/JavaScript/Enumerability_and_ownership_of_properties).
- `configurable`
  - : Булеве значення, котре вказує, чи може властивість бути видалена, перетворена на властивість доступу і чи можуть бути змінені її атрибути.

#### Властивість доступу

Зв'язує ключ з однією чи двома функціями доступу (`get` і `set`) для отримання чи збереження значення.

> **Примітка:** Важливо розуміти, що мова про _властивість_ доступу – не _метод_ доступу. Можна додати об'єктові JavaScript функції доступу, як в класу, шляхом використання функцій як значень – але це не зробить об'єкт класом.

Властивість доступу має наступні атрибути:

- `get`
  - : Функція, що викликається з порожнім списком аргументів для отримання значення властивості, коли виконується операція отримання значення. Більше - на сторінці [гетерів](/uk/docs/Web/JavaScript/Reference/Functions/get). Може мати значення `undefined`.
- `set`
  - : Функція, що викликається з аргументом, котрий містить присвоюване значення. Виконується щоразу, коли відповідну властивість намагаються змінити. Більше – на сторінці [сетерів](/uk/docs/Web/JavaScript/Reference/Functions/set). Може мати значення `undefined`.
- `enumerable`
  - : Булеве значення, що вказує, чи може властивість бути перелічена в циклі [`for...in`](/uk/docs/Web/JavaScript/Reference/Statements/for...in). Про те, як перелічуваність взаємодіє з іншими функціями й синтаксичними конструкціями – на сторінці [Перелічуваність та власність властивостей](/uk/docs/Web/JavaScript/Enumerability_and_ownership_of_properties).
- `configurable`
  - : Булеве значення, що вказує, чи може властивість бути видалена, перетворена на властивість даних і чи можуть її атрибути бути змінені.

### "Звичайні" об'єкти та функції

Об'єкт JavaScript є відображенням _ключів_ на _значення_. Ключі – це рядки (чи символи), а _значення_ можуть бути чим завгодно. Це робить об'єкти слушними для [геш-таблиць](https://uk.wikipedia.org/wiki/%D0%93%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8F).

Функції є звичайними об'єктами з додатковою можливістю _викличності_.

### Дати

Для представлення дат у JavaScript найкращим варіантом є використання вбудованих значень [`Date`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Date).

### Індексовані колекції: масиви й типізовані масиви

[Масиви](/uk/docs/Web/JavaScript/Reference/Global_Objects/Array) – звичайні об'єкти, для котрих є особливий зв'язок між цілочисловими властивостями й властивістю `length`.

Крім того, масиви успадковують прототип `Array.prototype`, котрий надає жменю зручних методів для обробки масивів. Наприклад, [`indexOf()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) (пошук значення в масиві) чи [`push()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Array/push) (додавання елемента до масиву), і так далі. Це робить масиви досконалим кандидатом для представлення списків чи наборів.

[Типізовані масиви](/uk/docs/Web/JavaScript/Typed_arrays) пропонують подібний до масиву прихований двійковий буфер даних і чимало методів, що мають семантику, що нагадує семантику їх аналогів для масиву. "Типізований масив" – узагальнення низки структур даних, в тому числі `Int8Array`, `Float32Array` тощо. Докладніше про це на сторінці [типізованого масиву](/uk/docs/Web/JavaScript/Typed_arrays).

### Ключеві колекції: Map, Set, WeakMap, WeakSet

Ці структури даних приймають посилання на об'єкти за ключі. {{jsxref("Set")}} і {{jsxref("WeakSet")}} представляють множини об'єктів, натомість {{jsxref("Map")}} і {{jsxref("WeakMap")}} пов'язують значення з об'єктом.

Різниця між `Map` і `WeakMap` у тому, що в першій ключі об'єкта можуть бути перелічені. Це дозволяє оптимізувати прибирання сміття у випадку другої структури.

`Map` і `Set` можна реалізувати самотужки. Проте оскільки об'єкти не можуть порівнюватися (в тому розумінні, в якому порівнює, наприклад, `<` "менше ніж"), а також оскільки рушій не дає доступу до його геш-функції для об'єктів, швидкодія операції пошуку обов'язково буде лінійною. Нативні реалізації цих структур даних (включно з `WeakMap`) можуть мати швидкодію пошуку, що лежить між логарифмічною та сталою.

Зазвичай для пов'язування даних з вузлом DOM можна задавати властивості напряму на об'єкті, або використовувати атрибути `data-*`. Недолік такого підходу – те, що такі дані доступні будь-якому сценарієві, котрий працює в тому самому контексті. `Map` і `WeakMap` дають змогу легко і _приватно_ пов'язати дані з об'єктом.

### Структуровані: JSON

JSON ("**J**ava**S**cript **O**bject **N**otation" – "об'єктний запис JavaScript") – легковаговий формат обміну даних, що походить від JavaScript, але використовується багатьма мовами програмування. JSON реалізовує загальновживані структури даних.

Більше подробиць – на сторінках [JSON](/uk/docs/Glossary/JSON) і {{jsxref("JSON")}}.

### Більше об'єктів стандартної бібліотеки

JavaScript має стандартну бібліотеку вбудованих об'єктів.

Про більше з них – у [довіднику](/uk/docs/Web/JavaScript/Reference/Global_Objects).

## Визначення типів за допомогою оператора `typeof`

Оператор `typeof` може допомогти з'ясувати тип змінної.

Більше подробиць і межові випадки – на [довідковій сторінці](/uk/docs/Web/JavaScript/Reference/Operators/typeof).

## Дивіться також

- [Структури даних і алгоритми JavaScript від Олексія Трехлеба](https://github.com/trekhleb/javascript-algorithms)
- [Колекція загальновживаних структур даних та алгоритмів у JavaScript від Ніколаса Закаса](https://github.com/humanwhocodes/computer-science-in-javascript)
- [Реалізація дерев пошуку на JavaScript](https://github.com/monmohan/dsjslib)
- [Типи даних і значення в специфікації ECMAScript (англ.)](https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values)
