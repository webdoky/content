---
title: Логічне І (&&)
slug: Web/JavaScript/Reference/Operators/Logical_AND
page-type: javascript-operator
browser-compat: javascript.operators.logical_and
---

{{jsSidebar("Operators")}}

Оператор **логічного І (`&&`)** (логічної кон'юнкції) для набору булевих операндів буде `true` тоді й лише тоді, коли всі операнди будуть `true`. Інакше – він буде `false`.

Якщо більш загально, то цей оператор повертає значення першого {{Glossary("falsy", "хибного")}} операнда, що зустрівся при обчисленні зліва направо, або значення останнього операнда, якщо всі операнди – {{Glossary("truthy", "істинні")}}.

{{EmbedInteractiveExample("pages/js/expressions-logical-and.html", "shorter")}}

## Синтаксис

```js-nolint
x && y
```

## Опис

Логічне І (`&&`) обчислює операнди зліва направо, негайно повертаючи значення першого {{Glossary("falsy", "хибного")}} операнда, що зустрівся; якщо всі значення – {{Glossary("truthy", "істинні")}}, то повертається значення останнього з них.

Якщо значення можна перетворити на `true`, то це значення є так званим {{Glossary("truthy", "істинним")}}. Якщо значення можна перетворити на `false`, то воно є так званим {{Glossary("falsy", "хибним")}}.

Приклади виразів, що можуть бути перетворені на хибу:

- `false`;
- `null`;
- `NaN`;
- `0`;
- порожній рядок (`""` або `''` або ` `` `);
- `undefined`.

Оператор І зберігає небулеві значення та повертає їх як є:

```js
result = "" && "foo"; // result присвоюється "" (порожній рядок)
result = 2 && 0; // result присвоюється 0
result = "foo" && 4; // result присвоюється 4
```

Навіть попри те, що оператор `&&` може вживатися над небулевими операндами, він все одно вважається булевим оператором, оскільки його повернене значення завжди може бути перетворено на [булів примітив](/uk/docs/Web/JavaScript/Data_structures#typ-boolean).
Щоб явно перетворити його повернене значення (або будь-який вираз загалом) на відповідне булеве значення, слід використати подвійний [`оператор НЕ`](/uk/docs/Web/JavaScript/Reference/Operators/Logical_NOT) або конструктор {{jsxref("Boolean/Boolean", "Boolean")}}.

### Закорочення обчислення

Вираз логічного І – це оператор з закороченням.
Оскільки кожний операнд перетворюється на булеве значення, то якщо результат одного перетворення виявиться `false`, то оператор І зупиняється та повертає вихідне значення цього хибного операнда; він **не** обчислює жодного з решти операндів.

Погляньмо на псевдокод нижче.

```plain
(якийсь хибний вираз) && вирз
```

Частина `вирз` **ніколи не обчислюється**, тому що перший операнд `(якийсь хибний вираз)` обчислюється як {{Glossary("falsy", "хибний")}}.
Якщо `вирз` – це функція, то вона ніколи не викликається.
Погляньте на приклад нижче:

```js
function A() {
  console.log("викликано A");
  return false;
}
function B() {
  console.log("викликано B");
  return true;
}

console.log(A() && B());
// Виводить у консоль "викликано A", оскільки викликано функцію A,
// && обчислюється в false (функція A повертає false), тому false виводиться у консоль;
// оператор І тут закорочується та ігнорує функцію B
```

### Пріоритет операторів

Оператор І має вищий пріоритет, ніж оператор АБО, а отже – оператор `&&` виконується до оператора `||` (дивіться [пріоритет операторів](/uk/docs/Web/JavaScript/Reference/Operators/Operator_precedence)).

```js-nolint
true || false && false; // true
true && (false || false); // false
(2 === 3) || (4 < 0) && (1 === 1); // false
```

## Приклади

### Застосування І

Наступний код демонструє приклади з оператором `&&` (логічне І).

```js
a1 = true && true; // t && t повертає true
a2 = true && false; // t && f повертає false
a3 = false && true; // f && t повертає false
a4 = false && 3 === 4; // f && f повертає false
a5 = "Кіт" && "Пес"; // t && t повертає "Пес"
a6 = false && "Кіт"; // f && t повертає false
a7 = "Кіт" && false; // t && f повертає false
a8 = "" && false; // f && f повертає ""
a9 = false && ""; // f && f повертає false
```

### Правила перетворення булевих операцій

#### Перетворення І на АБО

Наступна операція над **булевими**:

```js-nolint
bCondition1 && bCondition2
```

завжди рівносильна щодо:

```js-nolint
!(!bCondition1 || !bCondition2)
```

#### Перетворення АБО на І

Наступна операція над **булевими**:

```js-nolint
bCondition1 || bCondition2
```

завжди рівносильна щодо:

```js-nolint
!(!bCondition1 && !bCondition2)
```

### Вилучення вкладених дужок

Оскільки логічні вирази обчислюються зліва направо, завжди можна вилучити зі складного виразу дужки, якщо дотримано кількох правил.

Наступна складена операція над **булевими**:

```js-nolint
bCondition1 || (bCondition2 && bCondition3)
```

завжди рівносильна щодо:

```js-nolint
bCondition1 || bCondition2 && bCondition3
```

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

## Дивіться також

- {{jsxref("Boolean")}}
- {{Glossary("Truthy", "Істинне значення")}}
- {{Glossary("Falsy", "Хибне значення")}}
