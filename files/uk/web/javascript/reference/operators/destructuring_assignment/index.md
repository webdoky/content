---
title: Присвоєння з деструктуризацією
slug: Web/JavaScript/Reference/Operators/Destructuring_assignment
tags:
  - Destructuring
  - Destructuring_assignment
  - ECMAScript 2015
  - ES6
  - JavaScript
  - Language feature
  - Nested object and array destructuring
  - Operator
browser-compat: javascript.operators.destructuring
---
{{jsSidebar("Operators")}}

Синтаксис **присвоєння з деструктуризацією** — це вираз в JavaScript, який дає змогу розпакувати значення з масивів, або властивості з об'єктів, в окремі змінні.

{{EmbedInteractiveExample("pages/js/expressions-destructuringassignment.html", "taller")}}

## Синтаксис

```js
let a, b, rest;
[a, b] = [10, 20];
console.log(a); // 10
console.log(b); // 20

[a, b, ...rest] = [10, 20, 30, 40, 50];
console.log(a); // 10
console.log(b); // 20
console.log(rest); // [30, 40, 50]

({ a, b } = { a: 10, b: 20 });
console.log(a); // 10
console.log(b); // 20

// Проєкт стадії 4(завершений)
({a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40});
console.log(a); // 10
console.log(b); // 20
console.log(rest); // {c: 30, d: 40}
```

## Опис

Літерали об'єктів та масивів дають можливість легко створювати пакунки з даними _на ходу_.

```js
const x = [1, 2, 3, 4, 5];
```

Присвоєння з деструктуризацією використовує подібний синтаксис, але по лівий бік від оператора присвоєння, щоб встановити, які саме значення розпакувати зі змінної-джерела.

```js
const x = [1, 2, 3, 4, 5];
const [y, z] = x;
console.log(y); // 1
console.log(z); // 2
```

Подібним чином можна деструктуризувати масиви з лівого боку від присвоєння

```js
const [firstElement, secondElement] = list;
// еквівалентно такому коду:
// const firstElement = list[0];
// const secondElement = list[1];
```

Ці можливості подібні до функціонала, наявного в таких мовах, як Perl і Python.

## Приклади

### Деструктуризація масиву

#### Просте присвоєння змінних

```js
const foo = ['один', 'два', 'три'];

const [red, yellow, green] = foo;
console.log(red); // "один"
console.log(yellow); // "два"
console.log(green); // "три"
```

#### Присвоєння, відокремлене від оголошення

За допомогою деструктуризації можна присвоїти значення змінній, окремо від її оголошення.

```js
let a, b;

[a, b] = [1, 2];
console.log(a); // 1
console.log(b); // 2
```

Якщо під час деструктуризації масиву довжиною _N_, вказаного в правій частині виразу присвоєння, кількість змінних в лівій частині більша за _N_, то лише першим _N_ змінним буде присвоєно значення. Значення решти змінних залишиться невизначеним.

```js
const foo = ['один', 'два'];

const [red, yellow, green, blue] = foo;
console.log(red); // "один"
console.log(yellow); // "два"
console.log(green); // undefined
console.log(blue);  //undefined
```

#### Усталені значення

Змінній можна присвоїти усталене значення, на випадок, якщо розпаковане з масиву значення дорівнює `undefined`.

```js
let a, b;

[a=5, b=7] = [1];
console.log(a); // 1
console.log(b); // 7
```

#### Заміна змінних місцями

Значення двох змінних можна поміняти місцями в одному виразом з деструктуризацією.

Без присвоєння з деструктуризацією, така заміна вимагатиме тимчасової змінної (або, в деяких низькорівневих мовах, застосування [трюку зі XOR-заміною](https://en.wikipedia.org/wiki/XOR_swap_algorithm)).

```js
let a = 1;
let b = 3;

[a, b] = [b, a];
console.log(a); // 3
console.log(b); // 1

const arr = [1,2,3];
[arr[2], arr[1]] = [arr[1], arr[2]];
console.log(arr); // [1,3,2]
```

#### Розбирання масиву, поверненого функцією

Завжди було можливо повернути масив із функції. Деструктуризація може зробити роботу з поверненими значеннями масивів лаконічнішою.

В цьому прикладі, `f()` повертає значення `[1, 2]`, яке можна одразу одним рядком розібрати, за допомогою деструктуризації.

```js
function f() {
  return [1, 2];
}

let a, b;
[a, b] = f();
console.log(a); // 1
console.log(b); // 2
```

#### Ігнорування деяких повернених значень

Можна ігнорувати ті з повернених значень, які не становлять інтересу:

```js
function f() {
  return [1, 2, 3];
}

const [a, , b] = f();
console.log(a); // 1
console.log(b); // 3

const [c] = f();
console.log(c); // 1
```

Можна також ігнорувати всі повернені значення:

```js
[,,] = f();
```

#### Присвоєння змінній решти масиву

Під час деструктуризації масиву можна розпакувати й присвоїти його залишок змінній, застосувавши патерн решти:

```js
const [a, ...b] = [1, 2, 3];
console.log(a); // 1
console.log(b); // [2, 3]
```

Варто знати, що буде викинуто {{jsxref("SyntaxError")}} в разі, якщо справа від елемента решти буде висяча кома:

```js example-bad
const [a, ...b,] = [1, 2, 3];

// SyntaxError: rest element may not have a trailing comma
// Завжди розглядайте застосування оператора решти як останнього елемента
```

#### Розпакування значень зі збігів з регулярним виразом

Коли метод регулярного виразу [`exec()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec) знаходить збіг, він повертає масив, що містить спершу цілий збіг з частиною рядка, а потім ті частини рядка, які збіглися з виділеними дужками групами регулярного виразу. Присвоєння з деструктуризацією дає змогу легко виділити частини цього масиву, проігнорувавши повний збіг, якщо в ньому немає потреби.

```js
function parseProtocol(url) {
  const parsedURL = /^(\w+)\:\/\/([^\/]+)\/(.*)$/.exec(url);
  if (!parsedURL) {
    return false;
  }
  console.log(parsedURL);
  // ["https://webdoky.org/uk/docs/Web/JavaScript",
  // "https", "webdoky.org", "uk/docs/Web/JavaScript"]

  const [, protocol, fullhost, fullpath] = parsedURL;
  return protocol;
}

console.log(parseProtocol('https://webdoky.org/uk/docs/Web/JavaScript'));
// "https"
```

### Деструктуризація об'єктів

#### Звичайне присвоєння

```js
const user = {
    id: 42,
    isVerified: true
};

const {id, isVerified} = user;

console.log(id); // 42
console.log(isVerified); // true
```

#### Присвоєння, відокремлене від оголошення

Змінній можна присвоїти значення за допомогою деструктуризації, окремо від її оголошення.

```js
let a, b;

({a, b} = {a: 1, b: 2});
```

> **Примітка:** Дужки `( ... )` навколо інструкції присвоєння є обов'язковими під час виконання присвоєння із деструктуризацією окремо від оголошення в об'єктних літералах.
>
> Окремий вираз `{a, b} = {a: 1, b: 2}` — це недійсний синтаксис, оскільки `{a, b}` зліва вважатимуться блоком, а не об'єктним літералом.
>
> Проте, вираз `({a, b} = {a: 1, b: 2})` є цілком коректним, так само як і `const {a, b} = {a: 1, b: 2}`
>
> Перед виразом `( ... )` також потрібна крапка з комою, інакше він може бути використаний для виклику функції на попередньому рядку.

#### Присвоєння змінним із новими іменами

Можна розпакувати властивість з об'єкта, і присвоїти її змінній під іншим ім'ям, відмінним від назви властивості.

```js
const o = {p: 42, q: true};
const {p: foo, q: bar} = o;

console.log(foo); // 42
console.log(bar); // true
```

Тут, наприклад, `const {p: foo} = o` бере з об'єкта `o` властивість `p`, і присвоює її місцевій змінній `foo`.

#### Усталені значення

Змінній можна присвоїти усталене значення, на випадок, якщо значення, розпаковане з об'єкта, дорівнює `undefined`.

```js
const {a = 10, b = 5} = {a: 3};

console.log(a); // 3
console.log(b); // 5
```

#### Присвоєння змінним із новими іменами, та надання усталених значень

Властивість можна одночасно:

- Розпакувати з об'єкта і призначити змінній із відмінним іменем.
- Призначити їй усталене значення, на випадок, якщо розпаковане значення дорівнює `undefined`.

```js
const {a: aa = 10, b: bb = 5} = {a: 3};

console.log(aa); // 3
console.log(bb); // 5
```

#### Розпаковування властивостей об'єкта, переданого параметром функції

Об'єкти, передані у функцію як параметри, також можна розпакувати у змінні, доступні всередині тіла функції. Що ж стосується присвоєння об'єктів, синтаксис деструктуризації дає змогу новій змінній мати те саме (або відмінне) ім'я, що й первинна властивість, і призначати усталені значення на випадок, якщо вихідний об'єкт не містить такої властивості.

Розгляньмо цей об'єкт, який містить інформацію про користувача.

```js
const user = {
  id: 42,
  displayName: 'скішка',
  fullName: {
    firstName: 'Самійло',
    lastName: 'Кішка'
  }
};
```

Далі показано, як розпакувати властивість переданого об'єкта у змінну із таким самим ім'ям. Значення параметра `{id}` вказує, що з об'єкта, переданого до функції, слід розпакувати властивість `id` у змінну зі таким самим ім'ям. Цю змінну далі можна буде використовувати всередині функції.

```js
function userId({id}) {
  return id;
}

console.log(userId(user)); // 42
```

Можна задати нове ім'я для розпакованої змінної. Нижче розпаковується властивість під назвою `displayName`, і перейменовується у `dname` для використання всередині тіла функції.

```js
function userDisplayName({displayName: dname}) {
  return dname;
}

console.log(userDisplayName(user)); // `скішка`
```

Також можна розпаковувати вкладені об'єкти. Наведений нижче приклад ілюструє розпаковування властивості `fullname.firstName` у змінну, названу `name`.

```js
function whois({displayName, fullName: {firstName: name}}) {
  return `${displayName} — це ${name}`;
}

console.log(whois(user));  // "скішка — це Самійло"
```

#### Встановлення усталеного значення для параметра функції

За допомогою `=` можна вказати усталене значення, яке потім буде використано як значення змінної в разі, якщо вказаної властивості в початковому об'єкті не існує.

Нижче показано функцію, де усталене значення змінної `size` дорівнює `'великий'`, усталені координати дорівнюють `x: 0, y: 0`, а усталений радіус `radius` — 25.

```js
function drawChart({size = 'великий', coords = {x: 0, y: 0}, radius = 25} = {}) {
  console.log(size, coords, radius);
  // виконати малювання якогось графіка
}

drawChart({
  coords: {x: 18, y: 30},
  radius: 30
});
```

> **Примітка:** В сигнатурі наведеної вище функції **`drawChart`**, деструктурованій лівій частині з правого боку присвоєно порожній об'єктний літерал:
>
> ```js
> {size = 'big', coords = {x: 0, y: 0}, radius = 25} = {}
> ```
>
> Можна було б записати цю функцію без такого присвоєння справа.
> Проте, якщо опустити це присвоєння з правого боку, функція буде очікувати на принаймні один переданий аргумент під час виклику. У її поточній формі можна викликати **`drawChart()`** без передачі будь-яких аргументів.
> Поточний підхід корисний, коли потрібно мати можливість викликати функцію не передаючи до неї аргументів.
> Інший підхід корисний, якщо потрібно пересвідчитись в тому, що об'єкт передається до функції.
> Докладніше про це у розділі [Усталені параметри > Деструктуризація параметрів із присвоєнням усталених значень](/uk/docs/Web/JavaScript/Reference/Functions/Default_parameters#destructured_parameter_with_default_value_assignment).

#### Деструктуризація вкладеного об'єкта і масиву

```js
const metadata = {
  title: 'Scratchpad',
  translations: [
    {
      locale: 'de',
      localization_tags: [],
      last_edit: '2014-04-14T08:43:37',
      url: '/de/docs/Tools/Scratchpad',
      title: 'JavaScript-Umgebung'
    }
  ],
  url: '/en-US/docs/Tools/Scratchpad'
};

let {
  title: englishTitle, // перейменування
  translations: [
    {
       title: localeTitle, // перейменування
    },
  ],
} = metadata;

console.log(englishTitle); // "Scratchpad"
console.log(localeTitle);  // "JavaScript-Umgebung"
```

#### `For of` — ітерування із деструктуризацією

```js
const people = [
  {
    name: 'Михайло Коваль',
    family: {
      mother: 'Яна Коваль',
      father: 'Гаврило Коваль',
      sister: 'Соломія Коваль'
    },
    age: 35
  },
  {
    name: 'Фома Іванченко',
    family: {
      mother: 'Раїса Іванченко',
      father: 'Ярослав Іванченко',
      brother: 'Валерій Іванченко'
    },
    age: 25
  }
];

for (const {name: n, family: {father: f}} of people) {
  console.log('Ім\'я: ' + n + ', Батько: ' + f);
}

// "Ім'я: Михайло Коваль, Батько: Гаврило Коваль"
// "Ім'я: Фома Іванченко, Батько: Ярослав Іванченко"
```

#### Деструктуризація, і обчислені імена властивостей

Деструктуризація дає змогу використовувати обчислені імена властивостей, подібні до таких в [об'єктних літералах](/uk/docs/Web/JavaScript/Reference/Operators/Object_initializer#computed_property_names).

```js
let key = 'z';
let {[key]: foo} = {z: 'bar'};

console.log(foo); // "bar"
```

#### Решта в деструктуризації об'єктів

Проєкт [Решта/розгорнуті властивості для ECMAScript (англ.)](https://github.com/tc39/proposal-object-rest-spread) (стадія 4) додає до деструктуризації синтаксис [решти](/uk/docs/Web/JavaScript/Reference/Functions/rest_parameters). В решту властивостей збирається залишок ключів власних перелічуваних властивостей — тих, які ще не були вказані під час деструктуризації.

```js
let {a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40}
a; // 10
b; // 20
rest; // { c: 30, d: 40 }
```

#### Недійсний ідентифікатор JavaScript як ім'я властивості

Деструктуризацію можна використовувати із такими іменами властивостей, які не є дійсними {{glossary("Identifier", "ідентифікаторами")}} в JavaScript, шляхом вказання такої альтернативи, яка є дійсним ідентифікатором.

```js
const foo = { 'fizz-buzz': true };
const { 'fizz-buzz': fizzBuzz } = foo;

console.log(fizzBuzz); // true
```

#### Одночасна деструктуризація об'єкта і масиву

Можна комбінувати деструктуризацію об'єкта і масиву. Скажімо, потрібен третій елемент з масиву `props`, наведеного нижче. І далі потрібно вибрати з нього властивість `name`. Це можна зробити наступним чином:

```js
const props = [
  { id: 1, name: 'Fizz'},
  { id: 2, name: 'Buzz'},
  { id: 3, name: 'FizzBuzz'}
];

const [,, { name }] = props;

console.log(name); // "FizzBuzz"
```

#### Під час деструктуризації об'єкта відбувається звертання до прототипного ланцюжка

Якщо під час деструктуризації об'єкта властивість в ньому недоступна, пошук продовжиться далі вздовж ланцюжка прототипів.

```js
let obj = {self: '123'};
obj.__proto__.prot = '456';
const {self, prot} = obj;
// self "123"
// prot "456" (Доступ до ланцюжка прототипів)
```

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

## Дивіться також

- [Оператори присвоєння](/uk/docs/Web/JavaScript/Reference/Operators#assignment_operators)
- ["Поглиблено про ES6: Деструктуризація" на hacks.mozilla.org (англ.)](https://hacks.mozilla.org/2015/05/es6-in-depth-destructuring/)
