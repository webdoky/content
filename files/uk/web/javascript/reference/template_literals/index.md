---
title: Шаблонні літерали (Шаблонні рядки)
slug: Web/JavaScript/Reference/Template_literals
tags:
  - ECMAScript 2015
  - Guide
  - JavaScript
  - React
  - String
  - Template Strings
  - Template literals
  - Template string
  - strings
browser-compat: javascript.grammar.template_literals
---
{{JsSidebar("More")}}

Шаблонні літерали — це літерали, які виділяються символами тупого наголосу (також відомий як "гравіс" — <code>`</code>) і дають можливість вкладати вирази, які називаються *замінами (підставляннями)*.

- *Нетеговані* шаблонні літерали дають в результаті рядки, що робить їх корисними для інтерполяції рядків (і для створення багаторядного тексту, оскільки вони допускають вживання неекранованих символів початку рядка).

- *Теговані* шаблонні літерали викликають функцію (так звану *функцію тега*) з масивом всіх сегментів тексту з літерала і набором аргументів зі значеннями для замін, що може бути корисно для [предметно-орієнтованих мов (DSL)](https://en.wikipedia.org/wiki/Domain-specific_language).

Шаблонні літерали інколи неформально називають *шаблонними рядками*, проте вони не є рядковими літералами, і їх не можна використовувати у всіх контекстах, в яких використовується рядковий літерал. Окрім цього, теговані шаблонні літерали можуть і не виводити рядок взагалі: функція тега сама вирішує, що їй слід (або не слід) створити.

## Синтаксис

```js
// Нетеговані літерали — створюють рядки:
`стрічка тексту`

`стрічка тексту — рядок 1
 стрічка тексту — рядок 2`

`стрічка тексту ${вираз} стрічка тексту`

// Шаблон, придатний до повторного використання:
const templateFn = вираз => `стрічка тексту ${вираз} стрічка тексту`;

// Теговані шаблони — в цьому випадку викликається функція "example" з шаблоном
// у першому аргументі, і значеннями для заміни, переданими в наступних аргументах:
example`стрічка тексту ${вираз} стрічка тексту`
```

## Опис

Шаблонні літерали виділяються символами тупого наголосу (\` \`) (також відомим як [гравіс](https://uk.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D0%B2%D1%96%D1%81_(%D0%B4%D1%96%D0%B0%D0%BA%D1%80%D0%B8%D1%82%D0%B8%D1%87%D0%BD%D0%B8%D0%B9_%D0%B7%D0%BD%D0%B0%D0%BA))) замість одинарних чи подвійних лапок.

Шаблонні літерали можуть містити поля для заповнення. Вони позначаються знаком долара і фігурними дужками (`${вираз}`). До функції передаються і вирази у полях для заповнення, і текст між тупими наголосами (\` \`).

Усталена функція просто з'єднує передані частини у цілий рядок. Якщо перед шаблонним літералом знаходиться якийсь вираз — це називається **тегованим шаблоном**. В такому разі вираз тегу (зазвичай функція) викликається разом з шаблонним літералом, з яким після цього можна виконувати якісь дії — перед поверненням з функції.

Для екранування символу тупого наголосу всередині шаблонного літерала достатньо поставити перед ним зворотний скіс (`\`).

```js
`\`` === '`' // --> true
```

### Багаторядковий текст

Будь-який символ нового рядка, присутній у початковому коді, входить до складу шаблонного літерала.

Під час використання звичайних рядків слід використовувати наступний синтаксис, аби отримати багаторядний текст:

```js
console.log('стрічка тексту — рядок 1\n' +
'стрічка тексту — рядок 2');
// "стрічка тексту — рядок 1
// стрічка тексту — рядок 2"
```

З шаблонними літералами аналогічного результату можна досягнути так:

```js
console.log(`стрічка тексту — рядок 1
стрічка тексту — рядок 2`);
// "стрічка тексту — рядок 1
// стрічка тексту — рядок 2"
```

### Інтерполяція виразів

Аби вкласти вираз всередину звичайного рядка, потрібно застосувати наступний синтаксис:

```js
let a = 5;
let b = 10;
console.log('П\'ятнадцять — це ' + (a + b) + ', а\nне ' + (2 * a + b) + '.');
// "П'ятнадцять — це 15, а
// не 20."

```

Тепер, з шаблонними літералами, є можливість скористатися синтаксичним цукром і зробити таку заміну значно простішою для читання:

```js
let a = 5;
let b = 10;
console.log(`П'ятнадцять — це ${a + b}, а
не ${2 * a + b}.`);
// "П'ятнадцять — це 15, а
// не 20."
```

### Вкладення шаблонів

В деяких випадках вкладання шаблону — це найпростіший (і, ймовірно, зручніший для читання) спосіб отримання рядків, які можна налаштовувати. Всередині шаблону, виділеного тупими наголосами, можна використати вкладений шаблон, просто вживши його всередині поля для заповнення `${ }` в шаблоні.

Наприклад, якщо умова є істинною — то повернути цей шаблонний літерал.

В ES5:

```js
let classes = 'header';
classes += (isLargeScreen() ?
  '' : item.isCollapsed ?
    ' icon-expander' : ' icon-collapser');
```

В ES2015 зі шаблонними літералами, і без вкладання:

```js
const classes = `header ${ isLargeScreen() ? '' :
  (item.isCollapsed ? 'icon-expander' : 'icon-collapser') }`;
```

В ES2015 з вкладеними шаблонними літералами:

```js
const classes = `header ${ isLargeScreen() ? '' :
  `icon-${item.isCollapsed ? 'expander' : 'collapser'}` }`;
```

### Теговані шаблони

Більш розширена форма шаблонних літералів — це _теговані_ шаблони.

Теги дають змогу розбирати шаблонні літерали за допомогою функції. Перший аргумент тегової функції містить масив рядкових значень. Решта аргументів належать до виразів.

Тегова функція далі може виконати які завгодно операції на цих аргументах і повернути оброблений рядок. (Вона також може повертати щось абсолютно інше, як описано в одному з прикладів нижче.)

Назва функції, яку вжито як тег, може бути якою завгодно.

```js
let person = 'Майк';
let age = 28;

function myTag(strings, personExp, ageExp) {
  let str0 = strings[0]; // "Цей "
  let str1 = strings[1]; // " — "
  let str2 = strings[2]; // "."

  let ageStr;
  if (ageExp > 99){
    ageStr = 'довгожитель';
  } else {
    ageStr = 'юнак';
  }

  // Можна повертати навіть рядок, сформований за допомогою шаблонного літерала
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

let output = myTag`Цей ${ person } — ${ age }.`;

console.log(output);
// Цей Майк — юнак.
```

Тегові функції навіть не зобов'язані повертати саме рядок!

```js
function template(strings, ...keys) {
  return (function(...values) {
    let dict = values[values.length - 1] || {};
    let result = [strings[0]];
    keys.forEach(function(key, i) {
      let value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join('');
  });
}

let t1Closure = template`${0}${1}${0}!`;
//let t1Closure = template(["","","","!"],0,1,0);
t1Closure('Y', 'A');                      // "YAY!"

let t2Closure = template`${0}, ${'foo'}!`;
//let t2Closure = template([""," ","!"],0,"foo");
t2Closure('Привіт', {foo: 'Світе'}); // "Привіт, Світе!"

let t3Closure = template`Мене звати ${'name'}. Мені майже ${'age'} рік.`;
//let t3Closure = template(["Мене звати ", ". Мені майже ", " рік."], "name", "age");
t3Closure('foo', {name: 'WebDoky', age: 1}); //"Мене звати WebDoky. Мені майже 1 рік."
t3Closure({name: 'WebDoky', age: 1}); //"Мене звати WebDoky. Мені майже 1 рік."
```

### Необроблені рядки

Особлива властивість `raw`, наявна в першому аргументі тегової функції, дає змогу доступитися до необроблених рядків в тому вигляді, в якому їх було введено, без обробки [екранованих послідовностей](/uk/docs/Web/JavaScript/Guide/Grammar_and_types#using_special_characters_in_strings).

```js
function tag(strings) {
  console.log(strings.raw[0]);
}

tag`стрічка тексту — рядок 1 \n стрічка тексту — рядок 2`;
// друкує "стрічка тексту — рядок 1 \n стрічка тексту — рядок 2" ,
// включно з двома символами '\' та 'n'
```

На додаток, для створення необроблених рядків існує метод {{jsxref("String.raw()")}}, який працює точнісінько так само, як усталена тегова функція і конкатенація рядків.

```js
let str = String.raw`Привіт\n${2+3}!`;
// "Привіт\\n5!"

str.length;
// 10

Array.from(str).join(',');
// "П,р,и,в,і,т,\\,n,5,!"
```

### Теговані шаблони і екрановані послідовності

#### Поведінка згідно ES2016

Починаючи з ECMAScript 2016, теговані шаблони враховують правила таких екранованих послідовностей:

- Екрановані послідовності Unicode, що починаються з "`\u`", наприклад `\u00A9`
- Екрановані послідовності кодової точки Unicode, що позначаються "`\u{}`", наприклад, `\u{2F804}`
- Шістнадцяткові екранування, що починаються з "`\x`", наприклад, `\xA9`
- Вісімкові літеральні екранування, що починаються з "`\0o`", а продовжуються однією чи декількома цифрами, наприклад, `\0o251`

Це означає, що буде проблематичним вжити такий тегований шаблон, як наведено нижче, оскільки, згідно з граматикою ECMAScript, парсер шукатиме дійсну екрановану послідовність Unicode, але знайде дефектний синтаксис:

```js
latex`\unicode`
// Викидає помилку в старіших версіях ECMAScript (ES2016 і раніших)
// SyntaxError: malformed Unicode character escape sequence
```

#### Перегляд недійсних екранованих послідовностей в ES2018

Теговані шаблони повинні давати змогу вкладати інші мови (наприклад, [предметно орієнтовані](https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%BC%D0%B5%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D1%96%D1%94%D0%BD%D1%82%D0%BE%D0%B2%D0%B0%D0%BD%D0%B0_%D0%BC%D0%BE%D0%B2%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F), чи [LaTeX](https://uk.wikipedia.org/wiki/LaTeX)), в яких поширені інші екрановані послідовності. Пропозиція до розгляду ECMAScript під назвою [Перегляд шаблонних літералів (англ.)](https://tc39.github.io/proposal-template-literal-revision/) (інтегровано в стандарт ECMAScript 2018) прибрала обмеження екранованих послідовностей ECMAScript з тегованих шаблонів.

Все ж, недійсні екрановані послідовності все одно необхідно показати в "приготованому" виразі. Їх буде показано як {{jsxref("undefined", "невизначені")}} елементи в масиві "cooked":

```js
function latex(str) {
  return { "cooked": str[0], "raw": str.raw[0] }
}

latex`\unicode`

// { cooked: undefined, raw: "\\unicode" }
```

Слід зауважити, що обмеження екранованих послідовностей було прибрано лише з _тегованих_ шаблонів, проте в _нетегованих_ літералах вони залишилися:

```js example-bad
let bad = `неправильна екранована послідовність: \unicode`;
```

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

## Дивіться також

- {{jsxref("String")}}
- {{jsxref("String.raw()")}}
- [Лексична граматика](/uk/docs/Web/JavaScript/Reference/Lexical_grammar)
- [Подібні до шаблонів рядки в ES3-сумісному синтаксисі](https://gist.github.com/WebReflection/8f227532143e63649804)
- ["Поглиблено про ES6: шаблонні рядки" на hacks.mozilla.org (англ.)](https://hacks.mozilla.org/2015/05/es6-in-depth-template-strings-2/)
