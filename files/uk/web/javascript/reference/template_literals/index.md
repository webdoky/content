---
title: Шаблонні літерали (Шаблонні рядки)
slug: Web/JavaScript/Reference/Template_literals
tags:
  - ECMAScript 2015
  - Guide
  - JavaScript
  - React
  - String
  - Template Strings
  - Template literals
  - Template string
  - strings
browser-compat: javascript.grammar.template_literals
---
{{JsSidebar("More")}}

Шаблонні літерали — це літерали, які виділяються символами тупого наголосу (\`), і дають можливість використовувати [багаторядковий текст](#bahatoriadkovyi-tekst), [інтерполяцію рядків](#interpoliatsiia-riadkiv) із вбудованими виразами, і також особливими конструкціями, які називаються [тегованими шаблонами](#tehovani-shablony).

Шаблонні літерали інколи неформально називають *шаблонними рядками*, оскільки одним із основних способів їхнього застосування є [інтерполяція рядків](#interpoliatsiia-riadkiv) (створення рядків шляхом підставляння полів для заповнення). Хоча теговані шаблонні літерали можуть і не виводити рядок взагалі; їх можна застосувати із довільною [теговою функцією](#tehovani-shablony) для виконання будь-яких операцій із різними частинами шаблонного літерала.

## Синтаксис

```js
// Нетеговані літерали — створюють рядки:
`стрічка тексту`

`стрічка тексту — рядок 1
 стрічка тексту — рядок 2`

`стрічка тексту ${вираз} стрічка тексту`

// Теговані шаблони — в цьому випадку викликається функція "tagFunction" з шаблоном
// у першому аргументі, і значеннями для заміни, переданими в наступних аргументах:
tagFunction`стрічка тексту ${вираз} стрічка тексту`
```

## Опис

Шаблонні літерали виділяються символами тупого наголосу (\`) замість одинарних чи подвійних лапок.

Поряд зі звичайними рядками, шаблонні літерали можуть містити інші частини — так звані _поля для заповнення_, які являються вбудованими виразами, виділеними знаком долара і фігурними дужками (`${вираз}`). Рядки і поля для заповнення передаються до функції: або усталеної, або переданої в коді. Усталена функція (що спрацьовує, коли явно не вказано іншої) виконує лише [інтерполяцію рядків](#interpoliatsiia-riadkiv) для підставляння значень у поля для заповнення, і потім з'єднує всі частини у цілий рядок.

Аби передати власну функцію, достатньо вказати її ім'я перед шаблонним літерам. Вираз, отриманий в результаті, називається [**тегований шаблон**](#tehovani-shablony). В цьому випадку шаблонний літерал буде передано до вказаної тегової функції, де можна буде виконати будь-які операції з різними частинами шаблонного літерала.

Для екранування символу тупого наголосу всередині шаблонного літерала достатньо поставити перед ним зворотний скіс (`\`).

```js
`\`` === '`' // --> true
```

Також для запобігання інтерполяції можна екранувати знак долара.

```js
`\${1}` === '${1}' // --> true
```

### Багаторядковий текст

Будь-який символ нового рядка, присутній у початковому коді, входить до складу шаблонного літерала.

Під час використання звичайних рядків слід використовувати наступний синтаксис, аби отримати багаторядний текст:

```js
console.log('стрічка тексту — рядок 1\n' +
'стрічка тексту — рядок 2');
// "стрічка тексту — рядок 1
// стрічка тексту — рядок 2"
```

З шаблонними літералами аналогічного результату можна досягнути так:

```js
console.log(`стрічка тексту — рядок 1
стрічка тексту — рядок 2`);
// "стрічка тексту — рядок 1
// стрічка тексту — рядок 2"
```

### Інтерполяція рядків

За відсутності шаблонних літералів, коли є потреба скомбінувати вивід виразу із рядками, знадобилося б [з'єднати їх](/uk/docs/Learn/JavaScript/First_steps/Strings#concatenation_using_) за допомогою "`+`" (знак додавання) ([оператора додавання](/uk/docs/Web/JavaScript/Reference/Operators/Addition)):

```js
let a = 5;
let b = 10;
console.log('П\'ятнадцять — це ' + (a + b) + ', а\nне ' + (2 * a + b) + '.');
// "П'ятнадцять — це 15, а
// не 20."

```

Це може бути складним для прочитання, особливо якщо там є декілька виразів.

Можна уникнути вживання оператора конкатенації — а також покращити зрозумілість коду — використавши шаблонні літерали шляхом додавання полів для заповнення у формі "`${вираз}`", для виконання заміни вбудованих виразів:

```js
let a = 5;
let b = 10;
console.log(`П'ятнадцять — це ${a + b}, а
не ${2 * a + b}.`);
// "П'ятнадцять — це 15, а
// не 20."
```

### Вкладення шаблонів

В деяких випадках вкладання шаблону — це найпростіший (і, ймовірно, зручніший для читання) спосіб отримання рядків, які можна налаштовувати. Всередині шаблону, виділеного тупими наголосами, можна використати вкладений шаблон, просто вживши його всередині поля для заповнення `${вираз}` в шаблоні.

Наприклад, якби потрібно було повернути певне значення залежно від конкретної умови, за відсутності шаблонних літералів — можна було б зробити щось схоже на наступний приклад:

```js example-bad
let classes = 'header';
classes += (isLargeScreen() ?
  '' : item.isCollapsed ?
    ' icon-expander' : ' icon-collapser');
```

Із шаблонним літералом, але без вкладання, можна було б зробити таким чином:

```js example-bad
const classes = `header ${ isLargeScreen() ? '' :
  (item.isCollapsed ? 'icon-expander' : 'icon-collapser') }`;
```

Із вкладеними шаблонними літералами, можна робити так:

```js example-good
const classes = `header ${ isLargeScreen() ? '' :
  `icon-${item.isCollapsed ? 'expander' : 'collapser'}` }`;
```

### Теговані шаблони

Більш розширена форма шаблонних літералів — це _теговані_ шаблони.

Теги дають змогу розбирати шаблонні літерали за допомогою функції. Перший аргумент тегової функції містить масив рядкових значень. Решта аргументів належать до виразів.

Тегова функція далі може виконати які завгодно операції на цих аргументах і повернути оброблений рядок. (Вона також може повертати щось абсолютно інше, як описано в одному з прикладів нижче.)

Назва функції, яку вжито як тег, може бути якою завгодно.

```js
let person = 'Майк';
let age = 28;

function myTag(strings, personExp, ageExp) {
  let str0 = strings[0]; // "Цей "
  let str1 = strings[1]; // " — "
  let str2 = strings[2]; // "."

  let ageStr;
  if (ageExp > 99){
    ageStr = 'довгожитель';
  } else {
    ageStr = 'юнак';
  }

  // Можна повертати навіть рядок, сформований за допомогою шаблонного літерала
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

let output = myTag`Цей ${ person } — ${ age }.`;

console.log(output);
// Цей Майк — юнак.
```

Тегові функції навіть не зобов'язані повертати саме рядок!

```js
function template(strings, ...keys) {
  return (function(...values) {
    let dict = values[values.length - 1] || {};
    let result = [strings[0]];
    keys.forEach(function(key, i) {
      let value = Number.isInteger(key) ? values[key] : dict[key];
      result.push(value, strings[i + 1]);
    });
    return result.join('');
  });
}

let t1Closure = template`${0}${1}${0}!`;
//let t1Closure = template(["","","","!"],0,1,0);
t1Closure('Y', 'A');                      // "YAY!"

let t2Closure = template`${0}, ${'foo'}!`;
//let t2Closure = template([""," ","!"],0,"foo");
t2Closure('Привіт', {foo: 'Світе'}); // "Привіт, Світе!"

let t3Closure = template`Мене звати ${'name'}. Мені майже ${'age'} рік.`;
//let t3Closure = template(["Мене звати ", ". Мені майже ", " рік."], "name", "age");
t3Closure('foo', {name: 'WebDoky', age: 1}); //"Мене звати WebDoky. Мені майже 1 рік."
t3Closure({name: 'WebDoky', age: 1}); //"Мене звати WebDoky. Мені майже 1 рік."
```

### Необроблені рядки

Особлива властивість `raw`, наявна в першому аргументі тегової функції, дає змогу доступитися до необроблених рядків в тому вигляді, в якому їх було введено, без обробки [екранованих послідовностей](/uk/docs/Web/JavaScript/Guide/Grammar_and_types#using_special_characters_in_strings).

```js
function tag(strings) {
  console.log(strings.raw[0]);
}

tag`стрічка тексту — рядок 1 \n стрічка тексту — рядок 2`;
// друкує "стрічка тексту — рядок 1 \n стрічка тексту — рядок 2" ,
// включно з двома символами '\' та 'n'
```

На додаток, для створення необроблених рядків існує метод {{jsxref("String.raw()")}}, який працює точнісінько так само, як усталена тегова функція і конкатенація рядків.

```js
let str = String.raw`Привіт\n${2+3}!`;
// "Привіт\\n5!"

str.length;
// 10

Array.from(str).join(',');
// "П,р,и,в,і,т,\\,n,5,!"
```

### Теговані шаблони і екрановані послідовності

#### Поведінка згідно ES2016

Починаючи з ECMAScript 2016, теговані шаблони враховують правила таких екранованих послідовностей:

- Екрановані послідовності Unicode, що починаються з "`\u`", наприклад `\u00A9`
- Екрановані послідовності кодової точки Unicode, що позначаються "`\u{}`", наприклад, `\u{2F804}`
- Шістнадцяткові екранування, що починаються з "`\x`", наприклад, `\xA9`
- Вісімкові літеральні екранування, що починаються з "`\0o`", а продовжуються однією чи декількома цифрами, наприклад, `\0o251`

Це означає, що буде проблематичним вжити такий тегований шаблон, як наведено нижче, оскільки, згідно з граматикою ECMAScript, парсер шукатиме дійсну екрановану послідовність Unicode, але знайде дефектний синтаксис:

```js
latex`\unicode`
// Викидає помилку в старіших версіях ECMAScript (ES2016 і раніших)
// SyntaxError: malformed Unicode character escape sequence
```

#### Перегляд недійсних екранованих послідовностей в ES2018

Теговані шаблони повинні давати змогу вкладати інші мови (наприклад, [предметно орієнтовані](https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%BC%D0%B5%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D1%96%D1%94%D0%BD%D1%82%D0%BE%D0%B2%D0%B0%D0%BD%D0%B0_%D0%BC%D0%BE%D0%B2%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F), чи [LaTeX](https://uk.wikipedia.org/wiki/LaTeX)), в яких поширені інші екрановані послідовності. Пропозиція до розгляду ECMAScript під назвою [Перегляд шаблонних літералів (англ.)](https://tc39.es/proposal-template-literal-revision/) (інтегровано в стандарт ECMAScript 2018) прибрала обмеження екранованих послідовностей ECMAScript з тегованих шаблонів.

Все ж, недійсні екрановані послідовності все одно необхідно показати в "приготованому" виразі. Їх буде показано як {{jsxref("undefined", "невизначені")}} елементи в масиві "cooked":

```js
function latex(str) {
  return { "cooked": str[0], "raw": str.raw[0] }
}

latex`\unicode`

// { cooked: undefined, raw: "\\unicode" }
```

Слід зауважити, що обмеження екранованих послідовностей було прибрано лише з _тегованих_ шаблонів, проте в _нетегованих_ літералах вони залишилися:

```js example-bad
let bad = `неправильна екранована послідовність: \unicode`;
```

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

## Дивіться також

- {{jsxref("String")}}
- {{jsxref("String.raw()")}}
- [Лексична граматика](/uk/docs/Web/JavaScript/Reference/Lexical_grammar)
- [Подібні до шаблонів рядки в ES3-сумісному синтаксисі](https://gist.github.com/WebReflection/8f227532143e63649804)
- ["Поглиблено про ES6: шаблонні рядки" на hacks.mozilla.org (англ.)](https://hacks.mozilla.org/2015/05/es6-in-depth-template-strings-2/)
