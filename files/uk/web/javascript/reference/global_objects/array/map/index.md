---
title: Array.prototype.map()
slug: Web/JavaScript/Reference/Global_Objects/Array/map
tags:
  - Array
  - ECMAScript 5
  - JavaScript
  - Method
  - Prototype
  - Reference
  - Polyfill
browser-compat: javascript.builtins.Array.map
---
{{JSRef}}

Метод **`map()`** **створює новий масив**, наповнений результатами виклику переданої функції на кожному з елементів початкового масиву.

{{EmbedInteractiveExample("pages/js/array-map.html")}}

## Синтаксис

```js
// Стрілкова функція
map((element) => { /* ... */ })
map((element, index) => { /* ... */ })
map((element, index, array) => { /* ... */ })

// Функція зворотного виклику
map(callbackFn)
map(callbackFn, thisArg)

// Функція зворотного виклику, оголошена на місці
map(function(element) { /* ... */ })
map(function(element, index) { /* ... */ })
map(function(element, index, array){ /* ... */ })
map(function(element, index, array) { /* ... */ }, thisArg)
```

### Параметри

- `callbackFn`

  - : Функція, яка викликається на кожному з елементів масиву. Кожного разу, коли виконується `callbackFn`, результат її виклику додається нового масиву.

    Функція `callbackFn` приймає наступні аргументи:

    - `element`
      - : Поточний елемент масиву, який зараз опрацьовується.
    - `index`{{optional_inline}}
      - : Порядковий номер поточного елемента масиву, який зараз обробляється.
    - `array`{{optional_inline}}
      - : Масив, на якому було викликано метод `map`.

- `thisArg`{{optional_inline}}
  - : Значення, що буде використано як `this` під час виконання `callbackFn`.

### Результат

Новий масив, куди входять всі результати викликання переданої функції зворотного виклику.

## Опис

Метод `map` викликає передану функцію `callbackFn` **один раз для кожного елемента** масиву, в порядку зростання індексу, і формує новий масив із результатів. `callbackFn` викликається лише для тих індексів, які мають присвоєне значення (включно з {{jsxref("undefined")}}).

Вона _не_ викликається для пропущених елементів масиву. Маються на увазі:

- індекси, які ніколи не встановлювались;
- індекси, які було видалено.

### Коли не слід застосовувати map()

Оскільки `map` будує новий масив, його застосування є антипаттерном у тих ситуаціях, коли повернений в результаті масив не використовується. Натомість краще використати {{jsxref("Array/forEach", "forEach")}} чи
{{jsxref("Statements/for...of", "for...of")}}.

Не слід використовувати `map`, якщо:

- повернений в результаті масив не використовується; та/або
- передана функція зворотного виклику не повертає результату.

### Докладно про параметри

Функція `callbackFn` викликається з трьома аргументами: значенням елементу, його порядковим номером, і об'єктом масиву, який власне перебирається.

У випадку, коли передано параметр `thisArg`, його буде використано як значення `this` у функції зворотного виклику. В протилежному випадку для `this` буде використано значення {{jsxref("undefined")}}. Загалом значення `this`, яке бачитиме функція `callback` визначається згідно з [загальними правилами визначення значення `this`, доступного для функції](/en-US/docs/Web/JavaScript/Reference/Operators/this).

Метод `map` не змінює початковий масив, на якому він викликається (хоча передана всередину функція `callbackFn` може це робити).

Діапазон елементів, що опрацьовуються методом `map`, задається до першого виклику `callbackFn`. Елементи, які будуть присвоєні до індексів, що вже пройдені методом, або ж до індексів за межами цього діапазону, не будуть опрацьовані функцією `callbackFn`. Якщо наявні елементи змінюються чи видаляються, то до `callbackFn` буде передано їх фактичне значення на момент, коли функція `callbackFn` їх опрацьовує. Ті елементи, які були видалені до моменту, як їх опрацювала функція, опрацьовані не будуть.

> **Обережно:** Одночасні модифікації такого типу, як описано в попередньому абзаці, часто приводять до коду, який важко зрозуміти. Загалом заведено уникати такого запису (окрім особливих випадків).

Згідно з алгоритмом, зазначеним у специфікації, якщо метод `map` викликається на розрідженому масиві, то результат також буде розрідженим масивом, зберігаючи порожніми ті самі індекси.

## Поліфіл

Метод `map` було додано до 5-ї редакції стандарту ECMA-262.  Тобто, він може бути доступний не у всіх його реалізаціях.

Цю проблему можна обійти шляхом додавання наступного коду на початку скрипту. Фактично це дозволить використовувати `map` у реалізаціях ECMA-262, які не підтримують його нативно. Це точнісінько той самий алгоритм, який наведено у 5-й редакції ECMA-262, з поправкою на припущення, що {{jsxref("Object")}}, {{jsxref("TypeError")}} та {{jsxref("Array")} мають свої початкові значення, і що `callback.call` зводиться до початкового значення {{jsxref("Function.prototype.call()")}}.

```js
// Етапи створення ECMA-262, 5 редакція, 15.4.4.19
// Посилання: https://es5.github.io/#x15.4.4.19
if (!Array.prototype.map) {

  Array.prototype.map = function(callback/*, thisArg*/) {

    var T, A, k;

    if (this == null) {
      throw new TypeError('this is null or not defined');
    }

    // 1. Нехай O буде результатом викликання ToObject зі значенням |this|
    //    як аргументом.
    var O = Object(this);

    // 2. Нехай lenValue буде результатом виклику внутрішнього методу Get
    //    об'єкту O з аргументом "length".
    // 3. Нехай len буде ToUint32(lenValue).
    var len = O.length >>> 0;

    // 4. Якщо IsCallable(callback) є хибою, викидаємо виняток TypeError.
    // Дивіться: https://es5.github.com/#x9.11
    if (typeof callback !== 'function') {
      throw new TypeError(callback + ' is not a function');
    }

    // 5. Якщо було передано thisArg, нехай T буде thisArg; інакше ж хай T залишається невизначеним.
    if (arguments.length > 1) {
      T = arguments[1];
    }

    // 6. Нехай A буде новим масивом, створеним виразом new Array(len),
    //    де Array — це стандартний вбудований конструктор з таким ім'ям, і
    //    len — це вказане вище значення len.
    A = new Array(len);

    // 7. Нехай k буде 0
    k = 0;

    // 8. Повторювати, поки k < len
    while (k < len) {

      var kValue, mappedValue;

      // a. Нехай Pk буде ToString(k).
      //   Ця операція виконується неявно для лівих операндів оператора in
      // b. Нехай kPresent буде результатом виклику внутрішнього методу HasProperty
      //    об'єкту O з аргументом Pk.
      //   Цей крок можна об'єднати з пунктом c
      // c. Якщо kPresent — істина, то
      if (k in O) {

        // i. Нехай kValue — це результат викликання внутрішнього методу Get
        //    об'єкту O з аргументом Pk.
        kValue = O[k];

        // ii. Нехай mappedValue буде результатом викликання внутрішнього методу Call
        //     переданої функції зворотного виклику з T як значенням "this",
        //     і набором аргументів, що містять kValue, k, and O.
        mappedValue = callback.call(T, kValue, k, O);

        // iii. Викликати внутрішній метод DefineOwnProperty об'єкту A з такими аргументами:
        // Pk, Property Descriptor
        // { Value: mappedValue,
        //   Writable: true,
        //   Enumerable: true,
        //   Configurable: true },
        // і false.

        // В браузерах, які підтримують Object.defineProperty, застосувати наступне:
        // Object.defineProperty(A, k, {
        //   value: mappedValue,
        //   writable: true,
        //   enumerable: true,
        //   configurable: true
        // });

        // Для найкращого покриття серед браузерів, використати такий запис:
        A[k] = mappedValue;
      }
      // d. Збільшити k на 1.
      k++;
    }

    // 9. повернути A
    return A;
  };
}
```

## Приклади

### Перетворення масиву чисел у масив їх квадратних коренів

Наступний код приймає масив чисел, і створює новий масив, який містить квадратні корені з чисел із першого масиву.

```js
let numbers = [1, 4, 9]
let roots = numbers.map(function(num) {
    return Math.sqrt(num)
})
// roots тепер         [1, 2, 3]
// numbers залишається [1, 4, 9]
```

### Застосування `map` для зміни формату об'єктів у масиві

Наступний код приймає масив об'єктів, і створює новий масив, який містить нові об'єкти у зміненому форматі.

```js
let kvArray = [{key: 1, value: 10},
               {key: 2, value: 20},
               {key: 3, value: 30}]

let reformattedArray = kvArray.map(obj => {
   let rObj = {}
   rObj[obj.key] = obj.value
   return rObj
})
// reformattedArray тепер [{1: 10}, {2: 20}, {3: 30}],

// kvArray залишається таким:
// [{key: 1, value: 10},
//  {key: 2, value: 20},
//  {key: 3, value: 30}]
```

### Перебирання масиву чисел із застосуванням функції з аргументом

Наступний код показує, як `map` працює з функцією, яка приймає лише один аргумент. Аргументу буде автоматично присвоєно значення кожного з елементів масиву, поки `map` проходить в циклі крізь початковий масив.

```js
let numbers = [1, 4, 9]
let doubles = numbers.map(function(num) {
  return num * 2
})

// doubles тепер       [2, 8, 18]
// numbers залишається [1, 4, 9]
```

### Узагальнене застосування `map`

Цей приклад показує, як застосувати функцію `map` на {{jsxref("String")}}, щоб отримати масив байтів, де кожен елемент означає значення символу в кодуванні ASCII:

```js
let map = Array.prototype.map
let a = map.call('Hello World', function(x) {
  return x.charCodeAt(0)
})
// a тепер виглядає так: [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]
```

### Узагальнене застосування `map` із querySelectorAll

Цей приклад показує, як обходити колекцію об'єктів, зібраних функцією `querySelectorAll`. Головним чином тому, що `querySelectorAll` повертає так званий `NodeList` (який є колекцією об'єктів, а не масивом).

В цьому випадку ми отримаємо значення всі вибраних на екрані елементів `option`:

```js
let elems = document.querySelectorAll('select option:checked')
let values = Array.prototype.map.call(elems, function(obj) {
  return obj.value
})
```

Простіший спосіб — застосувати метод {{jsxref("Array.from()")}}.

### Нетривіальний випадок

([Натхненний цим дописом](http://www.wirfs-brock.com/allen/posts/166))

Поширеним є застосовувати функції зворотного виклику з одним аргументом (елементом, який безпосередньо опрацьовується).
Деякі функції також зазвичай застосовуються з одним аргументом, навіть якщо вони також приймають додаткові необов'язкові аргументи. Ці звички можуть призводити до заплутаної поведінки.

Припустимо, у нас є:

```js
["1", "2", "3"].map(parseInt)
```

В той час, коли хтось може очікувати щось, схоже на `[1, 2, 3]`, фактичний результат є `[1, NaN, NaN]`.

{{jsxref("parseInt")}} часто використовується з одним аргументом, хоча приймає два. Перший із них - це вираз, а другий — основа для системи числення.

До функції зворотного виклику `Array.prototype.map` передає три аргументи:

- сам елемент
- його порядковий номер
- масив

Третій аргумент ігнорується функцією {{jsxref("parseInt")}}, проте _не_ другий! Ось і джерело можливої плутанини.

Короткий опис кроків циклу:

```js
// parseInt(string, radix) -> map(parseInt(value, index))
/*  перша ітерація (index is 0): */ parseInt("1", 0)  // 1
/*  друга ітерація (index is 1): */ parseInt("2", 1)  // NaN
/*  третя ітерація (index is 2): */ parseInt("3", 2)  // NaN
```

Як розв'язати цю проблему.

```js
function returnInt(element) {
  return parseInt(element, 10)
}

['1', '2', '3'].map(returnInt); // [1, 2, 3]
// В результаті маємо масив чисел (як і очікувалось)

// Те саме, що і вище, але у лаконічному записі через стрілкову функцію
['1', '2', '3'].map( str => parseInt(str) )

// Простіший спосіб і досягнути того ж, і уникнути підводного каменю:
['1', '2', '3'].map(Number)  // [1, 2, 3]

// Але на відміну від parseInt(), Number() також поверне і число з рухомою крапкою, і (розібраний) експоненціальний запис:
['1.1', '2.2e2', '3e300'].map(Number)  // [1.1, 220, 3e+300]

// Для порівняння, якби ми застосували parseInt() на попередньому масиві:
['1.1', '2.2e2', '3e300'].map( str => parseInt(str) ) // [1, 2, 3]
```

Інакший варіант результату виклику методу `map` із функцією {{jsxref("parseInt")}} як аргументом виглядає так:

```js
let xs = ['10', '10', '10']

xs = xs.map(parseInt)

console.log(xs)
// 10,NaN,2 в результаті може бути несподіваним, з урахуванням опису вище.
```

### Оригінальний масив містить undefined

Коли не повертається нічого, або {{jsxref("undefined")}}, маємо:

```js
let numbers = [1, 2, 3, 4]
let filteredNumbers = numbers.map(function(num, index) {
  if (index < 3) {
     return num
  }
})
// index починається з нуля 0, тому filterNumbers містять 1,2,3 і undefined.
// filteredNumbers має [1, 2, 3, undefined]
// numbers залишається [1, 2, 3, 4]
```

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

## Дивіться також

- Поліфіл `Array.prototype.map` наявний у [`core-js`](https://github.com/zloirock/core-js#ecmascript-array)
- {{jsxref("Array.prototype.forEach()")}}
- Об'єкт {{jsxref("Map")}}
- {{jsxref("Array.from()")}}
