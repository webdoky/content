---
title: Array.prototype.map()
slug: Web/JavaScript/Reference/Global_Objects/Array/map
tags:
  - Array
  - ECMAScript 5
  - JavaScript
  - Method
  - Prototype
  - Reference
  - Polyfill
browser-compat: javascript.builtins.Array.map
---

{{JSRef}}

Метод **`map()`** (відобразити) **створює новий масив**, наповнений результатами виклику переданої функції на кожному з елементів початкового масиву.

{{EmbedInteractiveExample("pages/js/array-map.html")}}

## Синтаксис

```js
// Стрілкова функція
map((element) => {
  /* ... */
});
map((element, index) => {
  /* ... */
});
map((element, index, array) => {
  /* ... */
});

// Функція зворотного виклику
map(callbackFn);
map(callbackFn, thisArg);

// Функція зворотного виклику, оголошена на місці
map(function (element) {
  /* ... */
});
map(function (element, index) {
  /* ... */
});
map(function (element, index, array) {
  /* ... */
});
map(function (element, index, array) {
  /* ... */
}, thisArg);
```

### Параметри

- `callbackFn`

  - : Функція, яка викликається на кожному з елементів масиву. Кожного разу, коли виконується `callbackFn`, результат її виклику додається до нового масиву.

    Ця функція викликається із наступними аргументами:

    - `element`
      - : Поточний елемент масиву, який зараз опрацьовується.
    - `index`
      - : Порядковий номер поточного елемента масиву, який зараз обробляється.
    - `array`
      - : Масив, на якому було викликано метод `map`.

- `thisArg` {{optional_inline}}
  - : Значення, що під час виконання `callbackFn` буде використано як `this`.

### Результат

Новий масив, куди входять всі результати викликання переданої функції зворотного виклику.

## Опис

Метод `map` викликає передану функцію `callbackFn` **один раз для кожного елемента** масиву, в порядку зростання індексу, і формує новий масив із результатів. `callbackFn` викликається лише для тих індексів, які мають присвоєне значення (включно з {{jsxref("undefined")}}).

Вона _не_ викликається для пропущених елементів масиву. Маються на увазі:

- індекси, які ніколи не встановлювались;
- індекси, які було видалено.

### Коли не слід застосовувати map()

Оскільки `map` будує новий масив, його застосування є поганою практикою в тих ситуаціях, коли повернений в результаті масив не використовується. Натомість краще використати {{jsxref("Array/forEach", "forEach")}} чи {{jsxref("Statements/for...of", "for...of")}}.

Не слід використовувати `map`, якщо виконується принаймні одна з умов:

- повернений в результаті масив не використовується;
- передана функція зворотного виклику не повертає результату.

### Докладно про параметри

Функція `callbackFn` викликається з трьома аргументами: значенням елементу, його порядковим номером і об'єктом масиву, який, власне, перебирається.

У випадку, коли передано параметр `thisArg`, його буде використано як значення `this` у функції зворотного виклику. В протилежному випадку для `this` буде використано значення {{jsxref("undefined")}}. Загалом значення `this`, яке бачитиме функція `callback`, визначається згідно з [загальними правилами визначення значення `this`, доступного для функції](/uk/docs/Web/JavaScript/Reference/Operators/this).

Метод `map` не змінює початковий масив, на якому він викликається (хоча передана всередину функція `callbackFn` може це робити).

Діапазон елементів, що опрацьовуються методом `map`, задається до першого виклику `callbackFn`. Елементи, які будуть присвоєні до індексів, що вже пройдені методом, або ж до індексів за межами цього діапазону, не будуть опрацьовані функцією `callbackFn`. Якщо наявні елементи змінюються чи видаляються, то до `callbackFn` буде передано їх фактичне значення на момент, коли функція `callbackFn` їх опрацьовує. Ті елементи, які були видалені до моменту, як їх опрацювала функція, опрацьовані не будуть.

> **Застереження:** Одночасні модифікації такого типу, як описано в попередньому абзаці, часто приводять до коду, який важко зрозуміти. Загалом заведено уникати такої логіки (окрім особливих випадків).

Згідно з алгоритмом, зазначеним у специфікації, якщо метод `map` викликається на розрідженому масиві, то результат також буде розрідженим масивом, зберігаючи порожніми ті самі індекси.

## Приклади

### Перетворення масиву чисел на масив їх квадратних коренів

Наступний код приймає масив чисел і створює новий масив, який містить квадратні корені чисел із першого масиву.

```js
const numbers = [1, 4, 9];
const roots = numbers.map((num) => Math.sqrt(num));
// roots тепер         [1, 2, 3]
// numbers залишається [1, 4, 9]
```

### Застосування `map` для зміни формату об'єктів у масиві

Наступний код приймає масив об'єктів і створює новий масив, який містить нові об'єкти у зміненому форматі.

```js
const kvArray = [
  { key: 1, value: 10 },
  { key: 2, value: 20 },
  { key: 3, value: 30 },
];

const reformattedArray = kvArray.map(({ key, value }) => ({ [key]: value }));
// reformattedArray тепер [{1: 10}, {2: 20}, {3: 30}],

// kvArray залишається таким:
// [{key: 1, value: 10},
//  {key: 2, value: 20},
//  {key: 3, value: 30}]
```

### Перебирання масиву чисел із застосуванням функції з аргументом

Наступний код показує, як `map` працює з функцією, яка приймає лише один аргумент. Аргументу буде автоматично присвоєно значення кожного з елементів масиву, поки `map` проходить в циклі крізь початковий масив.

```js
const numbers = [1, 4, 9];
const doubles = numbers.map((num) => num * 2);

// doubles тепер       [2, 8, 18]
// numbers залишається [1, 4, 9]
```

### Узагальнене застосування `map`

Цей приклад показує, як застосувати функцію `map` на {{jsxref("String")}}, щоб отримати масив байтів, де кожен елемент означає значення символу в кодуванні ASCII:

```js
const map = Array.prototype.map;
const charCodes = map.call('Hello World', (x) => x.charCodeAt(0));
// charCodes тепер має такий вигляд: [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]
```

### Узагальнене застосування `map` із querySelectorAll

Цей приклад показує, як обходити колекцію об'єктів, зібраних функцією `querySelectorAll`. Річ у тім, що `querySelectorAll` повертає так званий `NodeList` (який є колекцією об'єктів, а не масивом).

В цьому випадку будуть отримані значення всіх на екрані вибраних елементів `option`:

```js
const elems = document.querySelectorAll('select option:checked');
const values = Array.prototype.map.call(elems, ({ value }) => value);
```

Простіший спосіб — застосувати метод {{jsxref("Array.from()")}}.

### Нетривіальний випадок

([Натхненний цим дописом (англ.)](https://wirfs-brock.com/allen/posts/166))

Поширеним є застосування функцій зворотного виклику з одним аргументом (елементом, який безпосередньо опрацьовується). Деякі функції також зазвичай застосовуються з одним аргументом, навіть якщо вони також приймають додаткові необов'язкові аргументи. Такі звички можуть призводити до заплутаної поведінки.

Припустимо, у нас є:

```js
['1', '2', '3'].map(parseInt);
```

Хоч можна було б очікувати чогось подібного до `[1, 2, 3]`, фактичним результатом є `[1, NaN, NaN]`.

{{jsxref("parseInt")}} часто використовується з одним аргументом, хоча приймає два. Перший із них - це вираз, а другий — основа для системи числення.

`Array.prototype.map` передає до функції зворотного виклику три аргументи:

- сам елемент
- його порядковий номер
- масив

Третій аргумент ігнорується функцією {{jsxref("parseInt")}}, проте _не_ другий! Ось і джерело можливої плутанини.

Короткий опис кроків циклу:

```js
// parseInt(string, radix) -> map(parseInt(value, index))
/*  перша ітерація (index – 0): */ parseInt('1', 0); // 1
/*  друга ітерація (index – 1): */ parseInt('2', 1); // NaN
/*  третя ітерація (index – 2): */ parseInt('3', 2); // NaN
```

Як розв'язати цю проблему:

```js
const returnInt = (element) => parseInt(element, 10);

['1', '2', '3'].map(returnInt); // [1, 2, 3]
// В результаті маємо масив чисел (як і очікувалось)

// Те саме, що і вище, але у лаконічному записі через стрілкову функцію
['1', '2', '3']
  .map((str) => parseInt(str)) // [1, 2, 3]

  [
    // Простіший спосіб і досягнути того ж, і уникнути підводного каменю:
    ('1', '2', '3')
  ].map(Number) // [1, 2, 3]

  [
    // Але, на відміну від parseInt(), Number() також поверне і число з рухомою крапкою, і (розібраний) експоненціальний запис:
    ('1.1', '2.2e2', '3e300')
  ].map(Number) // [1.1, 220, 3e+300]

  [
    // Для порівняння, якби ми застосували parseInt() на попередньому масиві:
    ('1.1', '2.2e2', '3e300')
  ].map((str) => parseInt(str)); // [1, 2, 3]
```

Інакший варіант результату виклику методу `map` із функцією {{jsxref("parseInt")}} як аргументом має такий вигляд:

```js
const strings = ['10', '10', '10'];
const numbers = strings.map(parseInt);

console.log(numbers);
// [10, NaN, 2] в результаті може бути несподіваним, з урахуванням опису вище.
```

### Результівний масив містить undefined

Коли повернене значення відсутнє або дорівнює {{jsxref("undefined")}}, маємо:

```js
const numbers = [1, 2, 3, 4];
const filteredNumbers = numbers.map((num, index) => {
  if (index < 3) {
    return num;
  }
});
// index починається з 0, тому filterNumbers містить 1,2,3 й undefined.
// filteredNumbers має [1, 2, 3, undefined]
// numbers залишається [1, 2, 3, 4]
```

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

## Дивіться також

- [Поліфіл `Array.prototype.map` у `core-js`](https://github.com/zloirock/core-js#ecmascript-array)
- {{jsxref("Array.prototype.forEach()")}}
- Об'єкт {{jsxref("Map")}}
- {{jsxref("Array.from()")}}
