---
title: Array.prototype.sort()
slug: Web/JavaScript/Reference/Global_Objects/Array/sort
tags:
  - Array
  - Array method
  - JavaScript
  - Method
  - Prototype
  - Sorting
  - Polyfill
browser-compat: javascript.builtins.Array.sort
---

{{JSRef}}

Метод **`sort()`** (сортувати) сортує елементи масиву _[на місці (англ.)](https://en.wikipedia.org/wiki/In-place_algorithm)_ й повертає посилання на той самий масив, уже відсортований. Усталений порядок сортування — в порядку зростання, заснований на перетворенні елементів на рядки, а потім порівнянні їхніх послідовностей значень кодових одиниць UTF-16.

Складність алгоритму сортування щодо використання часу та місця в пам'яті ніяк не гарантується і залежить від реалізації.

{{EmbedInteractiveExample("pages/js/array-sort.html")}}

## Синтаксис

```js
// Без функції порівняння
sort();

// Стрілкова функція
sort((a, b) => {
  /* ... */
});

// Функція порівняння
sort(compareFn);

// Функція порівняння, оголошена на місці
sort(function compareFn(a, b) {
  /* ... */
});
```

### Параметри

- `compareFn` (функція порівняння) {{optional_inline}}

  - : Задає функцію, яка визначатиме порядок сортування. Якщо вона опущена, то елементи масиву перетворюються на рядки, а потім сортуються відносно значення юнікодного коду кожного символу.

    - `a`
      - : Перший елемент для порівняння.
    - `b`
      - : Другий елемент для порівняння.

### Повернене значення

Посилання на вихідний масив, уже відсортований. Зауважте, що масив сортується _[на місці (англ.)](https://en.wikipedia.org/wiki/In-place_algorithm)_: ніяких додаткових копій не створюється.

## Опис

Якщо `compareFunction` передано не було, всі елементи масиву, котрі не є `undefined`, сортуються шляхом перетворення їх на рядки та порівняння цих рядків в порядку кодів UTF-16. Наприклад, "банан" йде перед "черешнею". У разі сортування чисел – 9 йде перед 80, але через те, що числа перетворюються на рядки перед сортуванням, "80" йде перед "9" згідно з послідовністю кодів Unicode. Всі елементи, які є `undefined`, складаються в кінець масиву.

> **Примітка:** В UTF-16 символи юнікоду вище `\uFFFF` кодуються як сурогатні пари кодів з проміжку `\uD800`-`\uDFFF`. Під час порівняння значення кожного коду такої пари враховується окремо. Таким чином, символ, сформований сурогатною парою `\uD855\uDE51`, під час сортування опиниться перед символом `\uFF3A`.

Якщо було передано функцію порівняння `compareFunction`, всі елементи масиву, котрі не є `undefined`, сортуються відповідно поверненого значення функції порівняння (всі елементи, які містять `undefined`, складаються в кінець масиву без викликання `compareFunction`).

| Повернене значення `compareFunction(a, b)` | Порядок сортування                    |
| ------------------------------------------ | ------------------------------------- |
| > 0                                        | сортує `a` після `b`                  |
| < 0                                        | сортує `a` перед `b`                  |
| === 0                                      | зберігає початковий порядок `a` і `b` |

Отже, функція порівняння має наступну форму:

```js
function compare(a, b) {
  if (a менше за b за якимось критерієм впорядкуваня) {
    return -1;
  }
  if (a більше за b за тим самим критерієм впорядкування) {
    return 1;
  }
  // a має дорівнювати b
  return 0;
}
```

Більш формально кажучи, очікується, що компаратор для відповідного виконання сортування матиме наступні властивості:

- _Чистоту_: Компаратор не змінює об‘єкти, що порівнюються, чи будь-який зовнішній стан. (Це важливо, адже немає гарантій того, _коли_ і _як_ компаратор буде викликаний, тож будь-який конкретний виклик не повинен породжувати видимих зовні ефектів.)
- _Стабільність_: Компаратор повертає однаковий результат для кожної пари елементів.
- _Рефлексивність_: `compare(a, a) === 0`.
- _Симетричність_: `compare(a, b) === 0` і `compare(b, a) === 0` повинні або обидвоє бути нулями, або мати протилежні знаки.
- _Транзитивність_: Якщо і `compare(a, b)`, і `compare(b, c)` водночас є або додатними значеннями, або нулями, або від‘ємними, то `compare(a, c)` матиме такий самий знак, як і попередні двоє.

Компаратор, що відповідає обмеженням вище, обов‘язково в деяких випадках повертатиме `1`, `0` і `-1`, або ж він постійно повертатиме `0`. Наприклад, якщо компаратор повертає лише `1` і `0`, або ж якщо повертає лише `0` і `-1`, він не зможе надійно сортувати, бо _симетричність_ буде порушена. Компаратор, що завжди повертає `0`, призведе до того, що масив узагалі не зміниться, але буде в цьому надійним.

Усталений лексикографічний компаратор відповідає усім вищеописаним обмеженням.

Щоб порівняти числа замість рядків, функція порівняння може віднімати `b` від `a`. Наступна функція відсортує масив у порядку зростання (якщо він не містить `Infinity` чи `NaN`):

```js
function compareNumbers(a, b) {
  return a - b;
}
```

Метод `sort` можна зручно використовувати з {{jsxref("Operators/function", "виразами функцій", "", 1)}}:

```js
const numbers = [4, 2, 5, 1, 3];
numbers.sort(function (a, b) {
  return a - b;
});
console.log(numbers);

// [1, 2, 3, 4, 5]
```

ES2015 дає змогу користуватись {{jsxref("Functions/Arrow_functions", "виразами стрілкової функції", "", 1)}} зі ще коротшим синтаксисом.

```js
const numbers = [4, 2, 5, 1, 3];
numbers.sort((a, b) => a - b);
console.log(numbers);

// [1, 2, 3, 4, 5]
```

Масив об'єктів можна сортувати шляхом порівняння значень однієї з їхніх властивостей.

```js
const items = [
  { name: 'Edward', value: 21 },
  { name: 'Sharpe', value: 37 },
  { name: 'And', value: 45 },
  { name: 'The', value: -12 },
  { name: 'Magnetic', value: 13 },
  { name: 'Zeros', value: 37 },
];

// сортувати за властивістю value
items.sort(function (a, b) {
  return a.value - b.value;
});

// сортувати за властивістю name
items.sort(function (a, b) {
  const nameA = a.name.toUpperCase(); // ігноруємо малі та великі літери
  const nameB = b.name.toUpperCase(); // ігноруємо малі та великі літери
  if (nameA < nameB) {
    return -1;
  }
  if (nameA > nameB) {
    return 1;
  }

  // значення полів name однакові
  return 0;
});
```

## Приклади

### Створення, показування і сортування масиву

Наступний приклад створює чотири масиви, далі показує вихідний масив, а потім<span class="x x-first x-last"> —</span> відсортовані масиви. Числові масиви сортуються спочатку без функції сортування, а потім із нею.

```js
const stringArray = ['Кит синій', 'Горбатий кит', 'Білуга'];
const numberArray = [40, 1, 5, 200];
const numericStringArray = ['80', '9', '700'];
const mixedNumericArray = ['80', '9', '700', 40, 1, 5, 200];

function compareNumbers(a, b) {
  return a - b;
}

stringArray.join(); // 'Кит синій,Горбатий кит,Білуга'
stringArray.sort(); // ['Білуга', 'Горбатий кит', 'Кит синій']

numberArray.join(); // '40,1,5,200'
numberArray.sort(); // [1, 200, 40, 5]
numberArray.sort(compareNumbers); // [1, 5, 40, 200]

numericStringArray.join(); // '80,9,700'
numericStringArray.sort(); // ['700', '80', '9']
numericStringArray.sort(compareNumbers); // ['9', '80', '700']

mixedNumericArray.join(); // '80,9,700,40,1,5,200'
mixedNumericArray.sort(); // [1, 200, 40, 5, '700', '80', '9']
mixedNumericArray.sort(compareNumbers); // [1, 5, '9', 40, '80', 200, '700']
```

### Сортування не-ASCII символів

Для сортування рядків з не-ASCII символами, наприклад, рядків з діакритичними знаками (e, é, è, a, ä, та ін.) чи рядків з інших мов, не англійської, використовуйте {{jsxref("String.localeCompare")}}. Ця функція дає змогу порівнювати саме такі символи, так що вони опиняться у вірній послідовності.

```js
const items = ['réservé', 'premier', 'communiqué', 'café', 'adieu', 'éclair'];
items.sort(function (a, b) {
  return a.localeCompare(b);
});

// items містить ['adieu', 'café', 'communiqué', 'éclair', 'premier', 'réservé']
```

### Сортування з `map`

Функція порівняння `compareFunction` може викликатися декілька разів на елемент масиву. Залежно від природи `compareFunction`, це може призвести до високих накладних витрат. Чим більше роботи виконує функція `compareFunction`, і чим більше елементів треба відсортувати, тим ефективніше буде застосувати [`map()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Array/map) для сортування. Ідея полягає в тому, щоб перебрати масив один раз, щоб витягнути значення для сортування у тимчасовий масив, потім відсортувати тимчасовий масив, і далі перебрати тимчасовий масив іще раз, для отримання правильної послідовності.

```js
// масив, який треба відсортувати
const data = ['Григорій', 'Анна', 'Василь', 'Богдан'];

// тимчасовий масив містить об'єкти з позицією елемента в оригінальному масиві і значенням для сортування
const mapped = data.map((v, i) => {
  return { i, value: someSlowOperation(v) };
});

// сортуємо тимчасовий масив, що містить уже обраховані значення
mapped.sort((a, b) => {
  if (a.value > b.value) {
    return 1;
  }
  if (a.value < b.value) {
    return -1;
  }
  return 0;
});

const result = mapped.map((v) => data[v.i]);
```

Існує опенсорсна бібліотека [mapsort](https://github.com/Pimm/mapsort), котра реалізовує такий підхід.

### sort() повертає посилання на той самий масив

Метод `sort()` повертає посилання на вихідний масив, тож внесення змін до поверненого масиву змінить також вихідний масив.

```js
const numbers = [3, 1, 4, 1, 5];
const sorted = numbers.sort((a, b) => a - b);
// numbers і sorted – рівні [1, 1, 3, 4, 5]
sorted[0] = 10;
console.log(numbers[0]); // 10
```

Якщо потрібно, аби `sort()` не змінював вихідний масив, а повертав [поверхнево скопійований](/uk/docs/Glossary/Shallow_copy) масив, як інші методи (наприклад, [`map()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Array/map)), можна зробити поверхневу копію до виклику `sort()`, використовуючи [синтаксис розгортання](/uk/docs/Web/JavaScript/Reference/Operators/Spread_syntax) чи [`Array.from()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Array/from).

```js
const numbers = [3, 1, 4, 1, 5];
// [...numbers] створює поверхневу копію, тож sort() не міняє вихідного масиву
const sorted = [...numbers].sort((a, b) => a - b);
sorted[0] = 10;
console.log(numbers[0]); // 3
```

### Стабільність сортування

Починаючи з версії 10 (або EcmaScript 2019), [специфікація (англ.)](https://tc39.es/ecma262/#sec-array.prototype.sort) постулює, що `Array.prototype.sort` дає стабільне сортування.

Для прикладу, скажімо, є список студентів з їхніми оцінками. Зауважте, що цей список вже відсортований за іменами в алфавітному порядку:

```js
const students = [
  { name: 'Артур', grade: 13 },
  { name: 'Олексій', grade: 15 },
  { name: 'Рустем', grade: 15 },
  { name: 'Самійло', grade: 14 },
];
```

Після сортування цього масиву за полем `grade` у порядку зростання маємо:

```js
students.sort((firstItem, secondItem) => firstItem.grade - secondItem.grade);
```

Змінна з масивом `students` далі матиме наступне значення:

```js
[
  { name: 'Артур', grade: 13 },
  { name: 'Самійло', grade: 14 },
  { name: 'Олексій', grade: 15 }, // збережено первісне сортування для однакових оцінок (стабільне сортування)
  { name: 'Рустем', grade: 15 }, // збережено первісне сортування для однакових оцінок (стабільне сортування)
];
```

Важливо зауважити, що студенти, які мають однакові оцінки (для прикладу, Олексій та Рустем), залишаться в тому ж порядку, що й перед сортуванням. Це те, що гарантує алгоритм стабільного сортування.

До версії 10 (чи EcmaScript 2019) стабільність сортування не гарантувалась, тобто могла трапитись наступна ситуація:

```js
[
  { name: 'Артур', grade: 13 },
  { name: 'Самійло', grade: 14 },
  { name: 'Рустем', grade: 15 }, // первісне сортування не збережено
  { name: 'Олексій', grade: 15 }, // первісне сортування не збережено
];
```

### Сортування з погано сформованим компаратором

Якщо функція порівняння не задовольняє кожному з правил: чистоти, стабільності, рефлексивності, симетричності або транзитивності, як це пояснено в [описі](#opys), то поведінка програми не є чітко визначеною.

Для прикладу – погляньте на такий код:

```js
const arr = [3, 1, 4, 1, 5, 9];
const compare = (a, b) => (a > b ? 1 : 0);
arr.sort(compare);
```

Тут функція `compare` є погано сформованою, тому що не задовольняє правилу симетричності: якщо `a > b`, вона повертає `1`; однак якщо поміняти `a` й `b` місцями, вона замість від‘ємного значення повертає `0`. Таким чином, результівний масив буде різним на різних рушіях. Наприклад, V8 (що використовується Chrome, Node.js тощо) та JavaScriptCore (використовується Safari) не сортуватимуть масив узагалі й повернуть `[3, 1, 4, 1, 5, 9]`, натомість SpiderMonkey (використовується Firefox) поверне масив, відсортований в порядку зростання: `[1, 1, 3, 4, 5, 9]`.

А проте, якщо трохи змінити функцію `compare`, щоб вона повертала або `-1`, або `0`:

```js
const arr = [3, 1, 4, 1, 5, 9];
const compare = (a, b) => (a > b ? -1 : 0);
arr.sort(compare);
```

Тоді V8 і JavaScriptCore відсортують масив у порядку спадання: `[9, 5, 4, 3, 1, 1]`, натомість SpiderMonkey поверне його як є: `[3, 1, 4, 1, 5, 9]`.

У зв‘язку з цією неузгодженістю реалізацій краще завжди формувати компаратори як слід, виконуючи усі п‘ять вимог.

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

## Дивіться також

- [Поліфіл для `Array.prototype.sort` з сучасною поведінкою (включно зі стабільним сортуванням) у `core-js`](https://github.com/zloirock/core-js#ecmascript-array)
- {{jsxref("Array.prototype.reverse()")}}
- {{jsxref("String.prototype.localeCompare()")}}
- [Про стабільність алгоритму, застосованого в рушії V8 (англ.)](https://v8.dev/blog/array-sort)
- [Стабільність сортування V8 (англ.)](https://v8.dev/features/stable-sort)
- [Демонстрація стабільності сортування від Матіаса Байненса (англ.)](https://mathiasbynens.be/demo/sort-stability)
