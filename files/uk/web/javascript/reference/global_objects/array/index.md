---
title: Array
slug: Web/JavaScript/Reference/Global_Objects/Array
tags:
  - Array
  - Class
  - Example
  - Global Objects
  - JavaScript
  - Reference
browser-compat: javascript.builtins.Array
---
{{JSRef}}

Клас **`Array`** у JavaScript - це глобальний об'єкт, що використовується для створення масивів, які є високорівневими об'єктами, подібними до списків.

## Опис

Масиви &mdash; це подібні до списків об'єкти, чий прототип володіє методами для перебирання елементів та операцій зміни. Ні довжина масиву у JavaScript, ні тип його елементів не є фіксованими. Позаяк довжина масиву може змінитися в будь-який момент, і дані можуть перебувати в несуміжних місцях масиву, масиви у JavaScript не можуть бути гарантовано щільними; це залежить від того, як програміст їх використовує. Загалом це доволі зручні характеристики; проте якщо ці особливості для вашого конкретного випадку, ви можете розглянути можливість використання типізованих масивів.

Масиви не можуть використовувати рядок як індекс елементу (так, як це працює в [асоціативному масиві](https://en.wikipedia.org/wiki/Associative_array)), але повинні використовувати цілі числа. Задання, або доступ до значення за не цілочисельним індексом при використанні [квадратних дужок](/uk/docs/Web/JavaScript/Guide/Working_with_Objects#objects_and_properties) (або [крапкової нотації](/uk/docs/Web/JavaScript/Reference/Operators/Property_Accessors)) не задасть і не поверне елемент з масиву, проте змінить або поверне відповідну змінну у [колекції властивостей об'єкту](/uk/docs/Web/JavaScript/Data_structures#properties) цього масиву. Властивості об'єкту масиву відокремлені від власне послідовності елементів масиву, і [операції для перебирання і мутації](/uk/docs/Web/JavaScript/Guide/Indexed_collections#array_methods) масивів не можуть застосовуватися до цих іменованих полів.

### Загальні операції

**Створення масиву**

```js
let fruits = ['Apple', 'Banana']

console.log(fruits.length)
// 2
```

**Доступ до елементу масиву із використанням індексу позиції**

```js
let first = fruits[0]
// Apple

let last = fruits[fruits.length - 1]
// Banana
```

**Перебирання елементів масиву у циклі**

```js
fruits.forEach(function(item, index, array) {
  console.log(item, index)
})
// Apple 0
// Banana 1
```

**Додавання елементу в кінець масиву**

```js
let newLength = fruits.push('Orange')
// ["Apple", "Banana", "Orange"]
```

**Видалення елементу на кінці масиву**

```js
let last = fruits.pop() // видаляємо Orange (з кінця)
// ["Apple", "Banana"]
```

**Видалення елементу з початку масиву**

```js
let first = fruits.shift() // видаляємо Apple на початку
// ["Banana"]
```

**Додавання елементу в початок масиву**

```js
let newLength = fruits.unshift('Strawberry') // додаємо на початку
// ["Strawberry", "Banana"]
```

**Знаходження індексу елементу в масиві**

```js
fruits.push('Mango')
// ["Strawberry", "Banana", "Mango"]

let pos = fruits.indexOf('Banana')
// 1
```

**Видалення елементу з конкретної позиції**

```js
let removedItem = fruits.splice(pos, 1) // так видаляється елемент

// ["Strawberry", "Mango"]
```

**Видалення декількох елементів за їх позицією**

```js
let vegetables = ['Cabbage', 'Turnip', 'Radish', 'Carrot']
console.log(vegetables)
// ["Cabbage", "Turnip", "Radish", "Carrot"]

let pos = 1
let n = 2

let removedItems = vegetables.splice(pos, n)
// так видаляється елементи, n задає кількість елементів, які слід видалити,
// починаючи з заданого індексу - позиції pos, і продовжуючи в напрямку кінця масиву.

console.log(vegetables)
// ["Cabbage", "Carrot"] (початковий масив було змінено)

console.log(removedItems)
// ["Turnip", "Radish"]
```

**Копіювання масиву**

```js
let shallowCopySpread = [...fruits]
// ["Strawberry", "Mango"]
```

Це — поверхнева копія, виконана за допомогою [оператора розгортання](/uk/docs/Web/JavaScript/Reference/Operators/Spread_syntax). Нижче в розділі [Копіювання масиву](#kopiiuvannia-masyvu) розібрані інші способи скопіювати масив.

### Доступ до елементів масиву

Індекс масивів у JavaScript починається з нуля. Тобто, перший елемент масиву має індекс `0`, а індекс останнього дорівнює значенню властивості довжини {{jsxref("Array.length", "length")}} масиву, мінус `1`.

Використання некоректного числового індексу повертає `undefined`.

```js
let arr = ['це перший елемент', 'це другий елемент', 'це останній елемент']
console.log(arr[0])              // виводить 'це перший елемент'
console.log(arr[1])              // виводить 'це другий елемент'
console.log(arr[arr.length - 1]) // виводить 'це останній елемент'
```

Елементи масиву є властивостями об'єкту у тому ж розумінні, що й `toString` є властивістю (щоправда, якщо бути точним, `toString()` &mdash; це метод). Однак, спроба доступитися до елементу масиву наступним чином викине помилку синтаксису, оскільки таке ім'я властивості не є коректним:

```js
console.log(arr.0) // синтаксична помилка
```

Немає нічого особливого в масивах і властивостях у JavaScript, що призводять до цього. На властивості, що починаються з цифри, не можна посилатися за допомогою крапкової нотації; до них можна доступитися тільки за допомогою квадратних дужок.

Для прикладу, якщо у нас є об'єкт із властивістю, яка називається `3d`, її значення можна отримати тільки за допомогою квадратних дужок.

```js
let years = [1950, 1960, 1970, 1980, 1990, 2000, 2010]
console.log(years.0)   // синтаксична помилка
console.log(years[0])  // працює вірно
```

```js
renderer.3d.setTexture(model, 'character.png')     // синтаксична помилка
renderer['3d'].setTexture(model, 'character.png')  // працює вірно
```

У прикладі із `3d`, рядок `'3d'` *повинна* бути в лапках (бо вона починається з цифри). Але також можливо подавати в лапках і індекси масиву (наприклад, `years['2']` замість `years[2]`), хоча це не є необхідністю.

Цифра `2` у `years[2]` приводиться до рядка самим рушієм JavaScript через неявну `toString` конвертацію. Як наслідок, `'2'` і `'02'` будуть посилатися на дві різні комірки в об'єкті `years`, і наступний приклад цілком може вивести в результаті `true`:

```js
console.log(years['2'] != years['02'])
```

### Зв'язок між довжиною і числовими полями масиву

Властивість {{jsxref("Array.length", "length")}} у масиві пов'язана з його числовими властивостями.

Декілька вбудованих методів масиву (наприклад, {{jsxref("Array.join", "join()")}}, {{jsxref("Array.slice", "slice()")}}, {{jsxref("Array.indexOf", "indexOf()")}}, та ін.) беруть до уваги значення властивості {{jsxref("Array.length", "length")}}, коли їх викликають.

Інші методи (наприклад, {{jsxref("Array.push", "push()")}}, {{jsxref("Array.splice", "splice()")}}, та інші) іще й призводять до змін у властивості {{jsxref("Array.length", "length")}} масиву.

```js
const fruits = []
fruits.push('banana', 'apple', 'peach')

console.log(fruits.length) // 3
```

Під час задання властивості в масиві, коли назва властивості є коректним числовим індексом, і водночас цей індекс вказує за поточні межі масиву, рушій внесе відповідні зміни до значення властивості {{jsxref("Array.length", "length")}} масиву:

```js
fruits[5] = 'mango'
console.log(fruits[5])            // 'mango'
console.log(Object.keys(fruits))  // ['0', '1', '2', '5']
console.log(fruits.length)        // 6
```

Збільшення довжини {{jsxref("Array.length", "length")}} масиву.

```js
fruits.length = 10
console.log(fruits)              // ['banana', 'apple', 'peach', empty x 2, 'mango', empty x 4]
console.log(Object.keys(fruits)) // ['0', '1', '2', '5']
console.log(fruits.length)       // 10
console.log(fruits[8])           // undefined
```

Однак, зменшення значення властивості {{jsxref("Array.length", "length")}} масиву видаляє елементи.

```js
fruits.length = 2
console.log(Object.keys(fruits)) // ['0', '1']
console.log(fruits.length)       // 2
```

Це докладніше описано на сторінці {{jsxref("Array.length")}}.

### Створення масиву з результатів зіставлення

Результат зіставлення {{jsxref("RegExp")}} і рядка може створювати масив. Цей масив містить властивості та елементи, що надають інформацію про знайдені збіги. Такий масив повертають функції {{jsxref("RegExp.exec()")}} і {{jsxref("String.match()")}}.

Щоб краще зрозуміти ці властивості та елементи, гляньте на цей приклад, і після того зверніть увагу на таблицю нижче:

```js
// Зіставити одну "d", за якою слідує одна чи більше "b", після яких йде одна "d"
// Запам'ятати літери "b" та наступні "d", що збіглися
// Ігнорувати регістр літер

const myRe = /d(b+)(d)/i
const myArray = myRe.exec('cdbBdbsbz')
```

Поля та елементи, які будуть повернуті в результаті цього зіставлення, виглядають так:

<table class="fullwidth-table standard-table">
  <thead>
    <tr>
      <th class="header" scope="col">Властивість/Елемент</th>
      <th class="header" scope="col">Опис</th>
      <th class="header" scope="col">Приклад</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>input</code><br />{{ReadOnlyInline}}</td>
      <td>
        Вихідний рядок, який було зіставлено з регулярним виразом.
      </td>
      <td><code>"cdbBdbsbz"</code></td>
    </tr>
    <tr>
      <td><code>index</code><br />{{ReadOnlyInline}}</td>
      <td>Індекс позиції (починаючи з нуля) збігу у стрічці.</td>
      <td><code>1</code></td>
    </tr>
    <tr>
      <td><code>[0]</code><br />{{ReadOnlyInline}}</td>
      <td>Вміст останнього збігу.</td>
      <td><code>"dbBd"</code></td>
    </tr>
    <tr>
      <td><code>[1], ...[n]</code><br />{{ReadOnlyInline}}</td>
      <td>
        Елементи, що містять збіги з частинами регулярного виразу,
        взятого в дужки (за наявності). Кількість частин, виділених дужками,
        не обмежується.
      </td>
      <td>
        <code>[1]: "bB"<br />[2]: "d"</code>
      </td>
    </tr>
  </tbody>
</table>

### Копіювання масиву

Ініціалізація нової змінної з тим самим масивом не створює копії.
Натомість нова змінна лише _посилається_ на початковий масив.
Якщо якийсь елемент зміниться в початковому масиві – це відобразиться і на новому масиві.

```js
let array1 = [1,2,3]
let array1Reference = array1;
array1[1] = 9;
console.log(array1Reference);
// Array [1,9,3]  - зміни в array1 впливають на array1Reference — тобто це насправді не копія
```

Для копіювання масиву необхідно фактично створити нову змінну для масиву, і по новій змінній на кожний примітивний елемент масиву (оскільки ініціалізація змінної примітивним значенням справді створює копію, а не просто посилання на область у пам'яті). JavaScript надає наступні способи зробити це.

Отримання поверхневої копії за допомогою [оператора розгортання](/uk/docs/Web/JavaScript/Reference/Operators/Spread_syntax):

```js
let shallowCopySpread = [...fruits]
// ["Strawberry", "Mango"]
```
Отримання поверхневої копії за допомогою {{jsxref("Array.slice()")}}:

```js
let shallowCopySlice = fruits.slice()
// ["Strawberry", "Mango"]
```
Отримання поверхневої копії за допомогою {{jsxref("Array.from()")}}:

```js
let shallowCopyFrom = Array.from(fruits)
// ["Strawberry", "Mango"]
```

Всі ці способи дають змогу отримати _поверхневу копію_: елементи верхнього рівня копіюються, проте якщо масив містить вкладені об'єкти чи масиви, то вони і далі будуть посилатись на елементи в початковому масиві.

Якщо вам потрібна _глибинна копія_ всіх елементів — така, в якій навіть вкладені масиви також копіюються, а не просто посилаються на елементи первинного масиву — одним із варіантів буде застосувати {{jsxref("JSON.stringify()")}} для перетворення масиву на рядок JSON, і потім перетворити його назад на масив за допомогою {{jsxref("JSON.parse()")}}.

```js
let deepCopy = JSON.parse(JSON.stringify(fruits));
// ["Strawberry", "Mango"]
```

## Конструктор

- {{jsxref("Array/Array", "Array()")}}
  - : Створює новий об'єкт типу `Array`.

## Статичні властивості

- {{jsxref("Array/@@species", "get Array[@@species]")}}
  - : Функція-конструктор, що використовується для створення похідних об'єктів.

## Статичні методи

- {{jsxref("Array.from()")}}
  - : Створює новий екземпляр типу `Array` з будь-якого подібного до масиву, чи об'єкту з можливістю перебору.
- {{jsxref("Array.isArray()")}}
  - : Повертає `true`, якщо аргумент являється масивом, а інакше &mdash; `false`.
- {{jsxref("Array.of()")}}
  - : Створює новий екземпляр об'єкту `Array` з довільного набору аргументів, незалежно від кількості чи типу аргументів.

## Властивості екземпляру

- {{jsxref("Array.prototype.length")}}
  - : Відображає кількість елементів у масиві.
- {{jsxref("Array/@@unscopables", "Array.prototype[@@unscopables]")}}
  - : Символ, що містить імена властивостей, які слід виключати з області прив'язки [`with`](/uk/docs/Web/JavaScript/Reference/Statements/with).

## Методи екземпляру

- {{jsxref("Array.prototype.at()")}}{{Experimental_Inline}}
  - : Повертає елемент масиву за заданим індексом. Приймає також від'ємні цілі числа, які рахуються у зворотному напрямку від останнього елемента.
- {{jsxref("Array.prototype.concat()")}}
  - : Повертає новий масив, утворенням з'єднанням даного масиву з іншим масивом(и) та/чи значенням(и).
- {{jsxref("Array.prototype.copyWithin()")}}
  - : Копіює послідовність елементів всередині масиву.
- {{jsxref("Array.prototype.entries()")}}
  - : Повертає новий об'єкт типу `Array Iterator`, що містить пари ключ/значення для кожного індексу масиву.
- {{jsxref("Array.prototype.every()")}}
  - : Повертає `true`, якщо кожний з елементів масиву задовольняє передану перевіркову функцію.
- {{jsxref("Array.prototype.fill()")}}
  - : Заповнює всі елементи масиву статичним значенням, від початкового індексу до кінцевого.
- {{jsxref("Array.prototype.filter()")}}
  - : Повертає новий масив, що містить всі ті елементи поточного, для яких задана у фільтрі функція повертає `true`.
- {{jsxref("Array.prototype.find()")}}
  - : Повертає знайдений `element` масиву, якщо деякі елементи в масиві задовільняють перевіркову функцію, або `undefined`, якщо нічого знайдено не було.
- {{jsxref("Array.prototype.findIndex()")}}
  - : Повертає індекс знайденого в масиві елементу, якщо елемент в масиві задовільняє перевіркову функцію, або `-1`, якщо нічого не знайдено.
- {{jsxref("Array.prototype.forEach()")}}
  - : Викликає передану функцію з кожним елементом масиву.
- {{jsxref("Array.prototype.includes()")}}
  - : Визначає, чи масив містить подане значення, повертаючи `true` чи `false` відповідно.
- {{jsxref("Array.prototype.indexOf()")}}
  - : Повертає перший (найменший) індекс елементу всередині масиву, еквівалентного аргументу, або `-1`, якщо нічого знайдено не було.
- {{jsxref("Array.prototype.join()")}}
  - : З'єднує всі елементи масиву у рядок.
- {{jsxref("Array.prototype.keys()")}}
  - : Повертає новий об'єкт типу `Array Iterator`, що містить всі ключі кожного індексу в масиві.
- {{jsxref("Array.prototype.lastIndexOf()")}}
  - : Повертає останній (найбільший) індекс елементу всередині масиву, що еквівалентний аргументу, або `-1`, якщо нічого знайдено не було.
- {{jsxref("Array.prototype.map()")}}
  - : Повертає новий масив, що містить результати виклику функції на кожному з елементів поточного масиву.
- {{jsxref("Array.prototype.pop()")}}
  - : Видаляє останній елемент масиву, і повертає його як результат.
- {{jsxref("Array.prototype.push()")}}
  - : Додає один або більше елементів в кінець масиву, і повертає нове значення властивості `length` масиву.
- {{jsxref("Array.prototype.reduce()")}}
  - : Застосовує функцію до акумулятора і кожного зі значень масиву (зліва направо) з метою скорочення його до єдиного значення.
- {{jsxref("Array.prototype.reduceRight()")}}
  - : Застосовує функцію до акумулятора і кожного зі значень масиву (справа наліво) з метою скорочення його до єдиного значення.
- {{jsxref("Array.prototype.reverse()")}}
  - : Перевертає порядок елементів масиву _на місці_. (Перший стає останнім, останній стає першим.)
- {{jsxref("Array.prototype.shift()")}}
  - : Видаляє перший елемент з масиву, і повертає його як результат.
- {{jsxref("Array.prototype.slice()")}}
  - : Витягує відрізок початкового масиву і повертає його як новий масив.
- {{jsxref("Array.prototype.some()")}}
  - : Повертає `true`, якщо принаймні один елемент цього масиву задовільняє передану перевіркову функцію.
- {{jsxref("Array.prototype.sort()")}}
  - : Сортує елементи масиву _на місці_, і повертає сам масив.
- {{jsxref("Array.prototype.splice()")}}
  - : Додає та/чи видаляє елементи з масиву.
- {{jsxref("Array.prototype.toLocaleString()")}}
  - : Повертає локалізований рядок, що зображає масив і його елементи. Перевизначає метод {{jsxref("Object.prototype.toLocaleString()")}}.
- {{jsxref("Array.prototype.toString()")}}
  - : Повертає рядок, що зображає масив і його елементи. Перевизначає метод {{jsxref("Object.prototype.toString()")}}.
- {{jsxref("Array.prototype.unshift()")}}
  - : Додає один або більше елементів на початку масиву, і повертає нове значення довжини `length` масиву.
- {{jsxref("Array.prototype.values()")}}
  - : Повертає новий об'єкт типу `Array Iterator`, що містить всі значення за кожним індексом у масиві.
- {{jsxref("Array.prototype.@@iterator()", "Array.prototype[@@iterator]()")}}
  - : Повертає новий об'єкт типу `Array Iterator`, що містить всі значення за кожним індексом у масиві.

## Приклади

### Створення масиву

Наступний приклад створює масив `msgArray` довжиною `0`, а потім присвоює значення за індексами `msgArray[0]` та `msgArray[99]`, змінюючи таким чином довжину `length` масиву до `100`.

```js
let msgArray = []
msgArray[0] = 'Hello'
msgArray[99] = 'world'

if (msgArray.length === 100) {
  console.log('The length is 100.')
}
```

### Створення двовимірного масиву

Наступний приклад створює шахову дошку, використовуючи двовимірний масив рядків. Перший хід зроблено шляхом копіювання значення `'p'` з `board[6][4]` у `board[4][4]`. Попередня позиція `[6][4]` очищена.

```js
let board = [
  ['R','N','B','Q','K','B','N','R'],
  ['P','P','P','P','P','P','P','P'],
  [' ',' ',' ',' ',' ',' ',' ',' '],
  [' ',' ',' ',' ',' ',' ',' ',' '],
  [' ',' ',' ',' ',' ',' ',' ',' '],
  [' ',' ',' ',' ',' ',' ',' ',' '],
  ['p','p','p','p','p','p','p','p'],
  ['r','n','b','q','k','b','n','r'] ]

console.log(board.join('\n') + '\n\n')

// Перемістити королівського пішака на 2 клітинки вперед
board[4][4] = board[6][4]
board[6][4] = ' '
console.log(board.join('\n'))
```

Результат виконання:

```plain
R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , ,
 , , , , , , ,
 , , , , , , ,
 , , , , , , ,
p,p,p,p,p,p,p,p
r,n,b,q,k,b,n,r

R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , ,
 , , , , , , ,
 , , , ,p, , ,
 , , , , , , ,
p,p,p,p, ,p,p,p
r,n,b,q,k,b,n,r
```

### Оформлення набору значень у таблицю із використанням масиву

```js
values = []
for (let x = 0; x < 10; x++){
 values.push([
  2 ** x,
  2 * x ** 2
 ])
}
console.table(values)
```

Дає наступний результат

```plain
// Перша колонка значень - це індекс
0	1	0
1	2	2
2	4	8
3	8	18
4	16	32
5	32	50
6	64	72
7	128	98
8	256	128
9	512	162
```

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

## Дивіться також

- З настанов із JavaScript:

  - [“Індексування властивостей обʼєкту”](/uk/docs/Web/JavaScript/Guide/Working_with_Objects#indexing_object_properties)
  - [“Індексовані колекції: об'єкт `Array`”](/uk/docs/Web/JavaScript/Guide/Indexed_collections#array_object)

- [Типізовані масиви](/uk/docs/Web/JavaScript/Typed_arrays)
- [RangeError: invalid array length](/uk/docs/Web/JavaScript/Reference/Errors/Invalid_array_length)
