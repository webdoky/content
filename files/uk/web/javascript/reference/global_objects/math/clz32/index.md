---
title: Math.clz32()
slug: Web/JavaScript/Reference/Global_Objects/Math/clz32
page-type: javascript-static-method
browser-compat: javascript.builtins.Math.clz32
---

{{JSRef}}

Статичний метод **`Math.clz32()`** повертає кількість старших нульових бітів 32-бітного бінарного представлення переданого числа.

{{EmbedInteractiveExample("pages/js/math-clz32.html")}}

## Синтаксис

```js-nolint
Math.clz32(x)
```

### Параметри

- `x`
  - : Число.

### Повернене значення

Кількість старших нульових бітів 32-бітного бінарного представлення `x`.

## Опис

`clz32` – це скорочення від **C**ount**L**eading**Z**eros**32** ("порахувати старші нулі для 32-розрядного значення").

Якщо `x` — не число, то його буде спочатку перетворено на число, а потім переведено у 32-бітне беззнакове ціле число.

Якщо перетворене 32-бітне беззнакове ціле число дорівнює `0`, то повертається 32, адже тоді всі біти дорівнюють `0`. Якщо найстарший біт – `1` (тобто число більше або дорівнює 2<sup>31</sup>), то повертається `0`.

Ця функція здебільшого корисна в системах, які компілюються у JS, зокрема – [Emscripten](https://emscripten.org).

## Приклади

### Застосування Math.clz32()

```js
Math.clz32(1); // 31
Math.clz32(1000); // 22
Math.clz32(); // 32
const stuff = [
  NaN,
  Infinity,
  -Infinity,
  0,
  -0,
  false,
  null,
  undefined,
  "foo",
  {},
  [],
];
stuff.every((n) => Math.clz32(n) === 32); // true
Math.clz32(true); // 31
Math.clz32(3.5); // 30
```

### Реалізація підрахунку старших одиниць, й не тільки

Наразі не існує статичного методу `Math.clon` – "Count Leading Ones" ("порахувати старші одиниці") (його звуть "clon", а не "clo", адже назва "clo" та "clz" – занадто схожі, особливо для неангломовних). Проте функцію `clon` можна легко створити, обернувши біти числа й передавши результат `Math.clz32`. Це спрацює, тому що значення, обернене до 1, – це 0, і навпаки. Отже, обернення всіх бітів оберне вимірювану кількість нулів (за допомогою `Math.clz32`), таким чином, змусивши `Math.clz32` підрахувати число одиниць замість підрахунку числа нулів.

Припустімо, є таке 32-бітне слово:

```js
const a = 32776; // 00000000000000001000000000001000 (16 старших нулів)
Math.clz32(a); // 16

const b = ~32776; // 11111111111111110111111111110111 (обернене 32776, 0 старших нулів)
Math.clz32(b); // 0 (цей результат дорівнює кількості старших одиниць у числі a)
```

Використавши цю логіку, можна створити функцію `clon`, як показано нижче:

```js
const clz = Math.clz32;

function clon(integer) {
  return clz(~integer);
}
```

Далі цей підхід можна розширити, створивши функцію "Count Trailing Zeros", так, як це показано нижче. Функція `ctrz` бере бітову кон'юнкцію між цілим числом та доповненням його двійки. Щодо того, як працює доповнення двійки, то всі молодші нулі перетворюються на одиниці, а коли потім додається 1, то вона переноситься до наймолодшого `0` (котрий у вихідному значенні був `1`). Усі біти, старші за цей, залишаються такими ж і є оберненнями бітів вихідного числа. Таким чином, коли виконується бітова кон'юнкція з вихідним числом, то всі старші біти стають `0`, що підраховується `clz`. Число молодших нулів, плюс перший біт `1`, плюс старші біти, що були підраховані `clz`, сумарно дають 32.

```js
function ctrz(integer) {
  integer >>>= 0; // звести до Uint32
  if (integer === 0) {
    // пропуск цього кроку змусив би функцію повернути -1
    return 32;
  }
  integer &= -integer; // рівносильно `int = int & (~int + 1)`
  return 31 - clz(integer);
}
```

Тож функцію "порахувати молодші одиниці" можна означити так:

```js
function ctron(integer) {
  return ctrz(~integer);
}
```

Такі допоміжні функції можна оформити в модуль [asm.js](/uk/docs/Games/Tools/asm.js) – для потенційного покращення швидкодії.

```js
const countTrailsMethods = (function (stdlib, foreign, heap) {
  "use asm";
  const clz = stdlib.Math.clz32;
  // підрахувати молодші нулі
  function ctrz(integer) {
    integer = integer | 0; // звести до цілого числа
    if ((integer | 0) == 0) {
      // пропуск цього кроку змусив би функцію повернути -1
      return 32;
    }
    // Примітка: asm.js не має складених операторів присвоєння штибу &=
    integer = integer & -integer; // equivalent to `int = int & (~int + 1)`
    return (31 - clz(integer)) | 0;
  }
  // підрахувати молодші одиниці
  function ctron(integer) {
    integer = integer | 0; // звести до цілого числа
    return ctrz(~integer) | 0;
  }
  // asm.js вимагає простих об'єктів:
  return { ctrz: ctrz, ctron: ctron };
})(window, null, null);
const { ctrz, ctron } = countTrailsMethods;
```

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

## Дивіться також

- [Поліфіл `Math.clz32` у складі `core-js`](https://github.com/zloirock/core-js#ecmascript-math)
- {{jsxref("Math")}}
- {{jsxref("Math.imul")}}
