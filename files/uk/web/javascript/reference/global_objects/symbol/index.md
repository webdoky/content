---
title: Symbol
slug: Web/JavaScript/Reference/Global_Objects/Symbol
page-type: javascript-class
browser-compat: javascript.builtins.Symbol
---

{{JSRef}}

**`Symbol`** (символ) – це вбудований об'єкт, чий конструктор повертає [примітив](/uk/docs/Glossary/Primitive) `symbol` – котрий також звуть **символьним значенням** або просто **символом**, і котрий гарантовано є унікальним. Символи нерідко використовуються для додання до об'єкта унікальних ключів властивостей, котрі не конфліктуватимуть з жодними ключами, які може додати до цього об'єкта якийсь інший код, і котрі приховані від будь-яких механізмів, за допомогою яких інший корд здебільшого буде звертатися до цього об'єкта. Таким чином доступна певного роду слабка {{Glossary("encapsulation", "інкапсуляція")}}, або ж слабка форма [приховування інформації](https://en.wikipedia.org/wiki/Information_hiding).

Кожний виклик `Symbol()` гарантовано повертає унікальний символ. Кожний виклик `Symbol.for("key")` повертає той самий символ для того самого значення `"key"`. Коли викликається `Symbol.for("key")`, то якщо символ з переданим ключем може бути знайдений у глобальному реєстрі символів — цей символ повертається. Інакше – створюється і додається до глобального реєстру символів за переданим ключем новий символ, після чого – повертається.

## Опис

Для створення нового примітивного символу слід написати `Symbol()` з необов'язковим рядком як його описом:

```js
const sym1 = Symbol();
const sym2 = Symbol("foo");
const sym3 = Symbol("foo");
```

Код вище створює три нові символи. Зверніть увагу, що `Symbol("foo")` не зводить рядок `"foo"` до символу. Він щораз створює новий символ:

```js
Symbol("foo") === Symbol("foo"); // false
```

Наступний код, з оператором {{jsxref("Operators/new", "new")}}, викине {{jsxref("TypeError")}}:

```js example-bad
const sym = new Symbol(); // TypeError
```

Це не дає розробникам створювати замість нових символьних значень явні об'єкти-обгортки `Symbol`, але може здивувати, адже загалом створення явних об'єктів-обгорток навколо примітивних типів даних – можливо (наприклад, `new Boolean`, `new String` і `new Number`).

Коли справді треба створити об'єкт-обгортку `Symbol`, для цього можна використати функцію `Object()`:

```js
const sym = Symbol("foo");
typeof sym; // "symbol"
const symObj = Object(sym);
typeof symObj; // "object"
```

Через те, що символи – єдиний примітивний тип даних, що має ідентичність за посиланням (тобто не можна створити той самий символ двічі), вони у певному розумінні поводяться як об'єкти. Наприклад, щодо них працює збирач сміття, а тому вони можуть зберігатися в об'єктах {{jsxref("WeakMap")}}, {{jsxref("WeakSet")}}, {{jsxref("WeakRef")}} і {{jsxref("FinalizationRegistry")}}.

### Спільні символи у глобальному реєстрі символів

Код вище, застосовуючи функцію `Symbol()`, створює символ, чиє значення залишається унікальним протягом всього часу роботи програми. Для створення символів, доступних у різних файлах і навіть різних царинах (кожна з яких має власну глобальну область видимості), слід застосовувати методи {{jsxref("Symbol.for()")}} і {{jsxref("Symbol.keyFor()")}} – для задання та отримання символів з глобального реєстру символів.

Зверніть увагу, що "глобальний реєстр символів" є лише уявною концепцією, котра може не відповідати жодній внутрішній структурі даних рушія JavaScript – і навіть коли такий реєстр існує, його вміст недоступний кодові на JavaScript ніяким іншим чином, окрім методів `for()` і `keyFor()`.

Метод `Symbol.for(tokenString)` приймає рядковий ключ і повертає символьне значення з реєстру, а `Symbol.keyFor(symbolValue)` приймає символьне значення і повертає рядковий ключ, котрий цьому значенню відповідає. Ці методи є взаємно оберненими, тож код нижче дає `true`:

```js
Symbol.keyFor(Symbol.for("tokenString")) === "tokenString"; // true
```

Через те, що реєстрові символи можуть бути створені будь-де, вони поводяться майже точно так само, як рядки, котрі вони обгортають. Тому такі символи не гарантовано унікальні та не підлягають збиранню сміття. Унаслідок цього реєстрові символи заборонені в об'єктах {{jsxref("WeakMap")}}, {{jsxref("WeakSet")}}, {{jsxref("WeakRef")}} і {{jsxref("FinalizationRegistry")}}.

### Загальновідомі символи

Усі статичні властивості конструктора `Symbol` самі є символами, чиї значення – сталі для всіх царин. Вони відомі як _загальновідомі символи_, і їхнє призначення – служити "протоколами" для певних вбудованих операцій JavaScript, даючи користувачам змогу налаштувати поведінку мови. Наприклад, якщо функція-конструктор має метод з іменем {{jsxref("Symbol.hasInstance")}}, то такий метод міститиме логіку для оператора {{jsxref("Operators/instanceof", "instanceof")}}.

До появи загальновідомих символів JavaScript, для реалізації певних вбудованих операцій, використовував звичайні властивості. Наприклад, функція [`JSON.stringify`](/uk/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) намагається викликати на кожному об'єкті метод `toJSON()`, а функція [`String`](/uk/docs/Web/JavaScript/Reference/Global_Objects/String/String) викликає на об'єкті методи `toString()` і `valueOf()`. Проте, із доданням до мови більшої кількості операцій, виділення кожній з них "магічної властивості" могло зламати зворотну сумісність й ускладнити роботу з логікою мови. Загальновідомі символи дають кастомізаціям змогу бути "невидимими" для звичайного коду, котрий зазвичай зчитує лише рядкові властивості.

На MDN та інших джерелах загальновідомі символьні значення стилізовані за допомогою префікса `@@`. Наприклад, {{jsxref("Symbol.hasInstance")}} записується як `@@hasInstance`. Це тому, що символи не мають фактичних літеральних форматів, а використання `Symbol.hasInstance` не відображає можливість використання інших псевдонімів для посилання на той самий символ. Це схоже на різницю між `Function.name` та `"Function"`.

Загальновідомі символи не мають концепції збирання збирачем сміття, тому що вони входять до фіксованого набору і є унікальними протягом усього життя програми, подібно до вбудованих об'єктів, як то `Array.prototype`, тож вони також дозволені в об'єктах {{jsxref("WeakMap")}}, {{jsxref("WeakSet")}}, {{jsxref("WeakRef")}} і {{jsxref("FinalizationRegistry")}}.

### Пошук на об'єктах символьних властивостей

Метод {{jsxref("Object.getOwnPropertySymbols()")}} повертає масив символів і дає змогу знайти на переданому об'єкті символьні властивості. Зверніть увагу, що кожний об'єкт ініціалізується без власних символьних властивостей, тож цей об'єкт буде порожнім, якщо не задати на об'єкті якісь символьні властивості.

## Конструктор

- {{jsxref("Symbol/Symbol", "Symbol()")}}
  - : Створює новий об'єкт `Symbol`. Це не конструктор в традиційному розумінні, тому що він може бути викликаний лише як функція, але не конструюватися за допомогою `new Symbol()`.

## Статичні властивості

Статичними властивостями є загальновідомі символи. У описах цих символів ми використовуємо вирази виду "`Symbol.hasInstance` – це метод, що визначає…", але майте на увазі, що такі вирази – звертання до семантики методу об'єкта, що містить цей символ як назву свого методу (тому що загальновідомі символи діють як "протоколи"), а не опис значення самого символу.

- {{jsxref("Symbol.asyncIterator")}}
  - : Метод, що повертає усталений AsyncIterator об'єкта. Використовується циклом [`for await...of`](/uk/docs/Web/JavaScript/Reference/Statements/for-await...of).
- {{jsxref("Symbol.hasInstance")}}
  - : Метод, що визначає те, чи впізнає об'єкт-конструктор певний об'єкт як свій примірник. Використовується оператором {{jsxref("Operators/instanceof", "instanceof")}}.
- {{jsxref("Symbol.isConcatSpreadable")}}
  - : Булеве значення, котре вказує на те, чи сплющується об'єкт до своїх елементів масиву. Використовується {{jsxref("Array.prototype.concat()")}}.
- {{jsxref("Symbol.iterator")}}
  - : Метод, що повертає усталений ітератор об'єкта. Використовується циклом [`for...of`](/uk/docs/Web/JavaScript/Reference/Statements/for...of).
- {{jsxref("Symbol.match")}}
  - : Метод, що виконує зіставлення з рядком, а також використовується для з'ясування того, чи може об'єкт вживатися як регулярний вираз. Використовується методом {{jsxref("String.prototype.match()")}}.
- {{jsxref("Symbol.matchAll")}}
  - : Метод, котрий повертає ітератор, котрий видає збіги регулярного виразу в рядку. Використовується методом {{jsxref("String.prototype.matchAll()")}}.
- {{jsxref("Symbol.replace")}}
  - : Метод, котрий замінює підрядки збігу в рядку. Використовується методом {{jsxref("String.prototype.replace()")}}.
- {{jsxref("Symbol.search")}}
  - : Метод, котрий повертає індекс всередині рядка, який дає збіг з регулярним виразом. Використовується методом {{jsxref("String.prototype.search()")}}.
- {{jsxref("Symbol.species")}}
  - : Функція-конструктор, котра використовується для створення похідних об'єктів.
- {{jsxref("Symbol.split")}}
  - : Метод, котрий розбиває рядок за індексами, що дають збіг з регулярним виразом. Використовується методом {{jsxref("String.prototype.split()")}}.
- {{jsxref("Symbol.toPrimitive")}}
  - : Метод, котрий перетворює об'єкт на примітивне значення.
- {{jsxref("Symbol.toStringTag")}}
  - : Рядкове значення, котре використовується як усталений опис об'єкта. Використовується методом {{jsxref("Object.prototype.toString()")}}.
- {{jsxref("Symbol.unscopables")}}
  - : Об'єктне значення, чиї власні й успадковані імена властивостей виключаються зі зв'язувань середовища інструкції [`with`](/uk/docs/Web/JavaScript/Reference/Statements/with) для асоційованого об'єкта.

## Статичні методи

- {{jsxref("Symbol.for()")}}
  - : Шукає наявні символи з переданим ключем `key` і повертає, якщо знайдено. Інакше – в глобальному реєстрі символів створюється новий символ із заданим ключем `key`.
- {{jsxref("Symbol.keyFor()")}}
  - : Дістає зі глобального реєстру символів спільний символьний ключ для переданого символу.

## Властивості примірника

Ці властивості означені на `Symbol.prototype` і спільні для всіх примірник `Symbol`.

- {{jsxref("Object/constructor", "Symbol.prototype.constructor")}}
  - : Функція-конструктор, що створила об'єкт-примірник. Для примірників `Symbol` початковим значенням є конструктор {{jsxref("Symbol/Symbol", "Symbol")}}.
- {{jsxref("Symbol.prototype.description")}}
  - : Рядок лише для зчитування, що містить опис символу.
- `Symbol.prototype[@@toStringTag]`
  - : Початкове значення властивості [`@@toStringTag`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag) – рядок `"Symbol"`. Ця властивість використовується в методі {{jsxref("Object.prototype.toString()")}}. Проте через те, що `Symbol` має власний метод [`toString()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toString), то ця властивість не використовується, якщо не викликати [`Object.prototype.toString.call()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/call) з символьним значенням як `thisArg`.

## Методи примірника

- {{jsxref("Symbol.prototype.toString()")}}
  - : Повертає рядок, що містить опис символу. Заміщає метод {{jsxref("Object.prototype.toString()")}}.
- {{jsxref("Symbol.prototype.valueOf()")}}
  - : Повертає той же символ. Заміщає метод {{jsxref("Object.prototype.valueOf()")}}.
- [`Symbol.prototype[@@toPrimitive]()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Symbol/@@toPrimitive)
  - : Повертає той же символ.

## Приклади

### Використання з символами оператора typeof

Оператор {{jsxref("Operators/typeof", "typeof")}} може допомогти впізнати символи.

```js
typeof Symbol() === "symbol";
typeof Symbol("foo") === "symbol";
typeof Symbol.iterator === "symbol";
```

### Перетворення символьного типу

Кілька речей, котрі слід мати на увазі при перетворенні типу символів.

- При спробі перетворити символ на число – викидається {{jsxref("TypeError")}}
  (наприклад, `+sym` або `sym | 0`).
- При застосуванні нестрогої рівності, `Object(sym) == sym` повертає `true`.
- `Symbol("foo") + "bar"` викидає {{jsxref("TypeError")}} (не можна перетворювати символ на рядок). Це запобігає, наприклад, тихому створенню з символу нового рядкового імені властивості.
- ["безпечніше" перетворення `String(sym)`](/uk/docs/Web/JavaScript/Reference/Global_Objects/String#peretvorennia-riadkiv) працює як виклик {{jsxref("Symbol.prototype.toString()")}} із символами, але зверніть увагу, що `new String(sym)` викине помилку.

### Символи та ітерація for...in

Символи не перелічуються при ітерації [`for...in`](/uk/docs/Web/JavaScript/Reference/Statements/for...in). Крім цього, {{jsxref("Object.getOwnPropertyNames()")}} не поверне символьних властивостей об'єкта; проте можна застосувати {{jsxref("Object.getOwnPropertySymbols()")}} для їх отримання.

```js
const obj = {};

obj[Symbol("a")] = "a";
obj[Symbol.for("b")] = "b";
obj["c"] = "c";
obj.d = "d";

for (const i in obj) {
  console.log(i);
}
// "c" "d"
```

### Символи та JSON.stringify()

Властивості з символьними ключами геть ігноруються при використанні `JSON.stringify()`:

```js
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
```

Докладніше про це – {{jsxref("JSON.stringify()")}}.

### Об'єкти-обгортки Symbol як ключі властивостей

Коли об'єкт-обгортка Symbol використовується як ключ властивості, то такий об'єкт зводиться до загорнутого в ньому символу:

```js
const sym = Symbol("foo");
const obj = { [sym]: 1 };
obj[sym]; // 1
obj[Object(sym)]; // все одно 1
```

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

## Дивіться також

- [Поліфіл `Symbol` у складі `core-js`](https://github.com/zloirock/core-js#ecmascript-symbol)
- {{jsxref("Operators/typeof", "typeof")}}
- [Типи даних і структури даних JavaScript](/uk/docs/Web/JavaScript/Data_structures)
- [Заглиблення в ES6: Символи](https://hacks.mozilla.org/2015/06/es6-in-depth-symbols/) на hacks.mozilla.org (2015)
