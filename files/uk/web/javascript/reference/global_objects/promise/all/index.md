---
title: Promise.all()
slug: Web/JavaScript/Reference/Global_Objects/Promise/all
tags:
  - ECMAScript 2015
  - JavaScript
  - Method
  - Promise
browser-compat: javascript.builtins.Promise.all
---

{{JSRef}}

Метод **`Promise.all()`** приймає на вхід ітерований об'єкт із промісами й повертає один {{jsxref("Promise", "проміс")}}, який вирішується у масив результатів вхідних промісів. Цей повернений проміс сповнюється, коли сповнено всі вхідні проміси, або ж якщо вхідний ітерований об'єкт не містить промісів. Він відхиляється одразу в разі відхилення одного зі вхідних промісів чи викидання помилки непромісом, і відхиляється він із першим повідомленням відхилення або значенням помилки.

{{EmbedInteractiveExample("pages/js/promise-all.html")}}

## Синтаксис

```js-nolint
Promise.all(iterable)
```

### Параметри

- `iterable`
  - : [Ітерований](/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol) об'єкт, такий як {{jsxref("Array", "масив")}}.

### Повернене значення

- **Одразу сповнений** {{jsxref("Promise", "проміс")}}, якщо переданий _ітерований об'єкт_ — порожній.
- **Асинхронно сповнений** {{jsxref("Promise", "проміс")}}, якщо переданий _ітерований об'єкт_ не містить промісів. Слід зауважити, що Google Chrome 58 в цьому випадку повертає **одразу сповнений** проміс.
- **Очікуваний** {{jsxref("Promise", "проміс")}} у всіх інших випадках. Цей повернений проміс далі сповнюється чи відхиляється **асинхронно** (одразу після очищення черги), коли сповнені всі проміси в переданому _ітерованому об'єкті_, або коли будь-який з цих промісів відхиляється. Докладніше про це в частині "Асинхронність синхронності методу Promise.all" далі. Послідовність повернених значень відповідає послідовності переданих промісів, незалежно від послідовності їх виконання.

## Опис

Цей метод може бути корисним для агрегації результатів декількох промісів. Типово його застосовують в ситуації, коли є декілька пов'язаних асинхронних завдань, від яких залежить успішне виконання коду в цілому, і які повинні сповнитися всі до одного перед тим, як код продовжить виконання.

`Promise.all()` відхилиться одразу, як тільки відхилиться **будь-який** із переданих промісів. У порівнянні з ним проміс, повернений методом {{jsxref("Promise.allSettled()")}}, очікуватиме аж до завершення всіх промісів, незалежно від того, чи відхилиться якийсь із них, чи ні. Відповідно, він завжди повертатиме кінцевий результат кожного проміса і функції зі вхідного ітерованого об'єкта.

> **Примітка:** Послідовність всередині масиву промісів зберігається до завершення виконання цього методу.

### Сповнення

Повернений проміс сповнюється масивом, що містить **всі** сповнені значення (включно зі непромісними значеннями) із переданого аргументом _ітерованого об'єкта_.

- Якщо передано порожній _ітерований об'єкт_ — проміс, повернений цим методом, сповнюється синхронно. Сповнене значення є порожнім масивом.
- Якщо передано непорожній _ітерований об'єкт_, і **всі** проміси або сповнюються, або не є промісами — проміс, повернений цим методом, сповнюється асинхронно.

### Відхилення

Якщо якийсь із переданих промісів відхиляється — `Promise.all` асинхронно відхиляється зі значенням відхиленого проміса, незалежно від того, чи були залагоджені інші проміси.

## Приклади

### Застосування Promise.all

`Promise.all` очікує на всі сповнення (або першого відхилення).

```js
const p1 = Promise.resolve(3);
const p2 = 1337;
const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('foo');
  }, 100);
});

Promise.all([p1, p2, p3]).then((values) => {
  console.log(values); // [3, 1337, "foo"]
});
```

Якщо _ітерований об'єкт_ містить непромісні значення — їх буде проігноровано, проте включено до поверненого промісом масиву значень (за умови, що проміс сповнюється):

```js
// це вважається як наче переданий ітерований об'єкт — порожній, а отже він сповнюється
const p = Promise.all([1, 2, 3]);
// це вважається як наче переданий ітерований об'єкт містить лише вирішений проміс зі значенням "444", а отже він сповнюється
const p2 = Promise.all([1, 2, 3, Promise.resolve(444)]);
// це вважається як наче переданий ітерований об'єкт містить лише відхилений проміс зі значенням "555", а отже він видхиляється
const p3 = Promise.all([1, 2, 3, Promise.reject(555)]);

// застосування setTimeout дає змогу виконати код після очищення черги
setTimeout(() => {
  console.log(p);
  console.log(p2);
  console.log(p3);
});

// друкує:
// Promise { <state>: "fulfilled", <value>: Array[3] }
// Promise { <state>: "fulfilled", <value>: Array[4] }
// Promise { <state>: "rejected", <reason>: 555 }
```

### Асинхронність чи синхронність методу Promise.all

Наступний приклад демонструє асинхронність (чи синхронність, в разі якщо переданий _ітерований об'єкт_ — порожній) методу `Promise.all`:

```js
// аргументом передається масив уже вирішених промісів,
// аби запустити Promise.all якнайшвидше
const resolvedPromisesArray = [Promise.resolve(33), Promise.resolve(44)];

const p = Promise.all(resolvedPromisesArray);
// негайно друкує значення p
console.log(p);

// застосування setTimeout дає змогу виконати код після очищення черги
setTimeout(() => {
  console.log('тепер черга порожня');
  console.log(p);
});

// друкує, по порядку:
// Promise { <state>: "pending" }
// тепер черга порожня
// Promise { <state>: "fulfilled", <value>: Array[2] }
```

Аналогічна ситуація відбуватиметься, якщо `Promise.all` відхиляється:

```js
const mixedPromisesArray = [Promise.resolve(33), Promise.reject(44)];
const p = Promise.all(mixedPromisesArray);
console.log(p);
setTimeout(() => {
  console.log('тепер черга порожня');
  console.log(p);
});

// друкує
// Promise { <state>: "pending" }
// тепер черга порожня
// Promise { <state>: "rejected", <reason>: 44 }
```

Проте, `Promise.all` вирішується синхронно **лише в тому випадку, якщо** переданий _ітерований об'єкт_ — порожній:

```js
const p = Promise.all([]); // вирішується негайно
const p2 = Promise.all([1337, 'привіт']); // значення, які не є промісами — проігноруються, проте обчислення виконається асинхронно
console.log(p);
console.log(p2);
setTimeout(() => {
  console.log('тепер черга порожня');
  console.log(p2);
});

// друкує
// Promise { <state>: "fulfilled", <value>: Array[0] }
// Promise { <state>: "pending" }
// тепер черга порожня
// Promise { <state>: "fulfilled", <value>: Array[2] }
```

### Логіка швидкого провалу методу Promise.all

`Promise.all` відхиляється, якщо відхиляється один із переданих елементів. Наприклад, якщо передати до нього чотири проміси, що вирішуються після певної паузи, і один проміс, який негайно відхиляється — `Promise.all` буде одразу відхилено.

```js
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => resolve('один'), 1000);
});
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => resolve('два'), 2000);
});
const p3 = new Promise((resolve, reject) => {
  setTimeout(() => resolve('три'), 3000);
});
const p4 = new Promise((resolve, reject) => {
  setTimeout(() => resolve('чотири'), 4000);
});
const p5 = new Promise((resolve, reject) => {
  reject(new Error('відхилити'));
});

// Застосувавши .catch:
Promise.all([p1, p2, p3, p4, p5])
  .then((values) => {
    console.log(values);
  })
  .catch((error) => {
    console.error(error.message);
  });

// Із консолі:
// "reject"
```

Є можливість змінити цю поведінку, шляхом обробки можливих відхилень:

```js
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => resolve('затримане_вирішення_p1'), 1000);
});

const p2 = new Promise((resolve, reject) => {
  reject(new Error('негайне_відхилення_p2'));
});

Promise.all([
  p1.catch((error) => {
    return error;
  }),
  p2.catch((error) => {
    return error;
  }),
]).then((values) => {
  console.log(values[0]); // "затримане_вирішення_p1"
  console.error(values[1]); // "Error: негайне_відхилення_p2"
});
```

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

## Дивіться також

- {{jsxref("Promise")}}
- {{jsxref("Promise.race()")}}
