---
title: Promise
slug: Web/JavaScript/Reference/Global_Objects/Promise
tags:
  - Class
  - ECMAScript 2015
  - JavaScript
  - Promise
  - Reference
  - promise.all
  - Polyfill
browser-compat: javascript.builtins.Promise
---
{{JSRef}}

Об'єкт **`Promise`** відображає успішне (або невдале) завершення якоїсь асинхронної операції, і значення її результату.

{{AvailableInWorkers}}

Щоб взнати більше про те, як працюють проміси і як їх застосовувати, радимо спершу прочитати [застосування промісів](/uk/docs/Web/JavaScript/Guide/Using_promises).

## Опис

**`Promise`** &mdash; це заміна для значення, яке, як правило, невідоме на момент, коли проміс створюється. Він дозволяє прив'язати обробники до результату успішного виконання чи до причини невдачі асинхронної операції. Це дає можливість асинхронним методам повертати значення схоже до того, як це роблять синхронні функції. Замість повернути одразу кінцеве значення метод повертає _promise - зобов'язання_ надати це значення в якийсь момент у майбутньому.

`Promise` завжди знаходиться в одному з таких станів:

- Очікування — _pending_: початковий стан, ні виконаний, ні відхилений.
- Виконаний — _fulfilled_: означає, що операція була успішно завершена.
- Відхилений — _rejected_: означає, що операція завершилася невдало.

Проміс, який знаходиться в стані очікування, можна або _виконати_ з якимось результатом, або _відхилити_ з якоїсь причини (помилки). Коли відбувається якийсь із цих варіантів, викликаються відповідні обробники, задані методом `then` промісу. Якщо проміс уже було виконано чи відхилено на момент, коли приєднується відповідний обробник, його буде одразу викликано. Таким чином не відбувається стану гонитви між асинхронною операцією завершення і приєднанням її обробників.

Оскільки методи `{{JSxRef("Promise.then", "Promise.prototype.then()")}}` і `{{JSxRef("Promise.catch", "Promise.prototype.catch()")}}` також повертають проміси, їх можна зв'язувати у послідовність.

![](promises.png)

> **Зауваження:** Декілька інших мов також мають механізми для лінивого обчислення і відкладених обрахунків, які також називаються "promises", зокрема Scheme. Проміси в JavaScript позначають процеси, які вже відбуваються, і які можна об'єднати у послідовність з функціями зворотного виклику. Якщо вас цікавить саме ліниве обчислення значення якогось виразу, зверніть увагу на [стрілкову функцію](/uk/docs/Web/JavaScript/Reference/Functions/Arrow_functions) без аргументів: `f = () => вираз` задає вираз для лінивого обчислення, а `f()` безпосередньо обчислює його.

> **Зауваження:** Проміс вважається _settled — залагодженим_ якщо він або виконаний, або відхилений, але не в стані очікування. Також зустрічається термін _вирішений — resolved_ — це означає, що проміс або залагоджений, або “замкнений” на стан іншого промісу. Стаття [стани й долі](https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md) містить більше деталей про термінологію промісів.

### Зв'язані проміси

Методи `promise.then()`, `promise.catch()` та `promise.finally()` використовуються, щоб приєднати якусь наступну дію до промісу, який залагоджується.

Метод `.then()` приймає до двох аргументів; перший — це функція зворотного виклику для виконання промісу, а другий — відповідно, функція для його відхилення. Кожний `.then()` повертає новостворений об'єкт промісу, який далі може (необов'язково) використовуватися для нарощування послідовності викликів, як от:

```js
const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('foo');
  }, 300);
});

myPromise
  .then(handleResolvedA, handleRejectedA)
  .then(handleResolvedB, handleRejectedB)
  .then(handleResolvedC, handleRejectedC);
```

Процес продовжується до наступної ланки в послідовності, навіть якщо у наступний `.then()` не було передано функцію зворотного виклику, яка б повернула наступний проміс. Таким чином, ланцюжок може спокійно оминати кожний виклик функції _відхилення_ аж до останнього `.catch()`.

Обробка відхиленого промісу в кожному `.then()` має наслідки далі всередині послідовності промісів. Інколи просто немає вибору, оскільки помилка має бути опрацьована одразу. В такому випадку ми повинні викинути помилку якогось типу, щоб зберегти вміст помилки далі всередині послідовності. З іншого боку, в разі відсутності нагальної потреби, простіше віддати обробку помилки останній інструкції `.catch()` у ланцюжку. Фактично `.catch()` — це просто `.then()`, тільки без гнізда для функції успішного виконання промісу.

```js
myPromise
.then(handleResolvedA)
.then(handleResolvedB)
.then(handleResolvedC)
.catch(handleRejectedAny);
```

Реалізація послідовності промісів, записана із застосуванням {{JSxRef("Functions/Arrow_functions", "виразу стрілкової функції", "", 1)}} для функцій зворотного виклику, може виглядати десь так:

```js
promise1
.then(value => { return value + ' іще ланка'; })
.then(value => { return value + ' і знову ланка'; })
.then(value => { return value + ' і знову'; })
.then(value => { return value + ' і знову'; })
.then(value => { console.log(value) })
.catch(err => { console.log(err) });
```

Стан, з яким завершується проміс, визначає результат, яким "залагоджується" наступний проміс у послідовності. "Виконаний" стан позначає успішне завершення промісу, в той час, як стан "відхилено" позначає невдачу. Результат, повернутий кожним промісом у послідовності, передається далі до наступного `.then()`, тоді як причина, з якої було відхилено якийсь із промісів, передається тільки до наступного обробника помилки у послідовності.

Проміси в послідовності наче вкладені один в одного, як шари в цибулині, проте вони витягуються схоже до вершини стеку. Перший проміс у послідовності загорнутий найглибше, проте він же і буде першим, який витягнуть.

```plain
(проміс D, (проміс C, (проміс B, (проміс A) ) ) )
```

Якщо наступне значення `nextValue` — проміс, працює ефект динамічної перестановки. Інструкція `return` змушує витягнути проміс зі стека, проте на його місце одразу вкладається проміс `nextValue`. У випадку, наведеному вище, припустімо, що `.then()` пов'язаний з "промісом B" поверне "проміс X" як `nextValue`. Після цього картина вкладення буде виглядати так:

```plain
(проміс D, (проміс C, (проміс X) ) )
```

Один і той самий проміс може бути вкладений в декілька різних промісів. В прикладі нижче, перехід `promiseA` в "залагоджений" стан змусить спрацювати обидва `.then()`.

```js
const promiseA = new Promise(myExecutorFunc);
const promiseB = promiseA.then(handleFulfilled1, handleRejected1);
const promiseC = promiseA.then(handleFulfilled2, handleRejected2);
```

Можна прив'язати якусь дію до вже "залагодженого" промісу. В цьому випадку, дію (якщо це допустимо) буде виконано при першій ліпшій асинхронній можливості. Зауважте, що проміси гарантовано асинхронні. Таким чином, дія для уже "залагодженого" промісу трапиться лише після того, як стек викликів буде очищено, і пройде мить таймера рушія. Цей ефект дуже схожий до результату виконання `setTimeout(action,10)`.

```js
const promiseA = new Promise( (resolutionFunc,rejectionFunc) => {
    resolutionFunc(777);
});
// В цей момент "promiseA" уже залагоджено.
promiseA.then( (val) => console.log("асинхронний запис із таким значенням:",val) );
console.log("запис одразу");

// виводить результати в такому порядку:
// запис одразу
// асинхронний запис із таким значенням: 777
```

### Відстежування поточного установчого об'єкта

Установчий об'єкт — це [оточення](https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object), яке надає додаткову інформацію під час роботи JavaScript-коду. До нього входять область (realm), карта модулів, а також специфічна для HTML інформація, наприклад `origin`. Поточний установчий об'єкт постійно відстежується, для гарантування того, що браузер знає, який із них застосовувати для даної ділянки користувацького коду.

Щоб краще це уявити, погляньмо ближче на те, яким чином область може стати проблемою. **Область** можна приблизно вважати глобальним об'єктом. Що особливого в областях — так це те, що вони містять всю необхідну інформацію для виконання JavaScript-коду. Зокрема глобальні об'єкти, такі як [`Array`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Array) та [`Error`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Error). Кожний установчий об'єкт має свою власну "копію" цих даних. Це може призвести до певної неочікуваної поведінки під час роботи з промісами. Щоб обійти цю проблеми, ми відстежуємо таку річ, як **поточний установчий об'єкт**. Він відповідає за інформацію, яка стосується контексту користувацького коду, відповідального за виклик певної функції.

Щоб краще це проілюструвати, подивімось на те, як вбудований в документ [`<iframe>`](/uk/docs/Web/HTML/Element/iframe) спілкується зі своїм хазяїном. Оскільки всі веб-API мають на увазі поточний установчий об'єкт, наступний код буде працювати в усіх браузерах:

```html
<!DOCTYPE html>
<iframe></iframe> <!-- окрема область тут -->
<script> // і також окрема область тут
  const bound = frames[0].postMessage.bind(
    frames[0], "some data", "*");
    // bound містить вбудовану функцію, тобто тут немає
    // користувацького коду на стеку, тож яку область ми використаємо?
  window.setTimeout(bound);
  // це все ще працює, оскільки ми використовуємо молодшу
  // область (поточну) на стеку
</script>
```

Та сама ідея, але накладена на проміси. Змінимо трохи код вище, і отримаємо таке:

```html
<!DOCTYPE html>
<iframe></iframe> <!-- окрема область тут -->
<script> // і також окрема область тут
  const bound = frames[0].postMessage.bind(
    frames[0], "some data", "*");
    // bound містить вбудовану функцію, тобто тут немає
    // користувацького коду на стеку, тож яку область ми використаємо?
  Promise.resolve(undefined).then(bound);
  // це все ще працює, оскільки ми використовуємо молодшу
  // область (поточну) на стеку
</script>
```

Якщо ми змінимо це таким чином, що `<iframe>` в документі слухатиме повідомлення, ми зможемо спостерігати ефект поточного установчого об'єкта:

```html
<!-- y.html -->
<!DOCTYPE html>
<iframe src="x.html"></iframe>
<script>
  const bound = frames[0].postMessage.bind(frames[0], "some data", "*");
  Promise.resolve(undefined).then(bound);
</script>
```

```html
<!-- x.html -->
<!DOCTYPE html>
<script>
window.addEventListener("message", (event) => {
  document.querySelector("#text").textContent = "hello";
  // Цей код спрацює лише у браузерах, які відстежують поточний установчий об'єкт
  console.log(event);
}, false);
</script>
```

В прикладі, наведеному вище, текстовий вміст `<iframe>` буде оновлено лише у тому випадку, якщо поточний установчий об'єкт справді відстежується. Це тому, що без такого стеження ми можемо врешті решт відправити повідомлення через неправильне оточення.

> **Зауваження:** Наразі відстежування поточної області повністю реалізовано у Firefox, і частково виконано в Chrome і Safari.

## Конструктор

- {{jsxref("Promise/Promise", "Promise()")}}
  - : Створює новий об'єкт типу `Promise`. Здебільшого застосовується, щоб обгорнути в проміс функцію, яка ще не підтримує проміси.

## Статичні методи

- {{JSxRef("Promise.all", "Promise.all(iterable)")}}

  - : Чекає, поки всі проміси виконаються, або поки хоча б один із них буде відхилено.

    Якщо повернений в результаті виклику цього методу проміс виконується, він передає збірний масив результатів виконання всіх переданих спочатку промісів. Порядок результатів у масиві збігається з порядком початкових промісів у масиві.

    Якщо ж він завершується відхиленням, у функцію відхилення буде передано помилку з першого ж невдалого промісу в масиві.

- {{JSxRef("Promise.allSettled", "Promise.allSettled(iterable)")}}

  - : Чекає, поки всі проміси буде залагоджено (кожний може або виконатись, або відхилитись).

    Повертає проміс, який виконується після того, як всі передані в нього проміси або виконуються, або відхиляються. В цей повернений проміс передається масив об'єктів відповідно до результатів кожного з початкових промісів.

- {{JSxRef("Promise.any", "Promise.any(iterable)")}}
  - : Приймає масив об'єктів типу Promise. Як тільки хоча б один із цих промісів виконується, повертає єдиний проміс, який виконується із результатом роботи виконаного промісу з масиву.

- {{JSxRef("Promise.race", "Promise.race(iterable)")}}

  - : Чекає, поки будь-який із переданих промісів або виконується, або відхиляється.

    Якщо проміс в результаті виконується, він виконується із результатом першого промісу в наборі, який виконався.

    Якщо він відхиляється, він відхиляється з причиною з першого промісу, який завершився невдачею.

- {{JSxRef("Promise.reject", "Promise.reject(reason)")}}
  - : Повертає новий об'єкт типу `Promise`, який відхиляється з переданою причиною.
- {{JSxRef("Promise.resolve", "Promise.resolve(value)")}}

  - : Повертає новий об'єкт типу `Promise`, який виконується з переданим результатом. Якщо результат має свій метод `then`, повернений в результаті проміс "прослідкує" цей об'єкт, і прийме його кінцевий стан. Інакше цей проміс буде просто виконано з переданим значенням.

    Загалом, якщо наперед не відомо, чи результат є промісом, чи ні, краще просто викликати {{JSxRef("Promise.resolve", "Promise.resolve(value)")}} на ньому, і працювати з ним далі як з промісом.

## Методи екземпляру

Ознайомтесь із [Настановами з мікрозавдань](/uk/docs/Web/API/HTML_DOM_API/Microtask_guide "Microtask_guide"), щоб дізнатись більше про те, як ці методи працюють із чергою і сервісами мікрозавдань.

- {{jsxref("Promise.prototype.catch()")}}
  - : Додає обробник відхилення до промісу, і повертає новий проміс, який виконується або з результатом виконання переданої функції зворотного виклику, або — якщо проміс завершився успішно — результатом, з яким завершився попередній проміс.
- {{jsxref("Promise.prototype.then()")}}
  - : Додає обробники виконання і відхилення до промісу, і повертає новий проміс. Цей новий проміс або залагоджується з результатом виклику відповідного обробника, або повертає значення, з яким було залагоджено попередній проміс (в разі, якщо відповідний обробник — `onFulfilled` або `onRejected` — не є функцією).
- {{jsxref("Promise.prototype.finally()")}}
  - : Додає обробник до промісу, і повертає новий проміс, який виконується, якщо початковий проміс теж виконується. Обробник викликається, коли проміс залагоджується, незалежно від того, чи його було власне виконано, чи відхилено.

## Приклади

### Базовий приклад

```js
let myFirstPromise = new Promise((resolve, reject) => {
  // Викликаємо resolve(...), коли те, що ми робимо асинхронно, завершилося успіхом, і reject(...), якщо операція була невдалою.
  // В цьому прикладі використаємо setTimeout(...), для симуляції асинхронного коду.
  // На практиці тут буде щось схоже на XHR чи HTML5 API.
  setTimeout( function() {
    resolve("Success!")  // Ура! Все пройшло добре!
  }, 250)
})

myFirstPromise.then((successMessage) => {
  // successMessage — це будь-яке значення, яке ми передаємо в функцію resolve(...) вище.
  // Воно не зобов'язане бути рядком, проте якщо це просто повідомлення про успіх — воно ймовірно буде рядком.
  console.log("Ура! " + successMessage)
});
```

### Приклад з різноманітними ситуаціями

Цей приклад показує різноманітні техніки застосування можливостей промісів, і різні ситуації, які можуть трапитись. Для розуміння цього прикладу, прокрутіть до кінця блоку з кодом, і перегляньте послідовність промісів. Послідовність промісів слідує за заданням початкового промісу. Послідовність зібрана із викликів `.then()`, і зазвичай (проте на завжди) має єдиний `.catch()` наприкінці, за яким інколи може викликатись `.finally()`. В цьому прикладі, ланцюжок промісів ініційовано за допомогою самописного `new Promise()`, проте на практиці послідовність промісів зазвичай починається викликом функції API (написаної кимось іншим), яка повертає проміс.

Функція `tetheredGetNumber()` в прикладі зображає генератор промісу, який викличе `reject()` або під час влаштування асинхронного виклику, або всередині функції зворотного виклику, або ж і там, і там. Функція `promiseGetWord()` ілюструє, як функція API може створювати та повертати проміс автономно.

Зауважте, що функція `troubleWithGetNumber()` завершується `throw()`. Це вимушений крок, оскільки послідовність промісів в ES6 проходить через всі `.then()`, навіть після помилки. І без цього "throw()" помилка буде здаватися "виправленою". Це зайвий клопіт, і через це зазвичай опускають `rejectionFunc` у всій послідовності промісів `.then()`, і просто залишають єдину `rejectionFunc` всередині кінцевого `catch()`. Альтернативно можна викинути особливе значення (в цьому випадку "-999", проте більш правильно мати власний тип об'єкту Error).

Цей код може запускатися в середовищі NodeJS. Він буде більш зрозумілим, якщо переглянути помилки, які виникнуть у процесі виконання. Щоб збільшити кількість помилок, змініть значення `threshold`.

```js
"use strict";

// Для експерименту з обробкою помилок, значення "threshold" приводять до помилок випадковим чином
const THRESHOLD_A = 8; // можна використати 0, щоб гарантувати помилку

function tetheredGetNumber(resolve, reject) {
  try {
    setTimeout(
      function() {
        const randomInt = Date.now();
        const value = randomInt % 10;
        try {
          if(value >= THRESHOLD_A) {
            throw new Error(`Завелике значення: ${value}`);
          }
        } catch(msg) {
            reject(`Помилка в функції зворотного виклику ${msg}`);
        }
      resolve(value);
      return;
    }, 500);
    // Щоб поекспериментувати з помилкою при налаштуванні, розкоментуйте наступний 'throw'.
    // throw new Error("Пилка налаштування");
  } catch(err) {
    reject(`Помилка під час налаштування: ${err}`);
  }
  return;
}

function determineParity(value) {
  const isOdd = value % 2 ? true : false ;
  const parityInfo = { theNumber: value, isOdd: isOdd };
  return parityInfo;
}

function troubleWithGetNumber(reason) {
  console.error(`Проблема з отриманням числа: ${reason}`);
  throw -999; // необхідно викинути щось, для збереження інформації про помилку далі в послідовності
}

function promiseGetWord(parityInfo) {
  // Функція "tetheredGetWord()" отримує "parityInfo" як змінну замикання.
  const tetheredGetWord = function(resolve,reject) {
    const theNumber = parityInfo.theNumber;
    const threshold_B = THRESHOLD_A - 1;
    if(theNumber >= threshold_B) {
      reject(`Все ще завелике значення: ${theNumber}`);
    } else {
      parityInfo.wordEvenOdd = parityInfo.isOdd ? 'odd' : 'even';
      resolve(parityInfo);
    }
    return;
  }
  return new Promise(tetheredGetWord);
}

(new Promise(tetheredGetNumber))
  .then(determineParity,troubleWithGetNumber)
  .then(promiseGetWord)
  .then((info) => {
    console.log("Отримали: ",info.theNumber," , ", info.wordEvenOdd);
    return info;
  })
  .catch((reason) => {
    if(reason === -999) {
      console.error("Маємо помилку, оброблену раніше");
    }
    else {
      console.error(`Проблема з promiseGetWord(): ${reason}`);
    }
   })
  .finally((info) => console.log("Все зроблено"));
```

### Поглиблений приклад

Цей невеличкий приклад ілюструє сам механізм промісу. Метод `testPromise()` викликається під час кожного натискання елементу {{HTMLElement("button")}}. Це створює проміс, який буде виконано за допомогою {{domxref("setTimeout()")}}, зі значенням кількості промісів (число, починаючи з 1) кожні 1-3 секунди (інтервал випадковий). Для створення промісів використано конструктор `Promise()`.

Виконання промісів записується через функцію зворотного виклику, задану всередині {{JSxRef("Promise.prototype.then()","p1.then()")}}. Декілька записів, які виводяться в процесі роботи програми, показують, як синхронна частина методу відділена від асинхронного завершення промісу.

А якщо натиснути кнопку декілька разів протягом короткого проміжку часу, можна буде навіть побачити, як кілька різних промісів завершуються один за одним.

#### HTML

```html
<button id="make-promise">Створити проміс!</button>
<div id="log"></div>
```

#### JavaScript

```js
"use strict";
let promiseCount = 0;

function testPromise() {
  let thisPromiseCount = ++promiseCount;
  let log = document.getElementById('log');
  // початок
  log.insertAdjacentHTML('beforeend', thisPromiseCount + ') Started<br>');
  // Створюємо новий проміс: ми зобов'язуємося повернути числовий лічильник цього промісу, що починається з 1 (після очікування протягом 3 секунд)
  let p1 = new Promise((resolve, reject) => {
    // Функція, яка працює над виконанням промісу,
    // викликається з можливістю або виконати, або відхилити проміс
    log.insertAdjacentHTML('beforeend', thisPromiseCount + ') Конструктор промісу<br>');
    // Це лише приклад того, як може виникнути асинхронність
    window.setTimeout(function() {
        // Виконуємо проміс!
        resolve(thisPromiseCount);
    }, Math.random() * 2000 + 1000);
  });

  // Оголошуємо через виклик then(), що саме потрібно зробити, коли проміс виконується,
  // а за допомогою виклику catch() — що робити, якщо проміс відхилено
  p1.then(function(val) {
    // Записуємо значення, з яким виконався проміс
    log.insertAdjacentHTML('beforeend', val + ') Проміс виконано<br>');
  }).catch((reason) => {
    // Записуємо причину відхилення промісу
    console.log(`Тут оброблено відхилений проміс (${reason}).`);
  });
  // end
  log.insertAdjacentHTML('beforeend', thisPromiseCount + ') Проміс створено<br>');
}

if ("Promise" in window) {
  let btn = document.getElementById("make-promise");
  btn.addEventListener("click",testPromise);
} else {
  log = document.getElementById('log');
  log.textContent = "Приклад не працює, оскільки цей браузер не підтримує інтерфейс <code>Promise<code>.";
}
```

#### Результат

{{EmbedLiveSample("Advanced_Example", "500", "200")}}

### Завантаження зображення за допомогою XHR

Ще один простий приклад використання `Promise`, цього разу з завантаженням зображення за допомогою {{domxref("XMLHttpRequest")}}, доступний на GitHub-репозиторії MDN [js-examples](https://github.com/mdn/js-examples/tree/master/promises-test). Також можна [побачити його в дії](https://mdn.github.io/js-examples/promises-test/). Кожний крок прокоментовано, що дозволяє докладно пройтись по архітектурі промісів та XHR.

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

## Дивіться також

- Поліфіл для `Promise` доступний у складі [`core-js`](https://github.com/zloirock/core-js#ecmascript-promise)
- [Застосування промісів](/uk/docs/Web/JavaScript/Guide/Using_promises)
- [Специфікація Promises/A+](https://promisesaplus.com/)
- [JavaScript Promises: an introduction](https://web.dev/promises/)
- [Domenic Denicola: Callbacks, Promises, and Coroutines – Asynchronous Programming Patterns in JavaScript](https://de.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript)
