---
title: Promise
slug: Web/JavaScript/Reference/Global_Objects/Promise
tags:
  - Class
  - ECMAScript 2015
  - JavaScript
  - Promise
  - Reference
  - promise.all
  - Polyfill
browser-compat: javascript.builtins.Promise
---

{{JSRef}}

Об'єкт **`Promise`** (зобов'язання, проміс) відображає успішне (або невдале) завершення якоїсь асинхронної операції та значення її результату.

Щоб дізнатися більше про те, як працюють проміси і як їх застосовувати, краще спершу прочитати [застосування промісів](/uk/docs/Web/JavaScript/Guide/Using_promises).

## Опис

**`Promise`** – це заміна для значення, яке, як правило, невідоме на момент, коли проміс створюється. Він дає змогу прив'язати обробники до результату успішного виконання чи до причини невдачі асинхронної операції. Це дає асинхронним методам змогу повертати значення схоже до того, як це роблять синхронні функції. Замість повернути одразу кінцеве значення метод повертає _promise - зобов'язання_ надати це значення в якийсь момент у майбутньому.

`Promise` завжди знаходиться в одному з таких станів:

- Очікування — _pending_: початковий стан, ні сповнений, ні відхилений.
- Сповнений — _fulfilled_: означає, що операція була успішно завершена.
- Відхилений — _rejected_: означає, що операція завершилася невдало.

_Кінцевий стан_ промісу, який знаходиться в стані очікування, може бути або _сповнений_ якимось результатом, або _відхилений_ з якоїсь причини (через помилку).
Коли відбувається якийсь із цих варіантів, викликаються відповідні обробники, задані методом `then` промісу. Якщо проміс уже було сповнено чи відхилено на момент, коли приєднується відповідний обробник, цей обробник буде одразу викликано. Таким чином не трапляється стан гонитви між асинхронною операцією завершення і приєднанням її обробників.

Про проміс кажуть, що він _залагоджений_, якщо він або сповнився, або відхилився, але не перебуває в стані очікування.

![](promises.png)

Також можна зустріти використання з промісами терміну _вирішений_, – це означає, що проміс залагоджений або "замкнений" на відповідність кінцевому стану іншого проміса, і подальше його вирішення чи відхилення буде безрезультатним. Документ [Стани та долі (англ.)](https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md) з оригінальної пропозиції промісів містить більше деталей щодо термінології промісів. У розмовній мові "вирішені" проміси нерідко еквівалентні до "сповнених", але, як це показано в "Станах та долях", вирішені проміси також можуть очікувати чи бути відхиленими. Наприклад:

```js
new Promise((resolveOuter) => {
  resolveOuter(
    new Promise((resolveInner) => {
      setTimeout(resolveInner, 1000);
    }),
  );
});
```

Цей проміс є вже _вирішеним_ на час створення (бо `resolveOuter` викликана синхронно), але він вирішений з іншим промісом, а тому не буде _сповненим_ іще 1 секунду, поки не сповниться внутрішній проміс. На практиці "вирішення" нерідко виконується за лаштунками й не може відстежуватися, натомість сповнення й відхилення проміса – можуть.

> **Примітка:** Декілька інших мов мають механізми лінивих та відкладених обчислень, котрі теж звуться "промісами", наприклад, Scheme. Проміси в JavaScript представляють процеси, що вже відбуваються, котрі можна зв'язати в ланцюжок за допомогою функцій зворотного виклику. Якщо треба ліниво обчислити вираз, слід розглянути можливість використання функції без аргументів, наприклад, `f = () => expression`, що породжує ліниво обчислений вираз, обчислити котрий можна за допомогою `f()`.

### Ланцюжки промісів

Методи `{{jsxref("Promise.prototype.then()")}}`, `{{jsxref("Promise.prototype.catch()")}}` і `{{jsxref("Promise.prototype.finally()")}}` використовуються, щоб приєднати якусь наступну дію до промісу, який залагоджується. Оскільки методи `{{JSxRef("Promise.then", "Promise.prototype.then()")}}` та `{{JSxRef("Promise.catch", "Promise.prototype.catch()")}}` повертають проміси, їх виклики можна об'єднати в ланцюжок.

Метод `.then()` приймає до двох аргументів; перший — це функція зворотного виклику для сповнення промісу, а другий — відповідно, функція для його відхилення. Кожний `.then()` повертає новостворений об'єкт промісу, який далі може (необов'язково) використовуватися для нарощування ланцюжка викликів, як от:

```js
const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('foo');
  }, 300);
});

myPromise
  .then(handleFulfilledA, handleRejectedA)
  .then(handleFulfilledB, handleRejectedB)
  .then(handleFulfilledC, handleRejectedC);
```

Процес продовжується до наступної ланки ланцюжка, навіть якщо у наступний `.then()` не було передано функцію зворотного виклику, яка б повернула наступний проміс. Таким чином, ланцюжок може спокійно оминати кожний виклик функції _відхилення_ аж до останнього `.catch()`.

Обробка відхиленого промісу в кожному `.then()` має наслідки далі всередині ланцюжка промісів. Інколи просто немає вибору, оскільки помилка має бути опрацьована одразу. В такому випадку ми повинні викинути помилку якогось типу, щоб зберегти вміст помилки далі всередині послідовності. З іншого боку, в разі відсутності нагальної потреби простіше віддати обробку помилки останній інструкції `.catch()` у ланцюжку. Фактично `.catch()` — це просто `.then()`, тільки без гнізда для функції успішного сповнення промісу.

```js
myPromise
  .then(handleFulfilledA)
  .then(handleFulfilledB)
  .then(handleFulfilledC)
  .catch(handleRejectedAny);
```

Реалізація послідовності промісів, записана із застосуванням {{JSxRef("Functions/Arrow_functions", "виразу стрілкової функції", "", 1)}} для функцій зворотного виклику, може мати якийсь такий вигляд:

```js
myPromise
  .then((value) => {
    return value + ' іще ланка';
  })
  .then((value) => {
    return value + ' і знову ланка';
  })
  .then((value) => {
    return value + ' і знову';
  })
  .then((value) => {
    return value + ' і знову';
  })
  .then((value) => {
    console.log(value);
  })
  .catch((err) => {
    console.log(err);
  });
```

Стан, з яким завершується проміс, визначає результат, яким "залагоджується" наступний проміс у послідовності. "Сповнений" стан позначає успішне завершення промісу, а стан "відхилено" — невдачу. Результат, повернутий кожним сповненим промісом у послідовності, передається далі до наступного `.then()`, натомість причина, з якої було відхилено якийсь із промісів, передається тільки до наступного обробника помилки у послідовності.

Проміси в послідовності наче вкладені один в одного, як шари в цибулині, проте вони знімаються, подібно до верхівки стека. Перший проміс у послідовності загорнутий найглибше, проте він же і буде першим, який витягнуть.

```plain
(проміс D, (проміс C, (проміс B, (проміс A) ) ) )
```

Якщо наступне значення `nextValue` — проміс, працює ефект динамічної заміни. Інструкція `return` змушує витягнути проміс зі стека, проте на його місце одразу вкладається проміс `nextValue`. У випадку, наведеному вище, припустімо, що `.then()`, пов'язаний з "промісом B", поверне "проміс X" як `nextValue`. Після цього картина вкладення матиме такий вигляд:

```plain
(проміс D, (проміс C, (проміс X) ) )
```

Один і той самий проміс може бути вкладений в декілька різних промісів. В прикладі нижче перехід `promiseA` в "залагоджений" стан змусить спрацювати обидва `.then()`.

```js
const promiseA = new Promise(myExecutorFunc);
const promiseB = promiseA.then(handleFulfilled1, handleRejected1);
const promiseC = promiseA.then(handleFulfilled2, handleRejected2);
```

Можна прив'язати якусь дію до вже "залагодженого" промісу. В цьому випадку дію (якщо це допустимо) буде виконано при першій ліпшій асинхронній можливості. Зауважте, що проміси гарантовано асинхронні. Таким чином, дія для уже "залагодженого" промісу трапиться лише після того, як стек викликів буде очищено і мине мить таймера рушія. Цей ефект дуже схожий до результату виконання `setTimeout(action, 10)`.

```js
const promiseA = new Promise((resolutionFunc, rejectionFunc) => {
  resolutionFunc(777);
});
// В цей момент "promiseA" уже залагоджено.
promiseA.then((val) =>
  console.log('асинхронний запис із таким значенням:', val),
);
console.log('запис одразу');

// виводить результати в такому порядку:
// запис одразу
// асинхронний запис із таким значенням: 777
```

### Очікувані

Екосистема JavaScript мала декілька реалізацій промісів задовго до того, як вони стали частиною мови. Бувши всередині представленими по-різному, всі промісоподібні об'єкти щонайменше реалізовували інтерфейс _очікуваного_ (thenables). Очікуваний об'єкт реалізовує метод [`.then()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/then), котрий викликається з двома функціями зворотного виклику: одною на випадок сповнення промісу, однак на випадок відхилення. Проміси так само є очікуваними.

Щоб взаємодіяти з наявними реалізаціями Promise, мова дозволяє використання очікуваних об'єктів замість промісів. Наприклад, [`Promise.resolve`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve) вирішить не лише проміси, а й відстежить очікувані.

```js
const aThenable = {
  then(onFulfilled, onRejected) {
    onFulfilled({
      // Очікуваний сповнюється іншим очікуваним
      then(onFulfilled, onRejected) {
        onFulfilled(42);
      },
    });
  },
};
Promise.resolve(aThenable); // Проміс сповнюється значенням 42
```

### Відстежування поточного установчого об'єкта

Установчий об'єкт — це [оточення (англ.)](https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object), яке надає додаткову інформацію під час роботи JavaScript-коду. До нього входять область (realm), карта модулів, а також специфічна для HTML інформація, наприклад, `origin`. Поточний установчий об'єкт постійно відстежується для гарантування того, що браузер знає, який із них застосовувати для даної ділянки користувацького коду.

Щоб краще це уявити, погляньмо ближче на те, яким чином область може стати проблемою. **Область** можна згрубша уявляти як глобальний об'єкт. Що особливого в областях — так це те, що вони містять всю необхідну інформацію для виконання JavaScript-коду. Зокрема глобальні об'єкти, такі як [`Array`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Array) та [`Error`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Error). Кожний установчий об'єкт має свою власну "копію" цих даних. Це може призвести до певної неочікуваної поведінки під час роботи з промісами. Щоб обійти такі проблеми, ми відстежуємо таку річ, як **поточний установчий об'єкт**. Він відповідає за інформацію, яка стосується контексту користувацького коду, відповідального за виклик певної функції.

Щоб краще це проілюструвати, подивімось на те, як вбудований в документ [`<iframe>`](/uk/docs/Web/HTML/Element/iframe) спілкується зі своїм хазяїном. Оскільки всі веб-API мають на увазі поточний установчий об'єкт, наступний код буде працювати в усіх браузерах:

```html
<!DOCTYPE html>
<!-- окрема область в iframe -->
<iframe></iframe>
<script>
  // і також окрема область тут
  const bound = frames[0].postMessage.bind(frames[0], 'some data', '*');
  // bound містить вбудовану функцію, тобто тут немає
  // користувацького коду на стеку, тож яку область ми використаємо?
  window.setTimeout(bound);
  // це все ж працює, оскільки ми використовуємо наймолодшу
  // область (поточну) на стеку
</script>
```

Та сама ідея, але накладена на проміси. Змінимо трохи код вище, і отримаємо таке:

```html
<!DOCTYPE html>
<!-- окрема область в iframe -->
<iframe></iframe>
<script>
  // і також окрема область тут
  const bound = frames[0].postMessage.bind(frames[0], 'some data', '*');
  // bound містить вбудовану функцію, тобто тут немає
  // користувацького коду на стеку, тож яку область ми використаємо?
  Promise.resolve(undefined).then(bound);
  // це все ж працює, оскільки ми використовуємо наймолодшу
  // область (поточну) на стеку
</script>
```

Якщо ми змінимо це таким чином, що `<iframe>` в документі слухатиме повідомлення, ми зможемо спостерігати ефект поточного установчого об'єкта:

```html
<!-- y.html -->
<!DOCTYPE html>
<iframe src="x.html"></iframe>
<script>
  const bound = frames[0].postMessage.bind(frames[0], 'some data', '*');
  Promise.resolve(undefined).then(bound);
</script>
```

```html
<!-- x.html -->
<!DOCTYPE html>
<script>
  window.addEventListener(
    'message',
    (event) => {
      document.querySelector('#text').textContent = 'hello';
      // Цей код спрацює лише у браузерах, які відстежують поточний установчий об'єкт
      console.log(event);
    },
    false,
  );
</script>
```

У наведеному вище прикладі текстовий вміст `<iframe>` буде оновлено лише у тому випадку, якщо поточний установчий об'єкт справді відстежується. Причина цього в тому, що без такого відстеження ми можемо зрештою відправити повідомлення через неправильне оточення.

> **Примітка:** Наразі відстежування поточної області повністю реалізовано у Firefox і частково – в Chrome і Safari.

## Конструктор

- {{jsxref("Promise/Promise", "Promise()")}}
  - : Створює новий об'єкт типу `Promise`. Здебільшого застосовується, щоб обгорнути функцію, яка ще не підтримує проміси.

## Статичні методи

- {{JSxRef("Promise.all", "Promise.all(iterable)")}}

  - : Чекає, поки всі проміси сповняться, або поки хоча б один із них буде відхилено.

    Якщо повернений в результаті виклику цього методу проміс вирішується, він передає збірний масив результатів вирішення всіх переданих спочатку промісів. Порядок результатів у масиві збігається з порядком початкових промісів у масиві.

    Якщо ж він завершується відхиленням, у функцію відхилення буде передано помилку з першого ж невдалого промісу в масиві.

- {{JSxRef("Promise.allSettled", "Promise.allSettled(iterable)")}}

  - : Чекає, поки всі проміси буде залагоджено (кожний може або сповнитись, або відхилитись).

    Повертає проміс, який сповнюється після того, як всі передані в нього проміси або сповнюються, або відхиляються. В цей повернений проміс передається масив об'єктів відповідно до результатів кожного з початкових промісів.

- {{JSxRef("Promise.any", "Promise.any(iterable)")}}

  - : Приймає масив об'єктів типу Promise. Як тільки хоча б один із цих промісів сповнюється, повертає єдиний проміс, який сповнюється результатом роботи сповненого промісу з масиву.

- {{JSxRef("Promise.race", "Promise.race(iterable)")}}

  - : Чекає, поки будь-який із переданих промісів або сповнюється, або відхиляється.

    Якщо проміс в результаті сповнюється, то його значення сповнення – значення першого промісу в наборі, який сповнився.

    Якщо він відхиляється, він відхиляється з причиною з першого промісу, який був відхилений.

- {{JSxRef("Promise.reject", "Promise.reject(reason)")}}
  - : Повертає новий об'єкт типу `Promise`, який відхиляється з переданою причиною.
- {{JSxRef("Promise.resolve", "Promise.resolve(value)")}}

  - : Повертає новий об'єкт типу `Promise`, який вирішується з переданим результатом. Якщо результат є then-спроможним (має метод `then` - "відтак"), то повернений в результаті проміс "прослідкує" за цим then-спроможним і прийме його кінцевий стан. Інакше цей проміс буде просто сповнено переданим значенням.

    Загалом, якщо наперед не відомо, чи результат є промісом, чи ні, краще просто викликати {{JSxRef("Promise.resolve", "Promise.resolve(value)")}} на ньому і працювати з результатом такого виклику далі як з промісом.

## Методи примірника

Ознайомтесь із [Настановами з мікрозавдань](/uk/docs/Web/API/HTML_DOM_API/Microtask_guide), щоб дізнатись більше про те, як ці методи працюють із чергою та сервісами мікрозавдань.

- {{jsxref("Promise.prototype.catch()")}} (перехопити)
  - : Додає обробник відхилення до промісу і повертає новий проміс, який вирішується або з результатом виконання переданої функції зворотного виклику, або — якщо початковий проміс сповнився — значенням сповнення початкового проміса.
- {{jsxref("Promise.prototype.then()")}} (відтак)
  - : Додає обробники виконання і відхилення до промісу, і повертає новий проміс. Цей новий проміс або залагоджується з результатом виклику відповідного обробника, або повертає значення, з яким було залагоджено попередній проміс (в разі, якщо відповідний обробник — `onFulfilled` або `onRejected` — не є функцією).
- {{jsxref("Promise.prototype.finally()")}} (зрештою)
  - : Додає обробник до промісу і повертає новий проміс, який вирішується, якщо початковий проміс теж вирішується. Обробник викликається, коли проміс залагоджується, незалежно від того, чи його було сповнено, чи відхилено.

## Приклади

### Базовий приклад

```js
const myFirstPromise = new Promise((resolve, reject) => {
  // Викликаємо resolve(...), коли те, що ми робимо асинхронно, завершилося успіхом, і reject(...), якщо операція була невдалою.
  // В цьому прикладі використаємо setTimeout(...) для симуляції асинхронного коду.
  // На практиці тут буде щось схоже на XHR чи HTML5 API.
  setTimeout(() => {
    resolve('Успіх!'); // Ура! Все пройшло добре!
  }, 250);
});

myFirstPromise.then((successMessage) => {
  // successMessage — це будь-яке значення, яке ми передаємо в функцію resolve(...) вище.
  // Воно не зобов'язане бути рядком, проте якщо це просто повідомлення про успіх — воно, ймовірно, буде рядком.
  console.log('Ура! ' + successMessage);
});
```

### Приклад із різноманітними ситуаціями

Цей приклад показує різноманітні техніки застосування можливостей промісів і різні ситуації, які можуть трапитись. Для розуміння цього прикладу прокрутіть до кінця блоку з кодом і перегляньте ланцюжок промісів. Після початкового проміса може бути ланцюжок промісів. Він складається із викликів `.then()`, і зазвичай (проте на завжди) має єдиний `.catch()` наприкінці, після якого інколи може викликатись `.finally()`. В цьому прикладі ланцюжок промісів ініційовано за допомогою самописного `new Promise()`, проте на практиці послідовність промісів зазвичай починається викликом функції API (написаної кимось іншим), яка повертає проміс.

Функція `tetheredGetNumber()` в прикладі зображає генератор промісу, який викличе `reject()` або під час влаштування асинхронного виклику, або всередині функції зворотного виклику, або ж і там, і там. Функція `promiseGetWord()` ілюструє, як функція API може створювати та повертати проміс автономно.

Зауважте, що функція `troubleWithGetNumber()` завершується `throw()`. Це вимушений крок, оскільки послідовність промісів у ES6 проходить через всі `.then()`, навіть після помилки. І без цього "throw()" помилка буде здаватися "виправленою". Це зайвий клопіт, і через це зазвичай опускають `rejectionFunc` у всій послідовності промісів `.then()` і просто залишають єдину `rejectionFunc` всередині кінцевого `catch()`. Альтернативно можна викинути особливе значення (в цьому випадку "-999", проте більш правильно мати власний тип об'єкта Error).

Цей код може запускатися в середовищі NodeJS. Він буде більш зрозумілим, якщо переглянути помилки, які виникнуть у процесі виконання. Щоб збільшити кількість помилок, змініть значення `threshold`.

```js
'use strict';

// Для експерименту з обробкою помилок значення "threshold" приводять до помилок випадковим чином
const THRESHOLD_A = 8; // можна використати 0, щоб гарантувати помилку

function tetheredGetNumber(resolve, reject) {
  try {
    setTimeout(function () {
      const randomInt = Date.now();
      const value = randomInt % 10;
      try {
        if (value >= THRESHOLD_A) {
          throw new Error(`Завелике значення: ${value}`);
        }
      } catch (msg) {
        reject(`Помилка в функції зворотного виклику ${msg}`);
      }
      resolve(value);
      return;
    }, 500);
    // Щоб поекспериментувати з помилкою при налаштуванні, розкоментуйте наступний 'throw'.
    // throw new Error("Пилка налаштування");
  } catch (err) {
    reject(`Помилка під час налаштування: ${err}`);
  }
  return;
}

function determineParity(value) {
  const isOdd = value % 2 ? true : false;
  const parityInfo = { theNumber: value, isOdd: isOdd };
  return parityInfo;
}

function troubleWithGetNumber(reason) {
  console.error(`Проблема з отриманням числа: ${reason}`);
  throw -999; // необхідно викинути щось для збереження інформації про помилку далі в послідовності
}

function promiseGetWord(parityInfo) {
  // Функція "tetheredGetWord()" отримує "parityInfo" як змінну замикання.
  const tetheredGetWord = function (resolve, reject) {
    const theNumber = parityInfo.theNumber;
    const threshold_B = THRESHOLD_A - 1;
    if (theNumber >= threshold_B) {
      reject(`Все ж завелике значення: ${theNumber}`);
    } else {
      parityInfo.wordEvenOdd = parityInfo.isOdd ? 'odd' : 'even';
      resolve(parityInfo);
    }
    return;
  };
  return new Promise(tetheredGetWord);
}

new Promise(tetheredGetNumber)
  .then(determineParity, troubleWithGetNumber)
  .then(promiseGetWord)
  .then((info) => {
    console.log('Отримали: ', info.theNumber, ' , ', info.wordEvenOdd);
    return info;
  })
  .catch((reason) => {
    if (reason === -999) {
      console.error('Маємо помилку, оброблену раніше');
    } else {
      console.error(`Проблема з promiseGetWord(): ${reason}`);
    }
  })
  .finally((info) => console.log('Все зроблено'));
```

### Поглиблений приклад

Цей невеличкий приклад ілюструє сам механізм промісу. Метод `testPromise()` викликається під час кожного натискання елементу {{HTMLElement("button")}}. Це створює проміс, який буде виконано за допомогою {{domxref("setTimeout()")}}, зі значенням кількості промісів (число, починаючи з 1) кожні 1-3 секунди (інтервал випадковий). Для створення промісів використано конструктор `Promise()`.

Виконання промісів записується через функцію зворотного виклику, задану всередині {{JSxRef("Promise.prototype.then()","p1.then()")}}. Декілька записів, які виводяться в процесі роботи програми, показують, як синхронна частина методу відділена від асинхронного завершення промісу.

А якщо натиснути кнопку декілька разів протягом короткого проміжку часу, можна буде навіть побачити, як кілька різних промісів завершуються один за одним.

#### HTML

```html
<button id="make-promise">Створити проміс!</button>
<div id="log"></div>
```

#### JavaScript

```js
'use strict';
let promiseCount = 0;

function testPromise() {
  let thisPromiseCount = ++promiseCount;
  let log = document.getElementById('log');
  // початок
  log.insertAdjacentHTML('beforeend', thisPromiseCount + ') Started<br>');
  // Створюємо новий проміс: ми зобов'язуємося надати числовий лічильник цього промісу, що починається з 1 (після очікування протягом 3 секунд)
  let p1 = new Promise((resolve, reject) => {
    // Функція, яка працює над виконанням промісу,
    // викликається з можливістю або виконати, або відхилити проміс
    log.insertAdjacentHTML(
      'beforeend',
      thisPromiseCount + ') Конструктор промісу<br>',
    );
    // Це лише приклад того, як може виникнути асинхронність
    window.setTimeout(function () {
      // Виконуємо проміс!
      resolve(thisPromiseCount);
    }, Math.random() * 2000 + 1000);
  });

  // Оголошуємо через виклик then(), що саме потрібно зробити, коли проміс вирішується,
  // а за допомогою виклику catch() — що робити, якщо проміс відхилено
  p1.then(function (val) {
    // Виводимо значення, яким сповнився проміс
    log.insertAdjacentHTML('beforeend', val + ') Проміс сповнено<br>');
  }).catch((reason) => {
    // Виводимо причину відхилення промісу
    console.log(`Тут оброблено відхилений проміс (${reason}).`);
  });
  // кінець
  log.insertAdjacentHTML(
    'beforeend',
    thisPromiseCount + ') Проміс створено<br>',
  );
}

if ('Promise' in window) {
  let btn = document.getElementById('make-promise');
  btn.addEventListener('click', testPromise);
} else {
  log = document.getElementById('log');
  log.textContent =
    'Приклад не працює, оскільки цей браузер не підтримує інтерфейс <code>Promise<code>.';
}
```

#### Результат

{{EmbedLiveSample("pohlyblenyi-pryklad", "500", "200")}}

### Завантаження зображення за допомогою XHR

Ще один простий приклад використання `Promise`, цього разу з завантаженням зображення за допомогою {{domxref("XMLHttpRequest")}}, доступний на GitHub-репозиторії MDN [js-examples](https://github.com/mdn/js-examples/tree/master/promises-test). Також можна [побачити його в дії](https://mdn.github.io/js-examples/promises-test/). Кожний крок прокоментовано, що дає змогу докладно розглянути архітектуру промісів та XHR.

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

## Дивіться також

- [Поліфіл для `Promise` у складі `core-js`](https://github.com/zloirock/core-js#ecmascript-promise)
- [Застосування промісів](/uk/docs/Web/JavaScript/Guide/Using_promises)
- [Специфікація Promises/A+ (англ.)](https://promisesaplus.com/)
- [Promise'и JavaScript: вступ (англ.)](https://web.dev/promises/)
- [Доменік Денікола: Функції зворотного виклику, проміси та співпрограми – шаблони асинхронного програмування у JavaScript (англ.)](https://de.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript)
