---
title: String.prototype.replace()
slug: Web/JavaScript/Reference/Global_Objects/String/replace
page-type: javascript-instance-method
browser-compat: javascript.builtins.String.replace
---

{{JSRef}}

Метод **`replace()`** (замінити) примірників {{jsxref("String")}} повертає новий рядок, в якому один, деякі чи всі збіги з переданим патерном заміщені переданою заміною. Патерн може бути рядком або {{jsxref("RegExp", "регулярним виразом")}}, а заміна може бути як рядком, так і функцією, яка буде викликана для кожного збігу. Якщо патерн — рядок, то заміняється лише перший збіг. Початковий рядок залишається незмінним.

{{EmbedInteractiveExample("pages/js/string-replace.html")}}

## Синтаксис

```js-nolint
replace(pattern, replacement)
```

### Параметри

- `pattern` (патерн)
  - : Може бути рядком чи об'єктом, в котрого є метод [`Symbol.replace`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Symbol/replace): типовим прикладом такого об'єкта є [регулярний вираз](/uk/docs/Web/JavaScript/Reference/Global_Objects/RegExp). Будь-яке значення, котре не має метода `Symbol.replace`, буде приведене до рядка.
- `replacement` (заміна)
  - : Може бути рядком або функцією.
    - Якщо це рядок, то такий рядок замінить підрядок, що дав збіг з патерном. Підтримується низка особливих патернів заміни; дивіться розділ [Передача рядка як заміни](#peredacha-riadka-yak-zaminy) нижче.
    - Якщо це функція, то така функція буде викликана для кожного збігу, і повернене значення буде застосовано як текст заміни. Аргументи, що передаються такій функції, описані в розділі [Передача функції як заміни](#peredacha-funktsii-yak-zaminy) нижче.

### Повернене значення

Новий рядок, в якому один, деякі або всі збіги з патерном заміщені переданим замінником.

## Опис

Цей метод не видозмінює рядкове значення, на котрому викликаний. Він повертає новий рядок.

Рядковий патерн замінюється лише раз. Аби виконати глобальний пошук із заміною, слід застосувати регулярний вираз із позначкою `g` або використати натомість [`replaceAll()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll).

Якщо `pattern` є об'єктом із методом [`Symbol.replace`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Symbol/replace) (в т.ч. об'єктом `RegExp`), то такий метод викликається з цільовим рядком і `replacement` як аргументами. Його повернене значення стає поверненим значенням `replace()`. У такому випадку поведінка `replace()` цілком захована у методі `@@replace`: наприклад, будь-які згадки "груп захоплення" в описі нижче насправді є функціональністю, наданою [`RegExp.prototype[@@replace]`](/uk/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@replace).

Якщо `pattern` є порожнім рядком, то заміна вставляється в початок вихідного рядка.

```js
"xxx".replace("", "_"); // "_xxx"
```

Регулярний вираз із позначкою `g` є єдиним випадком, коли `replace()` виконує заміну більш ніж раз. Для отримання докладнішої інформації про те, як властивості регулярних виразів (особливо позначка [липкості](/uk/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky)) взаємодіють з `replace()` дивіться [`RegExp.prototype[@@replace]()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@replace).

### Передача рядка як заміни

Рядок для заміни може містити наступні спеціальні патерни заміни:

| Патерн    | Що вставляє                                                                                         |
| --------- | --------------------------------------------------------------------------------------------------- |
| `$$`      | Вставляє `"$"`.                                                                                     |
| `$&`      | Вставляє підрядок, що дав збіг.                                                                     |
| `` $` ``  | Вставляє частину рядка, що лежить перед підрядком, котрий дав збіг.                                 |
| `$'`      | Вставляє частину рядка, що лежить після підрядка, котрий дав збіг.                                  |
| `$n`      | Вставляє `n`-ту (з нумерацією від `1`) групу захоплення, де `n` – додатне ціле число, менше за 100. |
| `$<Name>` | Вставляє названу групу захоплення, де `Name` – ім'я групи.                                          |

`$n` і `$<Name>` доступні лише тоді, коли аргумент `pattern` є об'єктом {{jsxref("RegExp")}}. Якщо `pattern` є рядком, або ж якщо відповідна група захоплення не присутня в регулярному виразі, то патерн буде вставлений як є. Якщо група присутня, але не дала збігу (тому, що є частиною диз'юнкції), то вона буде вставлена як порожній рядок.

```js
"foo".replace(/(f)/, "$2");
// "$2oo"; регулярний вираз не має другої групи

"foo".replace("f", "$1");
// "$1oo"; патерн є рядком, тож він не має жодних груп

"foo".replace(/(f)|(g)/, "$2");
// "oo"; друга група існує, але вона не дала жодного збігу
```

### Передача функції як заміни

Другим аргументом можна також передати функцію. В цьому випадку функція викликається одразу, щойно збіг знайдено. Результат виконання функції (повернене значення) буде використано як рядок заміни.

> **Примітка:** Згадані вище особливі патерни заміни _не_ застосовуються для рядків, повернених з функції-замінювача.

Функція має наступну сигнатуру:

```js
function replacer(match, p1, p2, /* …, */ pN, offset, string, groups) {
  return replacement;
}
```

Аргументи функції такі:

- `match` (збіг)
  - : Підрядок, що дав збіг. (Відповідає `$&` вище.)
- `p1, p2, …, pN`
  - : `n`-ний рядок, знайдений групою захоплення (включно з іменованими групами захоплення), за умови що перший аргумент `replace()` є об'єктом {{jsxref("RegExp")}}. (Відповідає `$1`, `$2` тощо вище.). Наприклад, якщо `pattern` – це `/(\a+)(\b+)/`, то `p1` – збіг для `\a+`, а `p2` – збіг для `\b+`. Якщо група є частиною диз'юнкції (наприклад, `"abc".replace(/(a)|(b)/, replacer)`), то варіант, що не дав збігу, дасть `undefined`.
- `offset` (відступ)
  - : Відступ підрядка, що дав збіг, у межах всього досліджуваного рядка. Наприклад, якщо увесь рядок був `'abcd'`, а підрядок, що дав збіг, був `'bc'`, то цей аргумент буде `1`.
- `string` (рядок)
  - : Увесь досліджуваний рядок.
- `groups` (групи)
  - : Об'єкт, чиї ключі – використовувані імена груп, і чиї значення – частини, що дали збіг (`undefined`, якщо збігу немає). Присутній лише тоді, коли `pattern` містить принаймні одну іменовану групу захоплення.

Конкретне число аргументів залежить від того, чи є перший аргумент об'єктом {{jsxref("RegExp")}} – і, якщо це так – того, скільки груп захоплення він має.

Наступний приклад присвоїть `newString` значення `'abc - 12345 - #$*%'`:

```js
function replacer(match, p1, p2, p3, offset, string) {
  // p1 містить нецифрові символи, p2 — цифри, а p3 — все, окрім літер
  return [p1, p2, p3].join(" - ");
}
const newString = "abc12345#$*%".replace(/([^\d]*)(\d*)([^\w]*)/, replacer);
console.log(newString); // abc - 12345 - #$*%
```

Функція буде закликана декілька разів, для заміни кожного повного збігу, якщо регулярний вираз у першому параметрі є глобальним.

## Приклади

### Оголошення регулярного виразу безпосередньо в replace()

В наступному прикладі регулярний вираз оголошується всередині `replace()` і містить прапорець ігнорування регістру літер.

```js
const str = "То була ніч перед Йолем...";
const newstr = str.replace(/йолем/i, "Різдвом");
console.log(newstr); // То була ніч перед Різдвом...
```

Це надрукує: `'То була ніч перед Різдвом...'`.

> **Примітка:** Зверніться до [цих настанов щодо регулярних виразів](/uk/docs/Web/JavaScript/Guide/Regular_expressions) за повнішими роз'ясненнями.

### Застосування з replace() позначок "глобальна заміна" та "знехтувати регістром"

Глобальна заміна може виконуватись лише із застосуванням регулярного виразу. В наступному прикладі регулярний вираз містить [позначки "глобальний пошук" та "знехтувати регістром"](/uk/docs/Web/JavaScript/Guide/Regular_expressions/#pohlyblenyi-poshuk-z-poznachkamy), що дає функції `replace()` змогу замінити всі входження `'яблука'` на рядок з `'апельсини'`.

```js
const re = /яблука/gi;
const str = "Яблука — круглі, яблука — такі соковиті...";
const newstr = str.replace(re, "апельсини");
console.log(newstr); // апельсини — круглі, апельсини — такі соковиті...
```

Це надрукує: `'апельсини — круглі, апельсини — такі соковиті...'`.

### Обмін слів місцями в рядку

Наступний скрипт міняє слова місцями в рядку. Для отримання тексту заміни скрипт використовує [групи захоплення](/uk/docs/Web/JavaScript/Guide/Regular_expressions/Groups_and_backreferences) і патерни заміни `$1` та `$2`.

```js
const re = /(\w+)\s(\w+)/;
const str = "Іван Сірко";
const newstr = str.replace(re, "$2, $1");
console.log(newstr); // Сірко, Іван
```

Це надрукує: `'Сірко, Іван'`.

### Застосування функції, оголошеної на місці, яка змінює літери збігу

В цьому прикладі всі наявні в рядку великі літери перетворюються в літери нижнього регістру, а перед місцем збігу вставляється дефіс. Важлива деталь: перед повернення рядка як рядка заміни над ним слід провести додаткові операції.

Функція заміни приймає своїм аргументом фрагмент, що збігся, і перед тим, як повернути його, використовує його для зміни регістру і приєднання дефіса.

```js
function styleHyphenFormat(propertyName) {
  function upperToHyphenLower(match, offset, string) {
    return (offset > 0 ? "-" : "") + match.toLowerCase();
  }
  return propertyName.replace(/[A-Z]/g, upperToHyphenLower);
}
```

Для `styleHyphenFormat('borderTop')` це поверне `'border-top'`.

Оскільки в цьому випадку потрібно додатково змінити _знайдений збіг_ перед остаточною заміною, то слід вжити функцію. Це змушує програму спершу знайти збіг, тобто до виконання методу {{jsxref("String.prototype.toLowerCase()", "toLowerCase()")}}. Якщо спробувати зробити заміну без функції, то метод {{jsxref("String.prototype.toLowerCase()", "toLowerCase()")}} не матиме ефекту.

```js example-bad
// так не працює
const newString = propertyName.replace(/[A-Z]/g, "-" + "$&".toLowerCase());
```

Так відбувається через те, що `'$&'.toLowerCase()` спочатку виконується як операція над рядком (повертаючи в результаті той самий рядок `'$&'`), до того, як спеціальне значення цих символів буде використано.

### Заміна градусів за Фаренгейтом їхнім еквівалентом за шкалою Цельсія

Наступний приклад замінює градуси Фаренгейта їхнім еквівалентом в градусах Цельсія. Градуси Фаренгейта позначаються числом із літерою `"F"` в кінці. Функція повертає число градусів Цельсія зі літерою `"C"` в кінці. Наприклад, якщо вхідне число дорівнює `"212F"`, функція поверне `"100C"`. Якщо початкове число — `"0F"` – в результаті повернеться `"-17.77777777777778C"`.

Регулярний вираз `test` шукає будь-яке число, після котрого стоїть літера `F`. Доступ функції до числа градусів по шкалі Фаренгейта здійснюється через її другий аргумент `p1`. Функція встановлює число градусів Цельсія на основі градусів Фаренгейта, переданих рядком до функції `f2c()`. Після цього `f2c()` повертає число градусів Цельсія. Ця функція працює приблизно як позначка `s///e` в Perl.

```js
function f2c(x) {
  function convert(str, p1, offset, s) {
    return `${((p1 - 32) * 5) / 9}C`;
  }
  const s = String(x);
  const test = /(-?\d+(?:\.\d*)?)F\b/g;
  return s.replace(test, convert);
}
```

### Створення узагальненого замінювача

Припустімо, що необхідно створити замінювач, що додає дані про відступ до кожного рядка, котрий дав збіг. У зв'язку з тим, що функція-замінювач отримує параметр `offset`, це буде тривіальним, якщо регулярний вираз статично відомий.

```js
"abcd".replace(/(bc)/, (match, p1, offset) => `${match} (${offset}) `);
// "abc (1) d"
```

Проте такий замінювач буде важко узагальнити, якщо він повинен працювати з будь-яким патерном регулярного виразу. Замінювач є _варіативним_: число аргументів, котре він отримує, залежить від числа присутніх груп захоплення. Можна застосувати [решту параметрів](/uk/docs/Web/JavaScript/Reference/Functions/rest_parameters), але вона так само захопить у масив `offset`, `string` тощо. Факт того, що `groups` може бути або не бути переданим, залежно від ідентичності регулярного виразу, також ускладнює узагальнене з'ясування того, котрий з аргументів відповідає параметрові `offset`.

```js example-bad
function addOffset(match, ...args) {
  const offset = args.at(-2);
  return `${match} (${offset}) `;
}
console.log("abcd".replace(/(bc)/, addOffset)); // "abc (1) d"
console.log("abcd".replace(/(?<group>bc)/, addOffset)); // "abc (abcd) d"
```

Приклад `addOffset` вище не спрацює, коли регулярний вираз містить іменовану групу, тому що в такому випадку `args.at(-2)` буде `string`, а не `offset`.

Замість цього необхідно дістати останні кілька аргументів на основі типу, адже `groups` є об'єктом, а `string` – рядком.

```js
function addOffset(match, ...args) {
  const hasNamedGroups = typeof args.at(-1) === "object";
  const offset = hasNamedGroups ? args.at(-3) : args.at(-2);
  return `${match} (${offset}) `;
}
console.log("abcd".replace(/(bc)/, addOffset)); // "abc (1) d"
console.log("abcd".replace(/(?<group>bc)/, addOffset)); // "abc (1) d"
```

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

## Дивіться також

- [Поліфіл `String.prototype.replace` у складі `core-js`, з виправленнями й реалізацією сучасної логіки, як то підтримки `Symbol.replace`](https://github.com/zloirock/core-js#ecmascript-string-and-regexp)
- {{jsxref("String.prototype.replaceAll", "String.prototype.replaceAll()")}}
- {{jsxref("String.prototype.match", "String.prototype.match()")}}
- {{jsxref("RegExp.prototype.exec", "RegExp.prototype.exec()")}}
- {{jsxref("RegExp.prototype.test", "RegExp.prototype.test()")}}
- [`Symbol.replace`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Symbol/replace)
- [`RegExp.prototype[@@replace]()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@replace)
