---
title: String.prototype.indexOf()
slug: Web/JavaScript/Reference/Global_Objects/String/indexOf
tags:
  - JavaScript
  - Method
  - Prototype
  - Reference
  - String
browser-compat: javascript.builtins.String.indexOf
---
{{JSRef}}

Метод **`indexOf()`** повертає індекс першого збігу з шуканим значенням всередині об'єкта {{jsxref("String")}}, на якому цей метод було викликано. Пошук починається з позиції, переданої в параметрі `fromIndex`. Повертає `-1`, якщо шукане значення не знайшлося.

{{EmbedInteractiveExample("pages/js/string-indexof.html")}}

> **Примітка:** Інформація про однойменний метод масиву знаходиться за посиланням {{jsxref("Array.prototype.indexOf()")}}.

## Синтаксис

```js
indexOf(searchValue)
indexOf(searchValue, fromIndex)
```

### Параметри

- `searchValue`

  - : Шукане рядкове значення.

    Якщо явно не було передано ніякого рядка, [_searchValue_ буде зведено до значення "`undefined`"](https://tc39.github.io/ecma262/#sec-tostring), і далі використано для пошуку в рядку `str`.

    Таким чином, вираз `'undefined'.indexOf()` поверне `0`, оскільки `undefined` справді знаходиться в рядку `undefined` на позиції `0`. Однак, `'undefine'.indexOf()` поверне `-1`, адже `undefined` не можна знайти в рядку `undefine`.

- _`fromIndex`_ {{optional_inline}}

  - : Ціле число, яке позначає індекс символу, з якого почнеться пошук. Усталено дорівнює `0`.

    Для значень _`fromIndex`_ менших за `0`, або більших за `str.length`, пошук починається за індексом `0` та рівним `str.length` відповідно.

    Наприклад, `'привіт, світе'.indexOf('і', -5)` поверне `4`, оскільки фактично пошук починається з позиції `0`, а `і` знаходиться на позиції `4`. З іншого боку, `'привіт, світе'.indexOf('і', 13)` (та й узагалі з будь-яким значенням `fromIndex`, більшим за `13`) поверне `-1`, адже пошук починається з позиції `13`, тобто з позиції _після_ кінця рядка.

### Повернене значення

Індекс першої появи значення `searchValue` у рядку, або **`-1`**, якщо шукане значення не знайшлось.

Порожній рядок, переданий аргументом `searchValue`, видає дивні результати. Без вказаного `fromIndex`, або з будь-яким значенням `fromIndex`, меншим за довжину рядка, повернене значення буде таким самим, як і значення `fromIndex`:

```js
'привіт, світе'.indexOf('') // повертає 0
'привіт, світе'.indexOf('', 0) // повертає 0
'привіт, світе'.indexOf('', 3) // повертає 3
'привіт, світе'.indexOf('', 8) // повертає 8
```

Однак, з будь-яким значенням `fromIndex`, яке більше або дорівнює довжині рядка, повернене значення _дорівнює_ довжині рядка:

```js
'привіт, світе'.indexOf('', 13) // повертає 13
'привіт, світе'.indexOf('', 15) // повертає 13
'привіт, світе'.indexOf('', 22) // повертає 13
```

В першому прикладі складається враження, що JS знаходить порожній рядок одразу після переданого значення індексу. В останньому прикладі здається, що JS знаходить порожній рядок наприкінці рядка, в якому ведеться пошук.

## Опис

Індекси символів у рядку нумеруються зліва направо. Індекс першого символу дорівнює `0`, а індекс останнього символу в рядку під назвою `stringName` дорівнюватиме значенню виразу `stringName.length - 1`.

```js
'Синій Кит'.indexOf('Синій')      // повертає  0
'Синій Кит'.indexOf('Ситній')     // повертає -1
'Синій Кит'.indexOf('Кит', 0)     // повертає  6
'Синій Кит'.indexOf('Кит', 6)     // повертає  6
'Синій Кит'.indexOf('Кит', 7)     // повертає -1
'Синій Кит'.indexOf('')           // повертає  0
'Синій Кит'.indexOf('', 8)        // повертає  8
'Синій Кит'.indexOf('', 9)        // повертає 9
'Синій Кит'.indexOf('', 10)       // повертає 9
```

Метод `indexOf()` — чутливий до регістру. Наприклад, наступний вираз поверне `-1`:

```js
'Синій Кит'.indexOf('синій')  // повертає -1
```

### Перевірка збігів

Слід зауважити, що `0` не обчислюється до `true`, як і `-1` — до `false`. Тому, під час перевірки, чи міститься якийсь конкретний рядок всередині іншого рядка, правильний спосіб її виконати виглядатиме так:

```js
'Синій Кит'.indexOf('Синій') !== -1  // true
'Синій Кит'.indexOf('Синній') !== -1  // false
```

## Приклади

### Застосування методу `indexOf()`

Наступний приклад використовує `indexOf()` для визначення розташування значень у рядку `"Прекрасний новий світ"`.

```js
const str = 'Прекрасний новий світ'

console.log('Перша "н" від початку рядка знаходиться за індексом ' + str.indexOf('н'))   // виводить 7
console.log('"новий" знаходиться за індексом ' + str.indexOf('новий'))   // виводить 11
```

### Метод `indexOf()` і чутливість до регістру

Наступний приклад оголошує дві рядкові змінні.

Змінні мають ідентичний вміст, за винятком того, що другий рядок також містить літери верхнього регістру. Перший виклик методу {{domxref("console.log()")}} покаже `20`. Але оскільки метод `indexOf()` чутливий до регістру, рядок "`чеддер`" не знайдеться у `myCapString`, тож другий виклик `console.log()` виведе `-1`.

```js
const myString    = 'брі, перцевий джек, чеддер'
const myCapString = 'Брі, Перцевий Джек, Чеддер'

console.log('myString.indexOf("чеддер") дорівнює ' + myString.indexOf('чеддер'))
// друкує 20
console.log('myCapString.indexOf("чеддер") дорівнює ' + myCapString.indexOf('чеддер'))
// друкує -1
```

### Застосування `indexOf()` для обрахунку кількості появ певної літери у рядку

Наступний приклад встановлює кількість `count` появ літер `т` у рядку `str`:

```js
const str = 'Чи бути, чи не бути — ось питання.'
let count = 0
let position = str.indexOf('т')

while (position !== -1) {
  count++
  position = str.indexOf('т', position + 1)
}

console.log(count)  // виводить 3
```

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

## Дивіться також

- {{jsxref("String.prototype.charAt()")}}
- {{jsxref("String.prototype.lastIndexOf()")}}
- {{jsxref("String.prototype.includes()")}}
- {{jsxref("String.prototype.split()")}}
- {{jsxref("Array.prototype.indexOf()")}}
