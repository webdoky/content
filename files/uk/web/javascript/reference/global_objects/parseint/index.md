---
title: parseInt()
slug: Web/JavaScript/Reference/Global_Objects/parseInt
tags:
  - JavaScript
  - Method
  - Reference
  - parseInt
browser-compat: javascript.builtins.parseInt
---

{{jsSidebar("Objects")}}

Функція **`parseInt()`** (розібрати ціле число) розбирає рядковий аргумент і повертає ціле число за вказаною основою [системи числення](https://uk.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%BD%D1%8F).

{{EmbedInteractiveExample("pages/js/globalprops-parseint.html")}}

## Синтаксис

```js
parseInt(string);
parseInt(string, radix);
```

### Параметри

- `string` (рядок)
  - : Рядок, що починається з цілого числа. {{glossary("whitespace", "Пробіли")}} на початку цього аргументу ігноруються.
- `radix` (основа системи числення) {{optional_inline}}

  - : Ціле число між `2` та `36`, що представляє
    _основу системи числення_ `string`. Якщо лежить поза цими межами, то функція поверне `NaN`. Якщо дорівнює `0` або не задане, то основа буде виведена на основі значення `string`. Будьте уважні: усталеним значенням НЕ завжди є `10`! [Опис нижче](#opys) більш детально пояснює, що відбувається, коли не надано `radix`.

### Повернене значення

Ціле число, розібране з наданого рядка.

Або {{jsxref("NaN")}}, коли

- остача від ділення `radix` на `2**32` менша `2` чи більша `36`, або
- перший непробільний символ не може бути перетворений на число.

> **Примітка:** JavaScript не розрізняє "числа з рухомою комою" та "цілі числа" на рівні мови. `parseInt()` і [`parseFloat()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/parseFloat) відрізняються лише в логіці розбору, але не обов'язково повертають різні значення. Наприклад, `parseInt("42")` та `parseFloat("42")` повернуть одне й те ж значення: {{jsxref("Number")}} 42.

## Опис

Функція `parseInt` перетворює свій перший аргумент на рядок, розбирає цей рядок, а потім повертає ціле число або `NaN`.

Якщо не `NaN`, то повернене значення буде цілим числом, взятим як число за вказаною основою числення. (Наприклад, основа числення `10` розбирає десяткові числа, `8` – вісімкові, `16` – шістнадцяткові, і так далі.)

Значення, передане як аргумент `radix`, {{glossary("Type_coercion", "приводиться")}} до `Number` (якщо це необхідно). Якщо цей аргумент не наданий, або якщо його значенням стає 0, `NaN` чи `Infinity` (`undefined` приводиться до `NaN`), JavaScript робить наступні припущення:

1. Якщо `string`, не рахуючи пробілів та можливих знаків `+` і `-` на початку, починається з `0x` чи `0X` (нуля, після якого стоїть X у нижньому чи верхньому регістрі), то `radix` приймається за `16`, і решта рядка розбирається як шістнадцяткове число.
2. Якщо `string` починається з будь-якого іншого значення, основа приймається за `10` (десяткова система).

> **Примітка:** Інші префікси, наприклад, `0b`, що є дійсними в числових літералах, `parseInt()` не підтримуються.
> Інакше, якщо значення основи (за потреби приведене) не лежить в діапазоні \[2, 36] (включно), то `parseInt` повертає `NaN`.

Для основ, більших за `10`, цифрами після `9` є літери англійського алфавіту. Наприклад, для шістнадцяткових чисел (основа `16`) використовуються літери від `A` до `F`. Регістр літер ролі не грає.

`parseInt` розуміє виключно два знаки: `+` для додатних чисел і `-` для від'ємних (починаючи з ECMAScript 1). Розбір знаку виконується як перший крок після усування пробілів. Якщо знаків не знайдено, то алгоритм переходить до наступного кроку; інакше – прибирає знаки та виконує розбір числа в решті рядка. Наприклад, хоч рядок `1e3` технічно кодує ціле число (і буде коректно розібраний [`parseFloat()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/parseFloat) як ціле число `1000`), `parseInt("1e3", 10)` поверне `1`, тому що `e` не є дійсною цифрою при основі числення 10. Через те, що `.` також не є цифрою, повернене значення завжди буде цілим числом.

Якщо перший символ не може бути перетворений на число у використовуваній системі числення, то `parseInt` повертає `NaN`. Пробіли на початку рядка – дозволені.

Для арифметичних потреб значення `NaN` не вважається числом жодної системи числення. Щоб визначити, чи є результатом `parseInt` `NaN`, можна викликати функцію [`Number.isNaN`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN). Якщо `NaN` передати до арифметичних операцій, то результатом операції також буде `NaN`.

Через те, що великі числа використовують символ `e` у своєму рядковому представленні (наприклад, **`6.022E23`** для 6.022 × 10<sup>23</sup>), використання `parseInt` для обрізання чисел продукуватиме неочікувані результати при використанні на дуже великих чи дуже малих числах. `parseInt` _не слід_ використовувати як заміну {{jsxref("Math.floor()")}}.

Щоб перетворити число на його рядковий літерал у певній системі числення, слід використовувати `thatNumber.toString(radix)`.

> **Застереження:** `parseInt` перетворює {{jsxref("BigInt")}} на {{jsxref("Number")}} із втратою точності. Так відбувається через те, що нецифрові значення в кінці, включно з "`n`", відкидаються.

### Вісімкові інтерпретації без основи числення

Будь ласка, зверніть увагу, що на 2021 рік наступна інформація не стосується нещодавніх реалізацій.

Хоч це не рекомендував стандарт ECMAScript 3, чимало реалізацій ECMAScript 3 інтерпретували цифровий рядок, що починався з `0`, як вісімковий. Наступний код міг би видати вісімковий результат, а міг і десятковий

```js
parseInt('0e0'); // 0
parseInt('08'); // 0, тому що '8' не є вісімковою цифрою.
```

Специфікація функції `parseInt` стандарту ECMAScript 5 більше не дозволяє реалізацій, що вважають рядки, котрі починаються з символу `0`, вісімковими значеннями. Чимало реалізацій на 2021 рік вже прийняли таку поведінку.

```js
parseInt('0e0'); // 0
parseInt('08'); // 8
```

### Більш строга функція розбору

Іноді корисно мати більш строгу функцію розбору цілих чисел.

Тут допоможуть регулярні вирази:

```js
function filterInt(value) {
  if (/^[-+]?(\d+|Infinity)$/.test(value)) {
    return Number(value);
  } else {
    return NaN;
  }
}

console.log(filterInt('421')); // 421
console.log(filterInt('-421')); // -421
console.log(filterInt('+421')); // 421
console.log(filterInt('Infinity')); // Infinity
console.log(filterInt('421e+0')); // NaN
console.log(filterInt('421hop')); // NaN
console.log(filterInt('hop1.61803398875')); // NaN
console.log(filterInt('1.61803398875')); // NaN
```

## Приклади

### Використання parseInt

Усі наступні приклади повернуть `15`:

```js
parseInt('0xF', 16);
parseInt('F', 16);
parseInt('17', 8);
parseInt(021, 8);
parseInt('015', 10); // однак `parseInt('015', 8)` поверне 13
parseInt(15.99, 10);
parseInt('15,123', 10);
parseInt('FXX123', 16);
parseInt('1111', 2);
parseInt('15 * 3', 10);
parseInt('15e2', 10);
parseInt('15px', 10);
parseInt('12', 13);
```

Усі наступні приклади повернуть `NaN`:

```js
parseInt('Hello', 8); // Узагалі не число
parseInt('546', 2); // Цифри, що відмінні від 0 і 1, недійсні у двійковій системі
```

Усі наступні приклади повернуть `-15`:

```js
parseInt('-F', 16);
parseInt('-0F', 16);
parseInt('-0XF', 16);
parseInt(-15.1, 10);
parseInt('-17', 8);
parseInt('-15', 10);
parseInt('-1111', 2);
parseInt('-15e1', 10);
parseInt('-12', 13);
```

Усі наступні приклади повернуть `4`.

```js
parseInt(4.7, 10);
parseInt(4.7 * 1e22, 10); // Дуже велике число стає 4
parseInt(0.00000000000434, 10); // Дуже мале число стає 4
```

Якщо число більше за 1e+21 (включно) чи менше 1e-7 (включно), воно поверне `1`. (При використанні десяткової системи).

```js
parseInt(0.0000001, 10);
parseInt(0.000000123, 10);
parseInt(1e-7, 10);
parseInt(1000000000000000000000, 10);
parseInt(123000000000000000000000, 10);
parseInt(1e21, 10);
```

Наступний приклад поверне `224`:

```js
parseInt('0e0', 16);
```

Значення {{jsxref("BigInt")}} втрачають точність:

```js
parseInt('900719925474099267n');
// 900719925474099300
```

`parseInt` не працює з [цифровим розділювачем](/uk/docs/Web/JavaScript/Reference/Lexical_grammar#tsyfrovi-rozdiliuvachi):

```js
parseInt('123_456');
// 123
```

Основа числення приводиться до `Number`:

```js
const obj = {
  valueOf() {
    return 8;
  },
};
parseInt('11', obj); // 9

obj.valueOf = function () {
  return 1;
};
parseInt('11', obj); // NaN

obj.valueOf = function () {
  return Infinity;
};
parseInt('11', obj); // 11
```

### Використання parseInt() на нерядкових значеннях

`parseInt()` може дати цікаві результати при комбінації нерядкових значень та великої основи числення, наприклад, `36` (що робить усі літерно-цифрові символи чинними цифрами).

```js
parseInt(null, 36); // 1112745: Рядок "null" – це 1112745 за основою 36
parseInt(undefined, 36); // 86464843759093: Рядок "undefined" – це 86464843759093 за основою 36
```

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

## Дивіться також

- {{jsxref("Global_Objects/parseFloat", "parseFloat()")}}
- {{jsxref("Number.parseFloat()")}}
- {{jsxref("Number.parseInt()")}}
- {{jsxref("Global_Objects/isNaN", "isNaN()")}}
- {{jsxref("Number.toString()")}}
- {{jsxref("Object.valueOf")}}
