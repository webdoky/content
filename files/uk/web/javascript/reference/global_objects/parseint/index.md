---
title: parseInt()
slug: Web/JavaScript/Reference/Global_Objects/parseInt
page-type: javascript-function
tags:
  - JavaScript
  - Method
  - Reference
  - parseInt
browser-compat: javascript.builtins.parseInt
---

{{jsSidebar("Objects")}}

Функція **`parseInt()`** (розібрати ціле число) розбирає рядковий аргумент і повертає ціле число за вказаною основою [системи числення](https://uk.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%BD%D1%8F).

{{EmbedInteractiveExample("pages/js/globalprops-parseint.html")}}

## Синтаксис

```js-nolint
parseInt(string)
parseInt(string, radix)
```

### Параметри

- `string` (рядок)
  - : Рядок, що починається з цілого числа. {{Glossary("whitespace", "Пробіли")}} на початку цього аргументу ігноруються.
- `radix` (основа системи числення) {{optional_inline}}

  - : Ціле число між `2` та `36`, що представляє _основу системи числення_ `string`. Воно перетворюється на [32-бітове ціле](/uk/docs/Web/JavaScript/Reference/Global_Objects/Number#peretvorennia-chysel-fiksovanoi-shyryny); якщо після перетворення воно ненульове і лежить поза діапазоном \[2, 36], то функція поверне `NaN`. Якщо дорівнює `0` або не задане, то основа буде виведена на основі значення `string`. Будьте уважні: усталеним значенням _не_ завжди є `10`! [Опис нижче](#opys) більш детально пояснює, що відбувається, коли не надано `radix`.

### Повернене значення

Ціле число, розібране з наданого рядка, або {{jsxref("NaN")}}, коли

- `radix` як 32-бітне число менше `2` чи більше `36`, або
- перший непробільний символ не може бути перетворений на число.

> **Примітка:** JavaScript не розрізняє "числа з рухомою комою" та "цілі числа" на рівні мови. `parseInt()` і [`parseFloat()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/parseFloat) відрізняються лише в логіці розбору, але не обов'язково повертають різні значення. Наприклад, `parseInt("42")` та `parseFloat("42")` повернуть одне й те ж значення: {{jsxref("Number")}} 42.

## Опис

Функція `parseInt` [перетворює свій перший аргумент на рядок](/uk/docs/Web/JavaScript/Reference/Global_Objects/String#peretvorennia-riadkiv), розбирає цей рядок, а потім повертає ціле число або `NaN`.

Якщо не `NaN`, то повернене значення буде цілим числом, взятим як число за вказаною основою числення. (Наприклад, основа числення `10` розбирає десяткові числа, `8` – вісімкові, `16` – шістнадцяткові, і так далі.)

Аргумент `radix` [перетворюється на число](/uk/docs/Web/JavaScript/Reference/Global_Objects/Number#zvedennia-do-chysla). Якщо він не наданий, або якщо його значенням стає 0, `NaN` чи `Infinity` (`undefined` приводиться до `NaN`), JavaScript робить наступні припущення:

1. Якщо `string`, не рахуючи пробілів та можливих знаків `+` і `-` на початку, починається з `0x` чи `0X` (нуля, після якого стоїть X у нижньому чи верхньому регістрі), то `radix` приймається за `16`, і решта рядка розбирається як шістнадцяткове число.
2. Якщо `string` починається з будь-якого іншого значення, основа приймається за `10` (десяткова система).

> **Примітка:** Інші префікси, наприклад, `0b`, що є дійсними в [числових літералах](/uk/docs/Web/JavaScript/Reference/Lexical_grammar#dviikovi), обробляються `parseInt()` як звичайні цифри. `parseInt()` також _не_ обробляє рядки, що починаються з символу `0`, як вісімкові значення. Єдиний префікс, котрий бере до уваги `parseInt()`, – `0x` чи `0X` для шістнадцяткових значень; все решта за відсутності `radix` розбирається як десяткове значення.

Якщо основа числення – `16`, то `parseInt()` дозволяє (хоча не вимагає), аби рядок починався з `0x` чи `0X` після необов'язкового символу знаку (`+` або `-`).

Якщо значення основи (за потреби приведене) не лежить в діапазоні \[2, 36] (включно), то `parseInt` повертає `NaN`.

Для основ, більших за `10`, цифрами після `9` є літери англійського алфавіту. Наприклад, для шістнадцяткових чисел (основа `16`) використовуються літери від `A` до `F`. Регістр літер ролі не грає.

`parseInt` розуміє виключно два знаки: `+` для додатних чисел і `-` для від'ємних (починаючи з ECMAScript 1). Розбір знаку виконується як перший крок після усування пробілів. Якщо знаків не знайдено, то алгоритм переходить до наступного кроку; інакше – прибирає знаки та виконує розбір числа в решті рядка. Наприклад, хоч рядок `1e3` технічно кодує ціле число (і буде коректно розібраний [`parseFloat()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/parseFloat) як ціле число `1000`), `parseInt("1e3", 10)` поверне `1`, тому що `e` не є дійсною цифрою при основі числення 10. Через те, що `.` також не є цифрою, повернене значення завжди буде цілим числом.

Якщо перший символ не може бути перетворений на число у використовуваній системі числення, то `parseInt` повертає `NaN`. Пробіли на початку рядка – дозволені.

Для арифметичних потреб значення `NaN` не вважається числом жодної системи числення. Щоб визначити, чи є результатом `parseInt` `NaN`, можна викликати функцію [`Number.isNaN`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN). Якщо `NaN` передати до арифметичних операцій, то результатом операції також буде `NaN`.

Через те, що великі числа використовують символ `e` у своєму рядковому представленні (наприклад, **`6.022E23`** для 6.022 × 10<sup>23</sup>), використання `parseInt` для обрізання чисел продукуватиме неочікувані результати при використанні на дуже великих чи дуже малих числах. `parseInt` _не слід_ використовувати як заміну {{jsxref("Math.trunc()")}}.

Щоб перетворити число на його рядковий літерал у певній системі числення, слід використовувати `thatNumber.toString(radix)`.

Через те, що `parseInt()` повертає число, це число може постраждати від утрати точності, якщо представлене рядком число [лежить поза безпечним діапазоном](/uk/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger). Функція [`BigInt()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/BigInt/BigInt) підтримує точний розбір цілих чисел довільної довжини, повертаючи {{jsxref("BigInt")}}.

## Приклади

### Використання parseInt()

Усі наступні приклади повернуть `15`:

```js
parseInt("0xF", 16);
parseInt("F", 16);
parseInt("17", 8);
parseInt("015", 10); // однак `parseInt('015', 8)` поверне 13
parseInt("15,123", 10);
parseInt("FXX123", 16);
parseInt("1111", 2);
parseInt("15 * 3", 10);
parseInt("15e2", 10);
parseInt("15px", 10);
parseInt("12", 13);
```

Усі наступні приклади повернуть `NaN`:

```js
parseInt("Hello", 8); // Узагалі не число
parseInt("546", 2); // Цифри, що відмінні від 0 і 1, недійсні у двійковій системі
```

Усі наступні приклади повернуть `-15`:

```js
parseInt("-F", 16);
parseInt("-0F", 16);
parseInt("-0XF", 16);
parseInt("-17", 8);
parseInt("-15", 10);
parseInt("-1111", 2);
parseInt("-15e1", 10);
parseInt("-12", 13);
```

Наступний приклад повертає `224`:

```js
parseInt("0e0", 16);
```

`parseInt()` не обробляє значень {{jsxref("BigInt")}}. Вона зупиняється на символі `n`, розглядаючи символи перед ним як звичайне ціле число, з можливою втратою точності.

```js example-bad
parseInt("900719925474099267n");
// 900719925474099300
```

Натомість слід передати рядок у функцію [`BigInt()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/BigInt/BigInt), без символу `n` у кінці.

```js example-good
BigInt("900719925474099267");
// 900719925474099267n
```

`parseInt` не працює з [розділювачами розрядів](/uk/docs/Web/JavaScript/Reference/Lexical_grammar#rozdiliuvachi-rozriadiv):

```js example-bad
parseInt("123_456"); // 123
```

### Використання parseInt() на нерядкових значеннях

`parseInt()` може давати цікаві результати, коли опрацьовує нерядкові значення у поєднанні з високим значенням основи числення; наприклад, `36` (що робить усі абетково-цифрові символи дійсними цифрами).

```js
parseInt(null, 36); // 1112745: Рядок "null" – це 1112745 за основою 36
parseInt(undefined, 36); // 86464843759093: Рядок "undefined" – це 86464843759093 за основою 36
```

У загальному випадку, використовувати `parseInt()` до нерядкових значень – погана ідея, особливо як заміну для {{jsxref("Math.trunc()")}}. Це може працювати на малих числах:

```js
parseInt(15.99, 10); // 15
parseInt(-15.1, 10); // -15
```

Проте вийшло так, що це працює, лише через те, що рядкове представлення цих чисел використовує базовий дробовий запис (`"15.99"`, `"-15.1"`), в якому `parseInt()` зупиняється на десятковому розділювачі. Числа, більші чи рівні 1e+21, або менші чи рівні 1e-7, використовують у своєму рядковому представленні експоненційний запис (`"1.5e+22"`, `"1.51e-8"`), і `parseInt()` зупиниться на символі `e` чи десятковому роздільнику, котрий завжди стоїть після першої цифри. А отже – для великих та малих чисел `parseInt()` поверне одноцифрове ціле число:

```js example-bad
parseInt(4.7 * 1e22, 10); // Дуже велике число стає 4
parseInt(0.00000000000434, 10); // Дуже мале число стає 4
parseInt(0.0000001, 10); // 1
parseInt(0.000000123, 10); // 1
parseInt(1e-7, 10); // 1
parseInt(1000000000000000000000, 10); // 1
parseInt(123000000000000000000000, 10); // 1
parseInt(1e21, 10); // 1
```

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

## Дивіться також

- {{jsxref("Global_Objects/parseFloat", "parseFloat()")}}
- [Конструктор `Number()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Number/Number)
- {{jsxref("Number.parseFloat()")}}
- {{jsxref("Number.parseInt()")}}
- {{jsxref("Global_Objects/isNaN", "isNaN()")}}
- {{jsxref("Number.prototype.toString()")}}
- {{jsxref("Object.prototype.valueOf()")}}
- [Конструктор `BigInt()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/BigInt/BigInt)
