---
title: for...in
slug: Web/JavaScript/Reference/Statements/for...in
tags:
  - JavaScript
  - Language feature
  - Statement
browser-compat: javascript.statements.for_in
---

{{jsSidebar("Statements")}}

**Інструкція `for...in`** ("для кожного ... у") перебирає всі [перелічувані властивості](/uk/docs/Web/JavaScript/Enumerability_and_ownership_of_properties) об'єкта, ключами яких є рядки (тобто ігноруючи ті, ключами яких є [Символи](/uk/docs/Web/JavaScript/Reference/Global_Objects/Symbol)), в тому числі успадковані перелічувані властивості.

{{EmbedInteractiveExample("pages/js/statement-forin.html")}}

## Синтаксис

```js
for (const variable in object) {
  statement;
}
```

- `variable`
  - : Змінна, якій під час кожної ітерації присвоюється нове ім'я властивості.
- `object`
  - : Об'єкт, чиї перелічувані властивості з несимвольними ключами перебираються.

## Опис

Цикл опрацює всі власні перелічувані властивості об'єкта, а також ті, що успадковуються об'єктом від його прототипного ланцюжка (властивості ближчих прототипів мають перевагу над властивостями тих прототипів, які знаходяться далі від об'єкта у ланцюжку прототипів).

Цикл `for...in` перебирає лише ті перелічувані властивості, чиїм ключем не є символ. Об'єкти, які створюються за допомогою таких вбудованих конструкторів, як `Array` і `Object`, мають неперелічувані властивості, успадковані від `Array.prototype` та `Object.prototype`, як от метод {{jsxref("Array/indexOf", "indexOf()")}} об'єкта {{jsxref("Array")}} чи метод {{jsxref("Object/toString", "toString()")}} об'єкта {{jsxref("Object")}}. Такі властивості не оброблятимуться циклом `for...in`.

Порядок перебирання властивостей, згідно зі сучасною специфікацією ECMAScript — чітко визначений, і незмінний між реалізаціями. Всередині кожного компонента прототипного ланцюжка всі ключі, які є додатними цілими числами (зазвичай це індекси масивів) опрацьовуються першими, в порядку зростання числового значення. Потім опрацьовуються інші рядкові ключі, в хронологічному порядку відносно дати створення кожної властивості.

### Видалені, додані чи змінені властивості

Якщо під час однієї з ітерацій властивість змінюється, а потім опрацьовується в одній з наступних ітерацій, в циклі буде використано те значення, яке вона має на момент її опрацювання другого разу. Властивість, яку було видалено перед своєю обробкою, пізніше оброблено не буде. Властивості, які додаються до об'єкта під час перебирання його властивостей, можуть бути як оброблені пізніше, так і пропущені в циклі.

Загалом, під час ітерування краще не додавати, не змінювати й не видаляти властивості з об'єкта, окрім властивості, котра безпосередньо обробляється поточною ітерацією. Немає ніяких гарантій того, що додана властивість буде опрацьована циклом, чи буде змінена властивість оброблена до, чи після модифікації, і чи буде видалена властивість опрацьована до моменту видалення.

### Ітерування масиву і цикл for...in

Індекси масиву — це лише перелічувані властивості, які у всьому ідентичні властивостям звичайних об'єктів, окрім того, що їхні імена — це цілі числа. Цикл `for...in` обробить всі ключі, які є цілими числами, перед початком обробки інших ключів, чітко у напрямку їхнього зростання, що робить поведінку інструкції `for...in` близькою до звичайного перебирання масиву. Проте, цикл `for...in` також поверне всі перелічувані властивості, включно з успадкованими й тими, чиї ключі не є цілими числами. На відміну від `for...of`, `for...in` використовує перелічування властивостей замість ітератора масиву. У розріджених масивах `for...of` буде обробляти порожні гнізда, а `for...in` — ні.

Краще використовувати цикл {{jsxref("Statements/for", "for")}} з числовим індексом, {{jsxref("Array.prototype.forEach()")}} чи цикл {{jsxref("Statements/for...of", "for...of")}}, оскільки вони повертатимуть індекс як число, а не як рядок, а також уникатимуть властивостей поза індексом.

### Перебирання лише власних властивостей об'єкта

В разі, якщо необхідно розглянути лише ті властивості, які приєднані до самого об'єкта, без урахування його прототипів, можна застосувати один із наступних підходів:

- {{jsxref("Object.keys", "Object.keys(myObject)")}}
- {{jsxref("Object.getOwnPropertyNames", "Object.getOwnPropertyNames(myObject)")}}

`Object.keys` поверне список власних перелічуваних властивостей із рядковими ключами, а от `Object.getOwnPropertyNames` також міститиме неперелічувані властивості.

Якщо метод `Object.hasOwn()` недоступний, можна натомість використати {{jsxref("Object.prototype.hasOwnProperty", "hasOwnProperty()")}}, хоча в такому разі краще вжити форму `Object.prototype.hasOwnProperty.call(myObject, prop)` — на випадок, якщо `myObject` перезаписав успадкований метод `hasOwnProperty()`.

## Для чого взагалі слід використовувати for...in?

Багато настанов щодо стилю та лінтерів у JavaScript рекомендують не застосовувати `for...in` через те, що він перебирає весь ланцюжок прототипів, а це рідко є бажаним. Також його часто плутають із більш вживаним циклом `for...of`. В яких випадках `for...in` був би взагалі корисним?

Найбільш доцільним може бути його використання для потреб зневадження, як простого способу перевірити властивості об'єкта (шляхом виведення їх у консоль, або ж інакшим чином). І хоча масиви часто є практичнішим способом зберігання даних, в ситуаціях, коли доцільніше використовувати для роботи з даними формат ключ-значення (де імена властивостей грають роль "ключа"), можуть траплятися випадки, коли потрібно перевірити, чи якийсь із таких ключів зберігає певне значення.

## Приклади

### Застосування for...in

Цикл `for...in`, який наведено нижче, перевіряє всі перелічувані, несимвольні властивості об'єкта, і для кожної друкує рядок з іменем властивості та її значенням.

```js
const obj = { a: 1, b: 2, c: 3 };

for (const prop in obj) {
  console.log(`obj.${prop} = ${obj[prop]}`);
}

// Вивід:
// "obj.a = 1"
// "obj.b = 2"
// "obj.c = 3"
```

### Перебирання власних властивостей об'єкта

Наступна функція демонструє використання методу {{jsxref("Object.hasOwn", "Object.hasOwn()")}}: успадковані властивості не виводяться.

```js
const triangle = { a: 1, b: 2, c: 3 };

function ColoredTriangle() {
  this.color = 'red';
}

ColoredTriangle.prototype = triangle;

var obj = new ColoredTriangle();

for (const prop in obj) {
  if (Object.hasOwn(obj, prop)) {
    console.log(`obj.${prop} = ${obj[prop]}`);
  }
}

// Вивід:
// "obj.color = red"
```

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

### Сумісність: вираз ініціалізації в суворому режимі

У Firefox до версії 40 у циклі `for...in` було можливо використовувати вираз ініціалізації (`i=0`):

```js example-bad
const obj = {a: 1, b: 2, c: 3};
for (var i = 0 in obj) {
  console.log(obj[i]);
}
// 1
// 2
// 3
```

Ця нестандартна поведінка ігнорується починаючи з версії 40 і покаже помилку {{jsxref("SyntaxError")}} ("[заголовок оголошення циклу for-in не може містити вирази ініціалізації](/uk/docs/Web/JavaScript/Reference/Errors/Invalid_for-in_initializer)") в [суворому режимі](/uk/docs/Web/JavaScript/Reference/Strict_mode) (вади [748550](https://bugzilla.mozilla.org/show_bug.cgi?id=748550) і [1164741](https://bugzilla.mozilla.org/show_bug.cgi?id=1164741)).

Інші рушії, як от v8 (Chrome), Chakra (IE/Edge) і JSC (WebKit/Safari) — також у процесі визначення, чи варто видаляти цю нестандартну поведінку.

## Дивіться також

- {{jsxref("Statements/for...of", "for...of")}} – схожа інструкція, яка перебирає _значення_ властивостей
- {{jsxref("Statements/for", "for")}}
- [Функції ітераторів і генераторів](/uk/docs/Web/JavaScript/Guide/Iterators_and_Generators) (придатні для використання з синтаксисом `for...of`)
- [Перелічуваність і належність властивостей](/uk/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)
- {{jsxref("Object.getOwnPropertyNames()")}}
- {{jsxref("Object.hasOwn()")}}
- {{jsxref("Array.prototype.forEach()")}}
