---
title: for...in
slug: Web/JavaScript/Reference/Statements/for...in
page-type: javascript-statement
tags:
  - JavaScript
  - Language feature
  - Statement
browser-compat: javascript.statements.for_in
---

{{jsSidebar("Statements")}}

Інструкція **`for...in`** ("для кожного ... у") ітерує всі [перелічувані рядкові властивості](/uk/docs/Web/JavaScript/Enumerability_and_ownership_of_properties) об'єкта (ігноруючи ті, ключами яких є [символи](/uk/docs/Web/JavaScript/Reference/Global_Objects/Symbol)), в тому числі успадковані перелічувані властивості.

{{EmbedInteractiveExample("pages/js/statement-forin.html")}}

## Синтаксис

```js-nolint
for (variable in object)
  statement
```

### Параметри

- `variable`
  - : На кожній ітерації отримує ім'я рядкової властивості. Може бути або оголошенням з [`const`](/uk/docs/Web/JavaScript/Reference/Statements/const), [`let`](/uk/docs/Web/JavaScript/Reference/Statements/let) чи [`var`](/uk/docs/Web/JavaScript/Reference/Statements/var), або ціллю [присвоєння](/uk/docs/Web/JavaScript/Reference/Operators/Assignment) (наприклад, заздалегідь оголошеною змінною чи властивістю об'єкта).
- `object`
  - : Об'єкт, чиї перелічувані властивості з несимвольними ключами перебираються.
- `statement`
  - : Інструкція, що виконається на кожній ітерації. Може звертатися до `variable`. Для виконання декількох інструкцій можна використати [блокову інструкцію](/uk/docs/Web/JavaScript/Reference/Statements/block).

## Опис

Цикл опрацює всі власні перелічувані властивості об'єкта, а також ті, що успадковуються об'єктом від його прототипного ланцюжка (властивості ближчих прототипів мають перевагу над властивостями тих прототипів, які знаходяться далі від об'єкта у ланцюжку прототипів).

Цикл `for...in` перебирає лише перелічувані несимвольні властивості. Об'єкти, які створюються за допомогою таких вбудованих конструкторів, як `Array` і `Object`, мають неперелічувані властивості, успадковані від `Array.prototype` та `Object.prototype`, як от метод {{jsxref("Array/indexOf", "indexOf()")}} об'єкта {{jsxref("Array")}} чи метод {{jsxref("Object/toString", "toString()")}} об'єкта {{jsxref("Object")}}. Такі властивості не оброблятимуться циклом `for...in`.

Порядок перебирання властивостей, згідно зі сучасною специфікацією ECMAScript — чітко визначений, і незмінний між реалізаціями. Всередині кожного компонента прототипного ланцюжка всі ключі, які є додатними цілими числами (зазвичай це індекси масивів) опрацьовуються першими, в порядку зростання числового значення. Потім опрацьовуються інші рядкові ключі, в хронологічному порядку відносно дати створення кожної властивості.

Частина `for...in` `variable` приймає що завгодно, що може стояти зліва оператора `=`. Якщо не робити присвоєння змінній всередині тіла циклу, то можна для її оголошення використати {{jsxref("Statements/const", "const")}} (таке присвоєння не вплине на наступну ітерацію, адже в ній буде геть окрема змінна). Інакше – можна використати {{jsxref("Statements/let", "let")}}. Також можна застосувати [деструктурування](/uk/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) чи властивість об'єкта, як то `for (x.y in iterable)`.

[Застарілий синтаксис](/uk/docs/Web/JavaScript/Reference/Deprecated_and_obsolete_features#instruktsii) дозволяє оголошенням `var` змінної циклу мати ініціалізатор. Це викидає [синтаксичну помилку](/uk/docs/Web/JavaScript/Reference/Errors/Invalid_for-in_initializer) в строгому режимі й ігнорується в нестрогому.

### Видалені, додані чи змінені властивості

Якщо під час однієї з ітерацій властивість змінюється, а потім опрацьовується в одній з наступних ітерацій, в циклі буде використано те значення, яке вона має на момент її опрацювання другого разу. Властивість, яку було видалено перед своєю обробкою, пізніше оброблено не буде. Властивості, які додаються до об'єкта під час перебирання його властивостей, можуть бути як оброблені пізніше, так і пропущені в циклі.

Загалом, під час ітерування краще не додавати, не змінювати й не видаляти властивості з об'єкта, окрім властивості, котра безпосередньо обробляється поточною ітерацією. Немає ніяких гарантій того, що додана властивість буде опрацьована циклом, чи буде змінена властивість оброблена до, чи після модифікації, і чи буде видалена властивість опрацьована до моменту видалення.

### Ітерування масиву і цикл for...in

Індекси масиву — це лише перелічувані властивості, які у всьому ідентичні властивостям звичайних об'єктів, окрім того, що їхні імена — це цілі числа. Цикл `for...in` обробить всі ключі, які є цілими числами, перед початком обробки інших ключів, чітко у напрямку їхнього зростання, що робить поведінку інструкції `for...in` близькою до звичайного перебирання масиву. Проте, цикл `for...in` також поверне всі перелічувані властивості, включно з успадкованими й тими, чиї ключі не є цілими числами. На відміну від `for...of`, `for...in` використовує перелічування властивостей замість ітератора масиву. У [розріджених масивах](/uk/docs/Web/JavaScript/Guide/Indexed_collections#rozridzheni-masyvy) `for...of` буде обробляти порожні гнізда, а `for...in` — ні.

Краще використовувати цикл {{jsxref("Statements/for", "for")}} з числовим індексом, {{jsxref("Array.prototype.forEach()")}} чи цикл {{jsxref("Statements/for...of", "for...of")}}, оскільки вони повертатимуть індекс як число, а не як рядок, а також уникатимуть властивостей поза індексом.

### Перебирання лише власних властивостей об'єкта

В разі, якщо необхідно розглянути лише ті властивості, які приєднані до самого об'єкта, без урахування його прототипів, можна застосувати один із наступних підходів:

- {{jsxref("Object.keys", "Object.keys(myObject)")}}
- {{jsxref("Object.getOwnPropertyNames", "Object.getOwnPropertyNames(myObject)")}}

`Object.keys` поверне список власних перелічуваних властивостей із рядковими ключами, а от `Object.getOwnPropertyNames` також міститиме неперелічувані властивості.

Багато настанов щодо стилю та лінтерів у JavaScript рекомендують не застосовувати `for...in` через те, що він перебирає весь ланцюжок прототипів, а це рідко є бажаним. Також його часто плутають із більш вживаним циклом `for...of`. Найбільш доцільним може бути його використання для потреб зневадження, як простого способу перевірити властивості об'єкта (шляхом виведення їх у консоль, або ж інакшим чином). В ситуаціях, коли об'єкти використовуються як утилітарні пари ключ-значення, `for...in` дає змогу перевірити, чи зберігає якийсь з таких ключів певне значення.

## Приклади

### Застосування for...in

Цикл `for...in`, який наведено нижче, перевіряє всі перелічувані, несимвольні властивості об'єкта, і для кожної друкує рядок з іменем властивості та її значенням.

```js
const obj = { a: 1, b: 2, c: 3 };

for (const prop in obj) {
  console.log(`obj.${prop} = ${obj[prop]}`);
}

// Друкує:
// "obj.a = 1"
// "obj.b = 2"
// "obj.c = 3"
```

### Перебирання власних властивостей об'єкта

Наступна функція демонструє використання методу {{jsxref("Object.hasOwn", "Object.hasOwn()")}}: успадковані властивості не виводяться.

```js
const triangle = { a: 1, b: 2, c: 3 };

function ColoredTriangle() {
  this.color = "red";
}

ColoredTriangle.prototype = triangle;

var obj = new ColoredTriangle();

for (const prop in obj) {
  if (Object.hasOwn(obj, prop)) {
    console.log(`obj.${prop} = ${obj[prop]}`);
  }
}

// Друкує:
// "obj.color = red"
```

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

## Дивіться також

- {{jsxref("Statements/for...of", "for...of")}}
- {{jsxref("Statements/for", "for")}}
- [Перелічуваність і належність властивостей](/uk/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)
- {{jsxref("Object.getOwnPropertyNames()")}}
- {{jsxref("Object.hasOwn()")}}
- {{jsxref("Array.prototype.forEach()")}}
