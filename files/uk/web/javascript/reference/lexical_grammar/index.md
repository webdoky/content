---
title: Лексична граматика
slug: Web/JavaScript/Reference/Lexical_grammar
page-type: guide
browser-compat: javascript.grammar
---

{{JsSidebar("More")}}

Ця сторінка описує лексичну граматику JavaScript. Текст коду на JavaScript – лише послідовність символів, – аби інтерпретатор зрозумів його, рядок повинен бути _розібраний_ до більш структурованого представлення. Початковий етап розбору зветься [лексичним аналізом](https://uk.wikipedia.org/wiki/%D0%9B%D0%B5%D0%BA%D1%81%D0%B8%D1%87%D0%BD%D0%B8%D0%B9_%D0%B0%D0%BD%D0%B0%D0%BB%D1%96%D0%B7), при якому текст оглядається зліва направо й перетворюється на послідовність окремих, неподільних елементів введення. Частина елементів введення неважлива для інтерпретатора, тож може бути прибрана після цього кроку – серед них [пробіли](#probily) та [коментарі](#komentari). Решта, в тому числі [ідентифікатори](#identyfikatory), [ключові слова](#kliuchovi-slova), [літерали](#literaly) та розділові знаки (здебільшого [оператори](/uk/docs/Web/JavaScript/Reference/Operators)), використовуються при подальшому синтаксичному аналізі. [Символи кінця рядка](#symvoly-kintsia-riadka) й багаторядкові коментарі також є синтаксично неважливими, але вони допоміжні для [автоматичного вставляння крапок з комою](#avtomatychne-vstavliannia-krapok-z-komoiu), завдяки якому певні недійсні послідовності лексем стають дійсними.

## Символи контролю форматування

Символи контролю форматування не мають візуального представлення, але використовуються для контролю тлумачення тексту.

| Кодова точка | Назва                       | Абревіатура | Опис                                                                                                                                                                                                                                                                    |
| ------------ | --------------------------- | ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| U+200C       | Нез'єднувач нульової ширини | \<ZWNJ>     | Ставиться між символами, аби запобігти їх поєднанню в лігатури, в деяких мовах ([Wikipedia](https://en.wikipedia.org/wiki/Zero-width_non-joiner)).                                                                                                                      |
| U+200D       | З'єднувач нульової ширини   | \<ZWJ>      | Ставиться між символами, котрі зазвичай не з'єднуються, аби вони були візуалізовані за допомогою їхньої об'єднаної форми, в деяких мовах ([Wikipedia](https://en.wikipedia.org/wiki/Zero-width_joiner)).                                                                |
| U+FEFF       | Маркер порядку байтів       | \<BOM>      | Використовується на початку сценарію, аби позначити його як Unicode, а також порядок байтів у тексті ([Вікіпедія](https://uk.wikipedia.org/wiki/%D0%9C%D0%B0%D1%80%D0%BA%D0%B5%D1%80_%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BA%D1%83_%D0%B1%D0%B0%D0%B9%D1%82%D1%96%D0%B2)). |

У тексті коду мовою JavaScript \<ZWNJ> і \<ZWJ> обробляються як частини [ідентифікаторів](#identyfikatory), натомість \<BOM> (також відомий як безрозривний пробіл нульової ширини, \<ZWNBSP>, коли не стоїть на початку тексту) обробляється як [пробіл](#probily).

## Пробіли

[Пробільні](/uk/docs/Glossary/Whitespace) символи покращують прочитність тексту коду та відділяють лексеми одна від одної. Зазвичай ці символи не є необхідними для функціональності коду. Нерідко використовуються [інструменти з мініфікації](https://en.wikipedia.org/wiki/Minification_%28programming%29), аби прибрати пробіли для зменшення кількості даних, котру треба передавати.

| Кодова точка | Назва                                | Абревіатура | Опис                                                                                                                                                     | Послідовність екранування |
| ------------ | ------------------------------------ | ----------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------- |
| U+0009       | Табуляція символів                   | \<TAB>      | Горизонтальна табуляція                                                                                                                                  | \t                        |
| U+000B       | Табуляція рядків                     | \<VT>       | Вертикальна табуляція                                                                                                                                    | \v                        |
| U+000C       | Розрив сторінок                      | \<FF>       | Символ контролю розриву сторінок ([Wikipedia](https://en.wikipedia.org/wiki/Page_break#Form_feed)).                                                      | \f                        |
| U+0020       | Пробіл                               | \<SP>       | Звичайний пробіл                                                                                                                                         |                           |
| U+00A0       | Безрозривний пробіл                  | \<NBSP>     | Звичайний пробіл, але без точки, в якій може статися розрив рядка                                                                                        |                           |
| U+FEFF       | Безрозривний пробіл нульової довжини | \<ZWNBSP>   | Коли маркер BOM стоїть не на початку сценарію, він є звичайним пробільним символом                                                                       |                           |
| Інші         | Інші пробільні символи Unicode       | \<USP>      | [Символи загальної категорії "Space_Separator"](https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=%5Cp%7BGeneral_Category%3DSpace_Separator%7D) |                           |

> **Примітка:** Серед тих [символів, що мають властивість "White_Space", але не належать до загальної категорії "Space_Separator"](https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=%5Cp%7BWhite_Space%7D%26%5CP%7BGeneral_Category%3DSpace_Separator%7D), U+0009, U+000B і U+000C у JavaScript все одно обробляються як пробіли; U+0085 NEXT LINE не має особливої ролі; решта – стають множиною [символів кінця рядка](#symvoly-kintsia-riadka).

> **Примітка:** Зміни до стандарту Unicode, що використовується рушієм JavaScript, можуть вплинути на поведінку програм. Наприклад, ES2016 оновив посилання на стандарт Unicode від версії 5.1 до 8.0.0, що призвело до переведення символу U+180E MONGOLIAN VOWEL SEPARATOR з категорії "Space_Separator" до категорії "Format (Cf)", а також зробило його непробільним. Як наслідок, результат [`"\u180E".trim().length`](/uk/docs/Web/JavaScript/Reference/Global_Objects/String/Trim) змінився від `0` до `1`.

## Символи кінця рядка

На додачу до [пробільних](#probily) символів, символи кінця рядка використовуються для покращення прочитності тексту коду. Проте в деяких випадках вони можуть впливати на виконання коду на JavaScript, адже є кілька місць, у яких вони заборонені. Крім цього, символи кінця рядка впливають на процес [автоматичного вставляння крапок з комою](#avtomatychne-vstavliannia-krapok-z-komoiu).

Поза контекстом лексичної граматики пробіли та символи кінця рядка нерідко не розрізняються. Наприклад, {{jsxref("String.prototype.trim()")}} прибирає з початку та кінця рядка усі пробіли та символи кінця рядка. [Клас екранування символів](/uk/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes) `\s` у регулярних виразах дає збіг з усіма пробілами та символами кінця рядка.

Лише нижчеперелічені кодові точки Unicode обробляються в ECMAScript як символи кінця рядка, а всі решта символи розриву рядка розглядаються як пробіли (наприклад, Next Line, NEL, U+0085 – вважаються пробілами).

| Кодова точка | Назва               | Абревіатура | Опис                                                                                                                                                | Послідовність екранування |
| ------------ | ------------------- | ----------- | --------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------- |
| U+000A       | Символ нового рядка | \<LF>       | Символ нового рядка в системах UNIX.                                                                                                                | \n                        |
| U+000D       | Повернення каретки  | \<CR>       | Символ нового рядка у Commodore і ранніх системах Mac.                                                                                              | \r                        |
| U+2028       | Розділювач рядків   | \<LS>       | [Вікіпедія](https://uk.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB_%D0%BD%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE_%D1%80%D1%8F%D0%B4%D0%BA%D0%B0) |                           |
| U+2029       | Розділювач абзаців  | \<PS>       | [Вікіпедія](https://uk.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB_%D0%BD%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE_%D1%80%D1%8F%D0%B4%D0%BA%D0%B0) |                           |

## Коментарі

Коментарі використовуються для додавання підказок, нотаток, пропозицій чи застережень до коду JavaScript. Вони можуть робити цей код легшим для прочитання та розуміння. Вони можуть використовуватись для вимикання коду та запобігання його виконанню; це може бути цінним інструментом зневадження.

JavaScript має два традиційні способи додавання коментарів до коду: рядкові коментарі та блокові коментарі. на додачу, існує особливий синтаксис шебанг-коментарів.

### Рядкові коментарі

Перший спосіб – коментар `//`; це робить увесь текст, що стоїть далі до кінця рядка, коментарем. Наприклад:

```js
function comment() {
  // Це однорядковий коментар JavaScript
  console.log("Привіт, світе!");
}
comment();
```

### Блокові коментарі

Другий спосіб – стиль `/* */`, котрий є гнучкішим.

Наприклад, можна використати його на одному рядку:

```js
function comment() {
  /* Це однорядковий коментар JavaScript */
  console.log("Привіт, світе!");
}
comment();
```

Можна також робити багаторядкові коментарі, отак:

```js
function comment() {
  /* Цей коментар стоїть на кількох рядках. Зверніть увагу,
     що немає потреби закінчувати коментар, поки не хочеться. */
  console.log("Привіт, світе!");
}
comment();
```

Також його можна застосовувати посередині рядка, якщо є потреба, хоч це й робить код важчим для прочитання, тож так слід робити з обережністю:

```js
function comment(x) {
  console.log("Привіт, " + x /* вставлення значення x */ + " !");
}
comment("світе");
```

На додачу, це можна використовувати для вимикання коду, шляхом загортання його в коментар, отак:

```js
function comment() {
  /* console.log("Привіт, світе!"); */
}
comment();
```

У цьому випадку, виклик `console.log()` ніколи не відбудеться, адже він знаходиться всередині коментаря. Так можна вимкнути будь-яку кількість рядків коду.

Блокові коментарі, котрі містять щонайменше один символ кінця рядка, поводяться при [автоматичному вставлянні крапок з комою](#avtomatychne-vstavliannia-krapok-z-komoiu) як [символи кінця рядка](#symvoly-kintsia-riadka).

### Шебанг-коментарі

Є особливий третій синтаксис коментарів, **шебанг-коментар**. Шебанг-коментар поводиться точно так само, як однорядковий (`//`) коментар, окрім того, що він починається з `#!` і **є дійсним лише на абсолютному початку сценарію або модуля**. Зверніть увагу, що перед `#!` не може стояти жодних пробільних символів. Такий коментар складається з усіх символів після `#!` і до кінця першого рядка; дозволений лише один такий коментар.

Шебанг-коментарі в JavaScript нагадують [шебанги в Unix](<https://uk.wikipedia.org/wiki/%D0%A8%D0%B5%D0%B1%D0%B0%D0%BD%D0%B3_(Unix)>), котрі задають шлях до конкретного інтерпретатора JavaScript, котрий повинен виконати сценарій. До стандартизації шебанг-коментаря, він уже був фактично реалізований в небраузерних середовищах, як то Node.js, де його прибирали з вихідного тексту перед передачею до рушія. Приклад – наступний:

```js
#!/usr/bin/env node

console.log("Привіт, світе");
```

Інтерпретатор JavaScript розглядатиме це як звичайний коментар: він має значення лише для оболонки, якщо сценарій запускається в ній безпосередньо.

> **Застереження:** Аби мати змогу запускати сценарії в середовищі оболонки, їх слід кодувати в UTF-8 без [BOM](https://uk.wikipedia.org/wiki/%D0%9C%D0%B0%D1%80%D0%BA%D0%B5%D1%80_%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BA%D1%83_%D0%B1%D0%B0%D0%B9%D1%82%D1%96%D0%B2). Попри те, що BOM не призводить до жодних проблем для коду, що працює в браузері – бо цей символ прибирається під час розкодування UTF-8, до аналізу тексту коду – оболонка Unix чи Linux не впізнає шебанг, якщо перед ним стоятиме символ BOM.

Коментар у стилі `#!` повинен використовуватися лише для задання інтерпретатора JavaScript. У всіх інших випадках повинні використовуватись прості коментарі `//` (або ж багаторядкові).

## Ідентифікатори

_Ідентифікатор_ використовується для зв'язування значення з іменем. Ідентифікатори можуть вживатися в різних місцях:

```js
const decl = 1; // Оголошення змінних (може також бути з `let` або `var`)
function fn() {} // Оголошення функцій
const obj = { key: "value" }; // Ключі об'єктів
// Оголошення класів
class C {
  #priv = "value"; // Приватні властивості
}
lbl: console.log(1); // Підписи
```

У JavaScript ідентифікатори здебільшого складаються з алфавітно-цифрових символів, підкреслень (`_`) і знаків долара (`$`). Вони не можуть починатися з цифр. Проте ідентифікатори JavaScript не обмежені ASCII: так само дозволені чимало кодових точок Unicode. А саме, усі символи категорії [ID_Start](https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=%5Cp%7BID_Start%7D) можуть стояти на початку ідентифікатора, а всі символи категорії [ID_Continue](https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=%5Cp%7BID_Continue%7D) можуть зустрічатися після першого символу.

> **Примітка:** Якщо, з якоїсь причини, є потреба самотужки розібрати якийсь код на JavaScript, то не слід покладатися на припущення, ніби всі ідентифікатори відповідають патернові `/[A-Za-z_$][\w$]*/` (тобто лише ASCII)! Діапазон символів може бути описаний регулярним виразом `/[$_\p{ID_Start}][$\u200c\u200d\p{ID_Continue}]*/u` (окрім послідовностей екранування Unicode).

На додачу до цього, JavaScript дозволяє використання в ідентифікаторах [екрановані послідовності Unicode](#poslidovnosti-ekranuvannia-unicode), у вигляді `\u0000` або `\u{000000}`, що кодує ті самі рядкові значення, що й фактичні символи Unicode. Наприклад, `你好` і `\u4f60\u597d` – це один і той же ідентифікатор:

```js-nolint
const 你好 = "Привіт";
console.log(\u4f60\u597d); // Привіт
```

Не у всіх місцях приймається повний діапазон ідентифікаторів. Частина синтаксичних конструкцій, як то: оголошення функцій, вирази функцій та оголошення змінних — вимагають використання ідентифікаторів, що не є [зарезервованими словами](#zarezervovani-slova).

```js example-bad
function import() {} // Заборонено: import – зарезервоване слово.
```

Слід зазначити, що приватні властивості та властивості об'єктів – дозволяють зарезервовані слова.

```js
const obj = { import: "value" }; // Дозволено, попри те, що слово `import` – зарезервоване
class C {
  #import = "value";
}
```

## Ключові слова

_Ключові слова_ – лексеми, котрі на вигляд подібні до ідентифікаторів, але мають в JavaScript особливе значення. Наприклад, ключове слово [`async`](/uk/docs/Web/JavaScript/Reference/Statements/async_function) перед оголошенням функції позначає, що ця функція – асинхронна.

Частина ключових слів – _зарезервовані_, тобто їх не можна використовувати як ідентифікатори при оголошенні змінних, функцій тощо. Їх нерідко звуть _зарезервованими словами_. [Список цих зарезервованих слів](#zarezervovani-slova) – наведений нижче. Не всі ключові слова – зарезервовані: наприклад, `async` може використовуватись як ідентифікатор де завгодно. Частина ключових слів є _зарезервованими контекстно_: наприклад, `await` – зарезервоване лише всередині тіла асинхронної функції, а `let` – зарезервоване лише в коді у суворому режимі, або ж оголошеннях `const` і `let`.

Ідентифікатори завжди перевіряються за їх _рядковим значенням_, тож послідовності екранування в них – інтерпретуються. Наприклад, код нижче – все одно є синтаксичною помилкою:

```js example-bad
const els\u{65} = 1;
// `els\u{65}` кодує той самий ідентифікатор, що й `else`
```

### Зарезервовані слова

Ці ключові слова не можуть вживатися як ідентифікатори для змінних, функцій, класів тощо, будь-де в коді на JavaScript.

- {{jsxref("Statements/break", "break")}}
- {{jsxref("Statements/switch", "case")}}
- {{jsxref("Statements/try...catch", "catch")}}
- {{jsxref("Statements/class", "class")}}
- {{jsxref("Statements/const", "const")}}
- {{jsxref("Statements/continue", "continue")}}
- {{jsxref("Statements/debugger", "debugger")}}
- {{jsxref("Statements/switch", "default")}}
- {{jsxref("Operators/delete", "delete")}}
- {{jsxref("Statements/do...while", "do")}}
- {{jsxref("Statements/if...else", "else")}}
- {{jsxref("Statements/export", "export")}}
- [`extends`](/uk/docs/Web/JavaScript/Reference/Classes/extends)
- [`false`](#buliv-literal)
- {{jsxref("Statements/try...catch", "finally")}}
- {{jsxref("Statements/for", "for")}}
- {{jsxref("Statements/function", "function")}}
- {{jsxref("Statements/if...else", "if")}}
- {{jsxref("Statements/import", "import")}}
- {{jsxref("Operators/in", "in")}}
- {{jsxref("Operators/instanceof", "instanceof")}}
- {{jsxref("Operators/new", "new")}}
- {{jsxref("Operators/null", "null")}}
- {{jsxref("Statements/return", "return")}}
- {{jsxref("Operators/super", "super")}}
- {{jsxref("Statements/switch", "switch")}}
- {{jsxref("Operators/this", "this")}}
- {{jsxref("Statements/throw", "throw")}}
- [`true`](#buliv-literal)
- {{jsxref("Statements/try...catch", "try")}}
- {{jsxref("Operators/typeof", "typeof")}}
- {{jsxref("Statements/var", "var")}}
- {{jsxref("Operators/void", "void")}}
- {{jsxref("Statements/while", "while")}}
- {{jsxref("Statements/with", "with")}}

Наступні слова вважаються зарезервованими лише тоді, коли зустрічаються в коді в суворому режимі:

- {{jsxref("Statements/let", "let")}} (також зарезервоване в оголошеннях `const`, `let` і класів)
- [`static`](/uk/docs/Web/JavaScript/Reference/Classes/static)
- {{jsxref("Operators/yield", "yield")}} (також зарезервоване в тілах генераторних функцій)

Наступне слово вважається зарезервованим лише тоді, коли зустрічається в модульному коді або тілі асинхронної функції:

- [`await`](/uk/docs/Web/JavaScript/Reference/Operators/await)

### Зарезервовані на майбутнє слова

Слова нижче – зарезервовані специфікацією ECMAScript як ключові слова на майбутнє. Вони наразі не мають особливої функціональності, але можуть її мати колись у майбутньому, тож їх не можна використовувати як ідентифікатори.

Це слово – зарезервовано завжди:

- `enum`

Наступні слова зарезервовані лише тоді, коли зустрічаються в коді в суворому режимі:

- `implements`
- `interface`
- `package`
- `private`
- `protected`
- `public`

#### Зарезервовані на майбутнє слова в давніших стандартах

Слова нижче – були зарезервовані як ключові слова на майбутнє у давніших специфікаціях ECMAScript (від ECMAScript 1 і до версії 3).

- `abstract`
- `boolean`
- `byte`
- `char`
- `double`
- `final`
- `float`
- `goto`
- `int`
- `long`
- `native`
- `short`
- `synchronized`
- `throws`
- `transient`
- `volatile`

### Ідентифікатори з особливими значеннями

Кілька ідентифікаторів має особливе значення в певних контекстах, хоча вони не є зарезервованими словами жодного роду. Серед них:

- {{jsxref("Functions/arguments", "arguments")}} (не ключове слово, але в суворому режимі не може бути оголошений такий ідентифікатор)
- `as` ([`import * as ns from "mod"`](/uk/docs/Web/JavaScript/Reference/Statements/import#import-prostoru-imen))
- [`async`](/uk/docs/Web/JavaScript/Reference/Statements/async_function)
- {{jsxref("Global_Objects/eval", "eval")}} (не ключове слово, але в суворому режимі не може бути оголошений такий ідентифікатор)
- `from` ([`import x from "mod"`](/uk/docs/Web/JavaScript/Reference/Statements/import))
- {{jsxref("Functions/get", "get")}}
- [`of`](/uk/docs/Web/JavaScript/Reference/Statements/for...of)
- {{jsxref("Functions/set", "set")}}

## Літерали

> **Примітка:** Цей розділ описує літерали, що є неподільними лексемами. [Об'єктні літерали](/uk/docs/Web/JavaScript/Reference/Operators/Object_initializer) та [літерали масивів](/uk/docs/Web/JavaScript/Reference/Global_Objects/Array/Array#zapys-literala-masyva) є [виразами](/uk/docs/Web/JavaScript/Reference/Operators), що складаються з низки лексем.

### Літерал null

Докладніше дивіться на сторінці [`null`](/uk/docs/Web/JavaScript/Reference/Operators/null).

```js-nolint
null
```

### Булів літерал

Докладніше дивіться на сторінці [булевого типу](/uk/docs/Web/JavaScript/Data_structures#typ-boolean).

```js-nolint
true
false
```

### Числові літерали

Числові літерали використовують типи [Number](/uk/docs/Web/JavaScript/Data_structures#typ-number) і [BigInt](/uk/docs/Web/JavaScript/Data_structures#typ-bigint).

#### Десяткові числа

```js-nolint
1234567890
42
```

Десяткові літерали можуть починатися з нуля (`0`), після якого стоїть будь-яка інша десяткова цифра, але якщо всі цифри після `0` на початку менші за 8 – то число тлумачиться як вісімкове. Це вважається історичним синтаксисом, і числові літерали, що починаються з `0`, незалежно від того, чи тлумачаться вони як вісімкові, чи як десяткові, призводять до синтаксичної помилки в [суворому режимі](/uk/docs/Web/JavaScript/Reference/Strict_mode#istorychni-visimkovi-literaly) – таким чином, натомість слід використовувати префікс `0o`.

```js-nolint example-bad
0888 // 888 розбирається як десяткове
0777 // розбирається як вісімкове, тобто дає десяткове 511
```

##### Степеневий запис

Десятковий степеневий літерал – заданий наступним форматом: `beN`; де `b` – основа степеня (ціле або дробове число), далі – символ `E` або `e` (котрий служить розділювачем – _індикатором степеня_), і `N`, що є _степенем_, тобто _показником степеня_, – ціле число зі знаком.

```js-nolint
0e-5   // 0
0e+5   // 0
5e1    // 50
175e-2 // 1.75
1e3    // 1000
1e-3   // 0.001
1E3    // 1000
```

#### Двійкові

Синтаксис двійкових чисел використовує нуль на початку, після якого стоїть мала або велика латинська літера "B" (`0b` або `0B`). Будь-який символ після `0b`, котрий не є ані 0, ані 1, завершить послідовність літерала.

```js-nolint
0b10000000000000000000000000000000 // 2147483648
0b01111111100000000000000000000000 // 2139095040
0B00000000011111111111111111111111 // 8388607
```

#### Вісімкові

Синтаксис вісімкових чисел використовує нуль на початку, після якого стоїть мала або велика латинська літера "O" (`0o` або `0O)`. Будь-який символ після `0o`, що знаходиться поза діапазоном (01234567), завершить послідовність літерала.

```js-nolint
0O755 // 493
0o644 // 420
```

#### Шістнадцяткові

Синтаксис шістнадцяткових чисел використовує нуль на початку, після якого стоїть мала або велика латинська літера "X" (`0x` або `0X`). Будь-який символ після `0x`, що знаходиться поза діапазоном (0123456789ABCDEF), завершить послідовність літерала.

```js-nolint
0xFFFFFFFFFFFFFFFFF // 295147905179352830000
0x123456789ABCDEF   // 81985529216486900
0XA                 // 10
```

#### Літерал BigInt

Тип [BigInt](/uk/docs/Web/JavaScript/Data_structures#typ-bigint) – це числовий примітив JavaScript, що може представляти цілі числа з довільною точністю. Літерали BigInt створюються шляхом додавання `n` у кінець цілого числа.

```js-nolint
123456789123456789n     // 123456789123456789
0o777777777777n         // 68719476735
0x123456789ABCDEFn      // 81985529216486895
0b11101001010101010101n // 955733
```

Літерали BigInt не можуть починатися на `0` задля уникання плутанини з історичними вісімковими літералами.

```js example-bad
0755n;
// SyntaxError: invalid BigInt syntax
```

Для створення вісімкових чисел `BigInt` слід завжди після нуля на початку ставити літеру "o" (велику або малу):

```js example-good
0o755n;
```

Більше інформації про `BigInt` в статті [Структури даних JavaScript](/uk/docs/Web/JavaScript/Data_structures#typ-bigint).

#### Розділювачі розрядів

Для покращення прочитності числових літералів можуть вживатися розділювачі у вигляді підкреслень (`_`, `U+005F`):

```js-nolint
1_000_000_000_000
1_050.95
0b1010_0001_1000_0101
0o2_2_5_6
0xA0_B0_C0
1_000_000_000_000_000_000_000n
```

Зверніть увагу на наступні обмеження:

```js example-bad
// Не можна ставити більш ніж одне підкреслення підряд
100__000; // SyntaxError

// Не можна ставити підкреслення в кінці числового літерала
100_; // SyntaxError

// Не можна ставити підкреслення після 0 на початку
0_1; // SyntaxError
```

### Рядкові літерали

[Рядковий](/uk/docs/Web/JavaScript/Data_structures#typ-string) літерал – це нуль або більше кодових точок Unicode, загорнутих в одинарні чи подвійні лапки. Також кодові точки Unicode можуть бути представлені екранованою послідовністю. В рядкових літералах можуть зустрічатися в буквальному вигляді усі кодові точки, окрім оцих кодових точок, що закривають лапки:

- U+005C \ (backslash),
- U+000D \<CR>,
- and U+000A \<LF>.

Усі кодові точки можуть зустрічатися у вигляді послідовності екранування. Рядкові літерали обчислюються до рядкових значень ECMAScript. При генеруванні цих рядкових значень кодові точки Unicode кодуються в UTF-16.

```js-nolint
'foo'
"bar"
```

#### Шістнадцяткові послідовності екранування

Шістнадцяткові послідовності екранування складаються з `\x`, а далі – рівно двох шістнадцяткових цифр, що представляють кодову одиницю або кодову точку в діапазоні від 0x0000 до 0x00FF.

```js
"\xA9"; // "©"
```

#### Послідовності екранування Unicode

Послідовності екранування Unicode складаються з рівно чотирьох шістнадцяткових цифр, що стоять після `\u`. Вони представляють кодові точки в кодуванні UTF-16. Для кодових точок від U+0000 до U+FFFF кодові одиниці відповідають кодовим точкам. Кодові точки від U+10000 до U+10FFFF вимагають для кодування одного символу дві послідовності екранування, що представляють дві кодові одиниці (сурогатну пару); сурогатна пара – не те саме, що кодова точка.

Дивіться також {{jsxref("String.fromCharCode()")}} і {{jsxref("String.prototype.charCodeAt()")}}.

```js
"\u00A9"; // "©" (U+A9)
```

#### Екранування кодових точок Unicode

Екранування кодової точки Unicode складається з `\u{`, далі – кодової точки за шістнадцятковою базою, після чого – `}`. Значення шістнадцяткових цифр повинно бути в діапазоні від 0 до 0x10FFFF включно. Кодові точки в діапазоні від U+10000 до U+10FFFF немає потреби представляти у вигляді сурогатної пари.

Дивіться також {{jsxref("String.fromCodePoint()")}} і {{jsxref("String.prototype.codePointAt()")}}.

```js
"\u{2F804}"; // CJK COMPATIBILITY IDEOGRAPH-2F804 (U+2F804)

// той самий символ у вигляді сурогатної пари
"\uD87E\uDC04";
```

### Літерали регулярних виразів

На обох кінцях літералів регулярних виразів ставляться скісні риски (`/`). Лексичний аналізатор захоплює всі символи аж до наступної неекранованої скісної риски або кінця рядка, якщо ця скісна риска не стоїть всередині класу символів (`[]`). Частина символів (а саме – ті, котрі є [складовими частинами ідентифікаторів](#identyfikatory)) може стояти після завершальної риски, – вони слугують за позначки.

Лексична граматика JavaScript - вельми поблажлива: не всі літерали регулярних виразів, котрі впізнаються як єдиний токен, є дійсними регулярними виразами.

Дивіться докладніше на сторінці {{jsxref("RegExp")}}.

```js-nolint
/ab+c/g
/[/]/
```

Літерал регулярного виразу не може починатися з двох скісних рисок (`//`), тому що вони позначали б рядковий коментар. Щоб задати порожній регулярний вираз, слід використовувати `/(?:)/`.

### Шаблонні літерали

Один шаблонний літерал складається з декількох лексем: `` `xxx${`` (голова шаблону), `}xxx${` (середина шаблону) та `` }xxx`  `` (хвіст шаблону) є окремими лексемами, а між ними може стояти будь-який вираз.

Більше інформації – на сторінці [шаблонних літералів](/uk/docs/Web/JavaScript/Reference/Template_literals).

```js-nolint
`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tag`string text ${expression} string text`
```

## Автоматичне вставляння крапок з комою

Частина визначень синтаксису [інструкцій JavaScript](/uk/docs/Web/JavaScript/Reference/Statements) вимагає крапок з комою (`;`) на їх кінці. Серед таких інструкцій:

- [`var`](/uk/docs/Web/JavaScript/Reference/Statements/var), [`let`](/uk/docs/Web/JavaScript/Reference/Statements/let), [`const`](/uk/docs/Web/JavaScript/Reference/Statements/const)
- [Інструкції-вирази](/uk/docs/Web/JavaScript/Reference/Statements/Expression_statement)
- [`do...while`](/uk/docs/Web/JavaScript/Reference/Statements/do...while)
- [`continue`](/uk/docs/Web/JavaScript/Reference/Statements/continue), [`break`](/uk/docs/Web/JavaScript/Reference/Statements/break), [`return`](/uk/docs/Web/JavaScript/Reference/Statements/return), [`throw`](/uk/docs/Web/JavaScript/Reference/Statements/throw)
- [`debugger`](/uk/docs/Web/JavaScript/Reference/Statements/debugger)
- Оголошення полів класів ([публічних](/uk/docs/Web/JavaScript/Reference/Classes/Public_class_fields) та [приватних](/uk/docs/Web/JavaScript/Reference/Classes/Private_class_fields))
- [`import`](/uk/docs/Web/JavaScript/Reference/Statements/import), [`export`](/uk/docs/Web/JavaScript/Reference/Statements/export)

Проте для того, щоб мова JavaScript була доступнішою та зрозумілішою, JavaScript автоматично вставляє крапки з комою, коли захоплює потік лексем, тож частина недійсних послідовностей лексем може бути "виправлена" до дійсного синтаксису. Цей крок відбувається після того, як текст програми розбирається на лексеми згідно з лексичною граматикою. Є три випадки, за яких автоматично вставляються крапки з комою:

1\. Коли зустрічається лексема, заборонена граматикою, і вона відділена від попередньої лексеми принаймні одним [символом кінця рядка](#symvoly-kintsia-riadka) (включно з блоковим коментарем, що містить щонайменше один символ кінця рядка), або ж цією лексемою є "}", то перед такою лексемою ставиться крапка з комою.

```js-nolint
{ 1
2 } 3

// автоматично трансформується на:

{ 1
;2 ;} 3;

// Це є дійсною граматикою, що кодує три інструкції,
// кожна з яких складається з числового літерала
```

Завершальна ")" циклу [`do...while`](/uk/docs/Web/JavaScript/Reference/Statements/do...while) також обробляється цим правилом – як особливий випадок.

```js-nolint
do {
  // ...
} while (condition) /* ; */ // Автоматичне вставляння – тут
const a = 1
```

Проте крапка з комою не вставляється, якщо вона стала б розділювачем у заголовку інструкції [`for`](/uk/docs/Web/JavaScript/Reference/Statements/for).

```js example-bad
for (
  let a = 1 // Тут без автоматичного вставляння
  a < 10 // Тут без автоматичного вставляння
  a++
) {}
```

Крім цього, крапки з комою ніколи не вставляються як [порожні інструкції](/uk/docs/Web/JavaScript/Reference/Statements/Empty). Наприклад, у коді нижче, якщо вставити крапку з комою після ")", то код був би дійсним, з порожньою інструкцією як тілом `if` і оголошенням `const` як окремою інструкцією. Проте завдяки тому, що автоматично вставлені крапки з комою не можуть ставати порожніми інструкціями, це призводить до того, що тілом інструкції `if` стає [оголошення](/uk/docs/Web/JavaScript/Reference/Statements#vidminnosti-mizh-instruktsiiamy-ta-oholoshenniamy), що не є дійсним записом.

```js example-bad
if (Math.random() > 0.5)
const x = 1 // SyntaxError: Unexpected token 'const'
```

2\. Коли досягнуто кінця потоку лексем, і розбирач не може розібрати цей потік сам по собі як закінчену програму, в кінці вставляється крапка з комою.

```js-nolint
const a = 1 /* ; */ // Автоматичне вставляння тут
```

Це правило доповнює попереднє, а саме – для такого випадку, коли немає "лексеми-порушника", але настав кінець потоку введення.

3\. Коли граматика забороняє в певному місці символи кінця рядка, але такий символ зустрівся, вставляється крапка з комою. Серед таких місць:

- `expr <here> ++`, `expr <here> --`
- `continue <here> lbl`
- `break <here> lbl`
- `return <here> expr`
- `throw <here> expr`
- `yield <here> expr`
- `yield <here> * expr`
- `(param) <here> => {}`
- `async <here> function`, `async <here> prop()`, `async <here> function*`, `async <here> *prop()`, `async <here> (param) <here> => {}`

Тут [`++`](/uk/docs/Web/JavaScript/Reference/Operators/Increment) не розглядається як постфіксний оператор, що застосовується до змінної `b`, тому що між `b` і `++` знаходиться символ кінця рядка.

```js-nolint
a = b
++c

// автоматичним вставлянням трансформується до

a = b;
++c;
```

Тут інструкція `return` повертає `undefined`, і `a + b` стає недосяжною інструкцією.

```js-nolint
return
a + b

// автоматичним вставлянням трансформується до

return;
a + b;
```

Зверніть увагу, що автоматичне вставляння запускається лише тоді, коли розрив рядка розділяє лексеми, що без нього утворюють недійсний запис. Якщо наступна лексема може бути розібрана як частина дійсної структури, то крапки з комою не вставляються. Наприклад:

```js-nolint example-bad
const a = 1
(1).toString()

const b = 1
[1, 2, 3].forEach(console.log)
```

Через те, що `()` можуть розглядатися як виклик функції, зазвичай вони не спричиняють запуску автоматичного вставляння. Подібно до цього, `[]` можуть бути звертанням до елемента. Код вище – рівносильний щодо:

```js-nolint example-bad
const a = 1(1).toString();

const b = 1[1, 2, 3].forEach(console.log);
```

Так вийшло, що це дійсний синтаксис. `1[1, 2, 3]` – це [аксесор властивості](/uk/docs/Web/JavaScript/Reference/Operators/Property_Accessors) з виразом, об'єднаним [комою](/uk/docs/Web/JavaScript/Reference/Operators/Comma_Operator). Таким чином, при запуску коду вийдуть помилки виду "1 is not a function" and "Cannot read properties of undefined (reading 'forEach')".

Всередині класів пастками також можуть бути поля класів та генераторні методи.

```js example-bad
class A {
  a = 1
  *gen() {}
}
```

Розглядається як:

```js example-bad
class A {
  a = 1 * gen() {}
}
```

І таким чином – буде синтаксична помилка біля `{`.

Є кілька емпіричних правил для роботи з автоматичним вставлянням, коли є потреба примушувати до стилю без крапок з комою:

- Постфіксні `++` і `--` слід писати на тому ж рядку, що і їхні операнди.

  ```js-nolint example-bad
  const a = b
  ++
  console.log(a) // ReferenceError: Invalid left-hand side expression in prefix operation
  ```

  ```js-nolint example-good
  const a = b++
  console.log(a)
  ```

- Вирази після `return`, `throw` і `yield` повинні стояти на тому ж рядку, що й ключове слово.

  ```js-nolint example-bad
  function foo() {
    return
      1 + 1 // Повертає undefined; 1 + 1 – ігнорується
  }
  ```

  ```js-nolint example-good
  function foo() {
    return 1 + 1
  }
  function foo() {
    return (
      1 + 1
    )
  }
  ```

- Подібно до цього, ідентифікатор позначки після `break` або `continue` повинен стояти на тому ж рядку, що й ключове слово.

  ```js-nolint example-bad
  outerBlock: {
    innerBlock: {
      break
        outerBlock // SyntaxError: Illegal break statement
    }
  }
  ```

  ```js-nolint example-good
  outerBlock: {
    innerBlock: {
      break outerBlock
    }
  }
  ```

- `=>` стрілкової функції повинна стояти на тому ж рядку, що і її параметри.

  ```js-nolint example-bad
  const foo = (a, b)
    => a + b
  ```

  ```js-nolint example-good
  const foo = (a, b) =>
    a + b
  ```

- Після `async` асинхронних функцій, методів тощо не може зразу стояти символ кінця рядка.

  ```js-nolint example-bad
  async
  function foo() {}
  ```

  ```js-nolint example-good
  async function
  foo() {}
  ```

- Якщо рядок починається з `(`, `[`, `` ` ``, `+`, `-` або `/` (як в літералах регулярних виразів), слід поставити перед цим крапку з комою, або ж поставити в кінець попереднього рядка крапку з комою.

  ```js-nolint example-bad
  // () може зливатися з попереднім рядком як частина виклику функції
  (() => {
    // ...
  })()
  // [ може зливатися з попереднім рядком як частина звертання до властивості
  [1, 2, 3].forEach(console.log)
  // ` може зливатися з попереднім рядком як частина тегованого шаблонного літерала
  `string text ${data}`.match(pattern).forEach(console.log)
  // + може зливатися з попереднім рядком як частина бінарного виразу +
  +a.toString()
  // - може зливатися з попереднім рядком як частина бінарного виразу -
  -a.toString()
  // / може зливатися з попереднім рядком як частина виразу ділення
  /pattern/.exec(str).forEach(console.log)
  ```

  ```js-nolint example-good
  ;(() => {
    // ...
  })()
  ;[1, 2, 3].forEach(console.log)
  ;`string text ${data}`.match(pattern).forEach(console.log)
  ;+a.toString()
  ;-a.toString()
  ;/pattern/.exec(str).forEach(console.log)
  ```

- Поля класу краще закінчувати крапкою з комою: на додачу до попереднього правила (котре включає оголошення поля, після якого стоїть [обчислювана властивість](/uk/docs/Web/JavaScript/Reference/Operators/Object_initializer#imena-obchysliuvanykh-vlastyvostei), адже останні починаються з `[`), крапки з комою також необхідні між оголошенням поля та генераторним методом.

  ```js-nolint example-bad
  class A {
    a = 1
    [b] = 2
    *gen() {} // Розглядається як a = 1[b] = 2 * gen() {}
  }
  ```

  ```js-nolint example-good
  class A {
    a = 1;
    [b] = 2;
    *gen() {}
  }
  ```

## Сумісність із браузерами

{{Compat}}

## Дивіться також

- [Лексична граматика в специфікації ECMAScript](https://tc39.es/ecma262/#sec-ecmascript-language-lexical-grammar)
- [Джефф Волден – Двійкові та вісімкові числа](https://whereswalden.com/2013/08/12/micro-feature-from-es6-now-in-firefox-aurora-and-nightly-binary-and-octal-numbers/)
- [Матіас Байненс – Послідовності екранування символів у JavaScript](https://mathiasbynens.be/notes/javascript-escapes)
- [Boolean](/uk/docs/Web/JavaScript/Data_structures#typ-boolean)
- [Number](/uk/docs/Web/JavaScript/Data_structures#typ-number)
- [string](/uk/docs/Web/JavaScript/Data_structures#typ-string)
- {{jsxref("RegExp")}}
