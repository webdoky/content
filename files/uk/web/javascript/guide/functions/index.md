---
title: Функції
slug: Web/JavaScript/Guide/Functions
page-type: guide
---

{{jsSidebar("JavaScript Guide")}} {{PreviousNext("Web/JavaScript/Guide/Loops_and_iteration", "Web/JavaScript/Guide/Expressions_and_operators")}}

Функції – серед основних цеглинок, з котрих складається JavaScript. Функція в JavaScript подібна до процедури: низка інструкцій, котрі виконують завдання чи обчислюють значення; але щоб процедура вважалася функцією, вона повинна приймати певні значення на вхід і повертати виведення, щоб існував певний очевидний зв'язок між введенням та виведенням. Щоб використати функцію, її треба визначити десь в області видимості, з якої її буде викликано.

Дивіться подробиці також у [вичерпному довідковому розділі про функції JavaScript](/uk/docs/Web/JavaScript/Reference/Functions).

## Визначення функцій

### Оголошення функцій

**Визначення функції** (котре також зветься **оголошенням функції**, або ж **функційною інструкцією**) складається з ключового слова [`function`](/uk/docs/Web/JavaScript/Reference/Statements/function), після якого:

- Ім'я функції.
- Список параметрів функції, оточений дужками й розділений комами.
- Інструкції JavaScript, котрі визначають функцію, оточені фігурними дужками – `{ /* … */ }`.

Наприклад, наступний код визначає функцію, що зветься `square`:

```js
function square(number) {
  return number * number;
}
```

Функція `square` приймає один параметр, що зветься `number`. Вона складається з однієї інструкції, котра каже повернути параметр функції (тобто `number`), помножений на себе. Інструкція [`return`](/uk/docs/Web/JavaScript/Reference/Statements/return) задає значення, повернене функцією, тобто `number * number`.

Параметри по суті передаються до функцій **за значенням** — тож якщо код всередині тіла функції присвоює параметрові, переданому в функцію, геть нове значення, то **такі зміни не поширюються глобально чи в коді, котрий викликав цю функцію**.

Коли об'єкт передається як параметр, то якщо функція змінює його властивості, то зміни помітні поза функцією, як показано в наступному прикладі:

```js
function myFunc(theObject) {
  theObject.make = "Toyota";
}

const myCar = {
  make: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(myCar.make); // "Honda"

// властивість make змінена функцією
myFunc(myCar);
console.log(myCar.make); // "Toyota"
```

Коли як параметр передається масив, то якщо функція змінює будь-яке зі значень масиву, то такі зміни помітні поза функцією, як показано в наступному прикладі:

```js
function myFunc(theArr) {
  theArr[0] = 30;
}

const arr = [45];

console.log(arr[0]); // 45
myFunc(arr);
console.log(arr[0]); // 30
```

Оголошення та вирази функцій можна вкладати одне в одне, що утворює _ланцюжок областей видимості_. Наприклад:

```js
function addSquares(a, b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}
```

Читайте більше в [функційних областях видимості та замиканнях](#funktsiini-oblasti-vydymosti-ta-zamykannia).

### Вирази функцій

Коли оголошення функції з боку синтаксису є інструкцією, то функції також можна створити за допомогою [виразів функцій](/uk/docs/Web/JavaScript/Reference/Operators/function).

Така функція може бути **анонімною**; вона не обов'язково повинна мати ім'я. Наприклад, функція `square` могла б бути визначена так:

```js
const square = function (number) {
  return number * number;
};

console.log(square(4)); // 16
```

Проте ім'я _може_ бути надано в виразі функції. Надання імені дає функції змогу посилатися на саму себе, а також полегшує впізнання функції трасуванні стека зневаджувача:

```js
const factorial = function fac(n) {
  return n < 2 ? 1 : n * fac(n - 1);
};

console.log(factorial(3)); // 6
```

Вирази функцій зручні при передачі функції як аргументу в іншу функцію. Наступний приклад визначає функцію `map`, котра повинна отримати функцію як перший аргумент і масив як другий аргумент. Далі вона викликається з передачею функції, визначеної функційним виразом:

```js
function map(f, a) {
  const result = new Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = f(a[i]);
  }
  return result;
}

const numbers = [0, 1, 2, 5, 10];
const cubedNumbers = map(function (x) {
  return x * x * x;
}, numbers);
console.log(cubedNumbers); // [0, 1, 8, 125, 1000]
```

Функція повертає: `[0, 1, 8, 125, 1000]`.

У JavaScript функція може бути визначена на основі умови. Наприклад, наступне означення функції визначає `myFunc` лише за умови, що `num` дорівнює `0`:

```js
let myFunc;
if (num === 0) {
  myFunc = function (theObject) {
    theObject.make = "Toyota";
  };
}
```

На додачу до визначення функцій, як це описано вище, можна використати конструктор {{jsxref("Function")}} для створення функцій з рядків під час виконання, подібно до {{jsxref("Global_Objects/eval", "eval()")}}.

**Метод** – це функція, що є властивістю об'єкта. Читайте більше про об'єкти та методи в [Роботі з об'єктами](/uk/docs/Web/JavaScript/Guide/Working_with_objects).

## Виклик функції

_Визначення_ функції не _виконує_ її. Визначення дає їй ім'я та порядок дій у випадку її виклику.

**Виклик** функції вже виконує задані дії, з використанням вказаних параметрів. Наприклад, якщо визначити функцію `square`, то викликати її можна буде отак:

```js
square(5);
```

Інструкція вище викликає функцію з аргументом `5`. Функція виконує свої інструкції й повертає значення `25`.

Функції повинні бути _доступні в області видимості_, коли викликані, але оголошення функції може бути [піднято](#pidniattia-funktsii) (стояти в коді нижче власного виклику). Областю видимості оголошення функції є та функція, в якій перша була оголошена (або вся програма, якщо функцію оголошено на верхньому рівні).

Аргументи функцій не обмежені рядками й числами. У функції можна передавати цілі об'єкти. Функція `showProps()` (визначена в [Роботі з об'єктами](/uk/docs/Web/JavaScript/Guide/Working_with_objects#obiekty-i-vlastyvosti)) є прикладом функції, котра приймає об'єкт за аргумент.

Функція може викликати сама себе. Наприклад, ось функція, що рекурсивно обчислює факторіали:

```js
function factorial(n) {
  if (n === 0 || n === 1) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}
```

Тепер можна обчислити факторіали від `1` до `5` ось так:

```js
console.log(factorial(1)); // 1
console.log(factorial(2)); // 2
console.log(factorial(3)); // 6
console.log(factorial(4)); // 24
console.log(factorial(5)); // 120
```

Є інші способи викликати функцію. Нерідко трапляються випадки, коли функцію треба викликати динамічно, або коли число аргументів функції може бути різне, або коли контекст, в якому викликається функція, треба встановлювати як певний об'єкт під час виконання програми.

Виявляється, _функції самі є об'єктами_ – і ці об'єкти й собі мають методи. (Дивіться об'єкт {{jsxref("Function")}}.) Методи [`call()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/call) і [`apply()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/apply) можуть бути використані для досягнення такої цілі.

### Підняття функцій

Розгляньмо приклад нижче:

```js
console.log(square(5)); // 25
function square(n) {
  return n * n;
}
```

Такий код виконається без жодних помилок, попри те, що функція `square()` викликана до власного оголошення. Так відбувається через те, що інтерпретатор JavaScript піднімає все оголошення функції нагору поточної області видимості, тож код вище рівносильний такому кодові:

```js
// Усі оголошення функцій по суті спрацьовують нагорі області видимості
function square(n) {
  return n * n;
}
console.log(square(5)); // 25
```

Підняття функцій працює лише для _оголошень_ функцій – але не _виразів_ функцій. Наступний код не запрацює:

```js example-bad
console.log(square(5)); // ReferenceError: Cannot access 'square' before initialization
const square = function (n) {
  return n * n;
};
```

### Рекурсія

Функція може звертатися до себе й викликати себе. На неї можна послатися за назвою функційного виразу або оголошення, або через будь-яку доступну в області видимості змінну, що посилається на об'єкт-функцію. Наприклад, розгляньмо наступне визначення функції:

```js
const foo = function bar() {
  // тут інструкції
};
```

Всередині тіла функції можна посилатись на неї саму за допомогою як `bar`, так і `foo`, і викликати її за допомогою `bar()` і `foo()`.

Функція, що викликає сама себе, зветься _рекурсивною функцією_. У певному відношенні рекурсія аналогічна циклові. І рекурсія, і цикл виконують один і той же код декілька разів, обидва потребують умови (аби уникнути нескінченного виконання циклу, або в цьому випадку – радше нескінченної рекурсії).

Наприклад, розгляньмо наступний цикл:

```js
let x = 0;
while (x < 10) {
  // "x < 10" – умова циклу
  // різні дії
  x++;
}
```

Його можна перетворити на оголошення рекурсивної функції з викликом цієї функції:

```js
function loop(x) {
  // "x >= 10" – умова виходу (рівносильна "!(x < 10)")
  if (x >= 10) {
    return;
  }
  // різні дії
  loop(x + 1); // рекурсивний виклик
}
loop(0);
```

Проте частина алгоритмів не може бути простими циклами ітерації. Наприклад, отримати всі вузли деревної структури (як то [DOM](/uk/docs/Web/API/Document_Object_Model)) легше шляхом рекурсії:

```js
function walkTree(node) {
  if (node === null) {
    return;
  }
  // якісь дії з вузлом
  for (let i = 0; i < node.childNodes.length; i++) {
    walkTree(node.childNodes[i]);
  }
}
```

У порівнянні з функцією `loop`, кожний рекурсивний виклик сам робить тут чимало рекурсивних викликів.

Є можливим перетворити будь-який рекурсивний алгоритм на нерекурсивний, але при цьому логіка нерідко стає набагато складнішою, і таке перетворення вимагає використання стека.

Насправді рекурсія сама використовує стек – стек функції. Стекоподібна логіка може спостерігатися в наступному прикладі:

```js
function foo(i) {
  if (i < 0) {
    return;
  }
  console.log(`початок: ${i}`);
  foo(i - 1);
  console.log(`кінець: ${i}`);
}
foo(3);

// Виводить:

// початок: 3
// початок: 2
// початок: 1
// початок: 0
// кінець: 0
// кінець: 1
// кінець: 2
// кінець: 3
```

### Негайно закличні вирази-функції (IIFE)

[Негайно закличний вираз-функція (IIFE)](/uk/docs/Glossary/IIFE) – це патерн кодування, що безпосередньо викликає функцію, визначену як вираз. Він має такий вигляд:

```js
(function () {
  // Якісь дії
})();

const value = (function () {
  // Якісь дії
  return someValue;
})();
```

Замість збереження функції в змінній, ця функція негайно закликається. Це майже еквівалентно простому написанню тіла функції, але має кілька унікальних переваг:

- Це створює додаткову [область видимості](#funktsiini-oblasti-vydymosti-ta-zamykannia) змінних, що допомагає обмежити змінні тим місцем, де вони корисні.
- Це утворює _вираз_ замість простої послідовності _інструкцій_. Це дає змогу писати складну логіку обчислень при ініціалізації змінних.

Більше про це читайте на сторінці глосарія [IIFE](/uk/docs/Glossary/IIFE).

## Функційні області видимості та замикання

Функції утворюють [область видимості](/uk/docs/Glossary/Scope) для змінних – це означає, що до змінних, визначених всередині функції, не можна звернутися звідусіль поза функцією. Область видимості функції успадковує від усіх областей видимості вищих рівнів. Наприклад, функція, визначена в глобальній області видимості, може звертатися до всіх змінних, визначених в глобальній області видимості. Функція, визначена всередині іншої функції, також може звертатися до всіх змінних, визначених в її батьківській функції, і до будь-яких інших змінних, до яких має доступ батьківська функція. З іншого боку, батьківська функція (і будь-яка інша батьківська область видимості) _не_ має доступу до змінних і функцій, визначених всередині внутрішньої функції. Це забезпечує певного роду інкапсуляцію для змінних внутрішньої функції.

```js
// Наступні змінні визначені в глобальній області видимості
const num1 = 20;
const num2 = 3;
const name = "Шамах";

// Ця функція визначена в глобальній області видимості
function multiply() {
  return num1 * num2;
}

console.log(multiply()); // 60

// Приклад вкладеної функції
function getScore() {
  const num1 = 2;
  const num2 = 3;

  function add() {
    return `${name} отримав балів: ${num1 + num2}`;
  }
  return add();
}

console.log(getScore()); // "Шамах отримав балів: 5"
```

### Замикання

Також тіло функції звуть _замиканням_. Замикання – це будь-який фрагмент вихідного коду (найчастіше – функція), що посилається на певні змінні, і замикання "запам'ятовує" ці змінні навіть тоді, коли з області видимості, в якій ці змінні були оголошені, вже стався вихід.

Замикання зазвичай ілюструють за допомогою [вкладених функцій](#vkladeni-funktsii), аби показати, що вони запам'ятовують змінні поза областю видимості батьківської області видимості; але насправді вкладені функції не є обов'язковими. Технічно кажучи, всі функції в JavaScript утворюють замикання – деякі просто нічого не захоплюють, і замикання навіть не обов'язково мають бути функціями. Ключові складові для _корисного_ замикання такі:

- Батьківська область видимості, що визначає деякі змінні чи функції. Вона повинна мати чіткий термін життя, тобто повинна в певний момент завершити своє виконання. Цю вимогу задовольняють всі області видимості, що не є глобальними; серед таких областей: блоки, функції, модулі тощо.
- Вкладена область видимості, що посилається на деякі змінні чи функції з батьківської області видимості.
- Вкладена область видимості, що переживає термін життя батьківської області. Наприклад, вона зберігається в змінній, що визначена поза батьківською областю видимості, або ж повертається з батьківської області видимості (якщо батьківська область видимості – це функція).
- Потім, коли функція викликається поза батьківською областю видимості, ще можна звертатися до змінних чи функцій, що були визначені в батьківській області видимості, навіть якщо батьківська область видимості завершила виконання.

Далі – типовий приклад замикання:

```js
const pet = function (name) {
  // Зовнішня функція визначає змінну, що зветься "name"
  const getName = function () {
    // Внутрішня функція має доступ до змінної "name" зовнішньої функції
    return name;
  };
  return getName; // Повернути внутрішню функцію, таким чином відкриваючи її для зовнішніх областей видимості
};
const myPet = pet("Лазанья");

console.log(myPet()); // "Лазанья"
```

Усе може бути складніше, ніж у коді вище. Можна повернути цілий об'єкт, що містить методи для роботи з внутрішніми змінними зовнішніх функцій.

```js
const createPet = function (name) {
  let sex;

  const pet = {
    // setName(newName) рівносильно setName: function (newName)
    // у цьому контексті
    setName(newName) {
      name = newName;
    },

    getName() {
      return name;
    },

    getSex() {
      return sex;
    },

    setSex(newSex) {
      if (
        typeof newSex === "string" &&
        (newSex.toLowerCase() === "male" || newSex.toLowerCase() === "female")
      ) {
        sex = newSex;
      }
    },
  };

  return pet;
};

const pet = createPet("Лазанья");
console.log(pet.getName()); // Лазанья

pet.setName("Блек");
pet.setSex("male");
console.log(pet.getSex()); // male
console.log(pet.getName()); // Блек
```

У коді вище змінна `name` зовнішньої функції доступна внутрішнім функціям, і немає іншого способу звернутися до внутрішніх змінних, окрім як за допомогою внутрішніх функцій. Внутрішні змінні внутрішніх функцій діють як безпечні сховища для зовнішніх аргументів та змінних. Вони зберігають "постійні" й "інкапсульовані" дані для роботи внутрішніх функцій. Функції навіть не обов'язково присвоювати змінним чи давати їм ім'я.

```js
const getCode = (function () {
  const apiCode = "0]Eal(eh&2"; // Код, котрий сторонні не повинні мати змогу редагувати…

  return function () {
    return apiCode;
  };
})();

console.log(getCode()); // "0]Eal(eh&2"
```

У коді вище вживається патерн [IIFE](#nehaino-zaklychnyi-vyraz-funktsiia-iife). У межах цієї області видимості IIFE існують два значення: змінна `apiCode` і безіменна функція, що повертається й присвоюється змінній `getCode`. `apiCode` перебуває в області видимості поверненої безіменної функції, але не в області видимості жодної іншої частини програми, тож ніяк не можна зчитати значення `apiCode`, окрім як через функцію `getCode`.

### Функції з кількома рівнями вкладеності

Функції можуть мати кілька рівнів вкладеності. Наприклад:

- Функція (`A`) містить функцію (`B`), яка сама містить функцію (`C`).
- І функція `B`, і функція `C` утворюють замикання. Таким чином, `B` може звертатися до `A`, а `C` може звертатися до `B`.
- Крім цього, оскільки `C` може звертатися до `B`, яка може звертатися до `A`, то `C` може звертатися до `A`.

Таким чином, замикання можуть містити кілька областей видимості; вони рекурсивно вміщають область видимості функцій, що їх містять. Це називається _ланцюгом областей видимості_. Розгляньмо наступний приклад:

```js
function A(x) {
  function B(y) {
    function C(z) {
      console.log(x + y + z);
    }
    C(3);
  }
  B(2);
}
A(1); // Виводить 6 (тобто 1 + 2 + 3)
```

У цьому прикладі `C` звертається до `y` з `B` та `x` з `A`. Це можливо, оскільки:

1. `B` утворює замикання, що включає `A` (тобто `B` може звертатися до аргументів та змінних `A`).
2. `C` утворює замикання, що включає `B`.
3. Оскільки замикання `C` включає `B`, а замикання `B` включає `A`, то замикання `C` також включає `A`. Це означає, що `C` може звертатися до _як до_ аргументів і змінних `B`, _так і до_ аргументів і змінних `A`. Інакше кажучи, `C` _ланцюгує_ області видимості `B` і `A`, _в такому порядку_.

Проте зворотне твердження є хибним. `A` не може звертатися до `C`, оскільки `A` не може звертатися до жодного аргументу чи змінної `B`, змінною якої є `C`. Таким чином, `C` залишається приватною лише для `B`.

### Конфлікти імен

Коли два аргументи або змінні в областях видимості замикання мають однакові імена, виникає _конфлікт імен_. Більш вкладені області видимості мають пріоритет. Таким чином, найглибше вкладена область видимості має найвищий пріоритет, а найменш вкладена – найнижчий. Це називається _ланцюгом областей видимості_. Першою в ланцюгу є найглибше вкладена область видимості, а останньою – найменш вкладена. Розгляньмо наступне:

```js
function outside() {
  const x = 5;
  function inside(x) {
    return x * 2;
  }
  return inside;
}
console.log(outside()(10)); // 20 (а не 10)
```

Конфлікт імен трапляється на інструкції `return x * 2`, між параметром `x` функції `inside` і змінною `x` функції `outside`. Ланцюг областей видимості тут такий: `inside` => `outside` => глобальний об'єкт. Тому `x` функції `inside` має пріоритет над `x` функції `outside`, і повертається `20` (змінна `x` функції `inside`), а не `10` (змінна `x` функції `outside`).

## Використання об'єкта arguments

Аргументи функції зберігаються в масивоподібному об'єкті. Всередині функції можна звертатися до переданих аргументів наступним чином:

```js
arguments[i];
```

де `i` – порядковий номер аргументу, починаючи від `0`. Тож першим аргументом, переданим у функцію, буде `arguments[0]`. Загальне число аргументів показує властивість `arguments.length`.

За допомогою об'єкта `arguments` можна викликати функцію з більшою кількістю аргументів, ніж вона приймає згідно з її формальним оголошенням. Це нерідко корисно, коли наперед невідомо, скільки аргументів буде передано в функцію. `arguments.length` можна використовувати для з'ясування фактичної кількості переданих у функцію аргументів, а потім звернутися до кожного аргументу за допомогою об'єкта `arguments`.

Для прикладу візьмімо функцію, що зчіплює докупи кілька рядків. Єдиний формальний аргумент функції – рядок, що задає символи, котрі стоятимуть між елементами зчеплення. Функція визначена так:

```js
function myConcat(separator) {
  let result = ""; // ініціалізація списку
  // ітерація по arguments
  for (let i = 1; i < arguments.length; i++) {
    result += arguments[i] + separator;
  }
  return result;
}
```

В цю функцію можна передати будь-яку кількість аргументів, і вона зчепить усі аргументи в рядковий "список":

```js
console.log(myConcat(", ", "червоний", "помаранчевий", "синій"));
// "червоний, помаранчевий, синій, "

console.log(myConcat("; ", "слон", "жирафа", "лев", "гепард"));
// "слон; жирафа; лев; гепард; "

console.log(
  myConcat(". ", "шавлія", "базилік", "орегано", "перець", "петрушка"),
);
// "шавлія. базилік. орегано. перець. петрушка. "
```

> [!NOTE]
> Змінна `arguments` – "масивоподібне" значення, але не масив. Її масивоподібність полягає в тому, що вона має пронумеровані властивості та властивість `length`. Проте вона _не_ має усіх методів роботи з масивами.

Подробиці доступні на сторінці об'єкта {{jsxref("Function")}} в довідці JavaScript.

## Параметри функції

Є два особливі різновиди синтаксису параметрів: _усталені параметри_ й _решта параметрів_.

### Усталені параметри

В JavaScript усталене значення параметрів функцій – `undefined`. Проте в деяких ситуаціях може бути корисним задати інше усталене значення. Це саме те, що роблять усталені параметри.

В минулому загальноприйнятим підходом до задання усталених значень були перевірка значень параметрів у тілі функції та присвоєння значення, якщо зустрілося `undefined`.

В наступному прикладі, коли жодне значення не задано як `b`, його значення буде `undefined` при обчисленні `a*b`, і виклик `multiply` природно повернув би `NaN`. Проте цьому запобігає другий рядок цього прикладу:

```js
function multiply(a, b) {
  b = typeof b !== "undefined" ? b : 1;
  return a * b;
}

console.log(multiply(5)); // 5
```

З _усталеними параметрами_ ручна перевірка в тілі функції більше не потрібна. Можна поставити `1` як усталене значення `b` в голові функції:

```js
function multiply(a, b = 1) {
  return a * b;
}

console.log(multiply(5)); // 5
```

Більше подробиць – на сторінці довідки [Усталені параметри](/uk/docs/Web/JavaScript/Reference/Functions/Default_parameters).

### Решта параметрів

Синтаксис [решти параметрів](/uk/docs/Web/JavaScript/Reference/Functions/rest_parameters) дає змогу представити необмежену кількість аргументів як масив.

В наступному прикладі функція `multiply` використовує _решту параметрів_ для збору аргументів від другого до їх кінця. Потім функція множить їх на перший аргумент.

```js
function multiply(multiplier, ...theArgs) {
  return theArgs.map((x) => multiplier * x);
}

const arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]
```

## Стрілкові функції

[Вираз стрілкової функції](/uk/docs/Web/JavaScript/Reference/Functions/Arrow_functions) (також зветься _товстою стрілкою_, для розрізнення щодо гіпотетичного синтаксису `->` у JavaScript майбутнього) має коротший синтаксис у порівнянні з виразами функцій і не має власних [`this`](/uk/docs/Web/JavaScript/Reference/Operators/this), [`arguments`](/uk/docs/Web/JavaScript/Reference/Functions/arguments), [`super`](/uk/docs/Web/JavaScript/Reference/Operators/super) і [`new.target`](/uk/docs/Web/JavaScript/Reference/Operators/new.target). Стрілкові функції завжди є анонімними.

Два чинники повпливали на запровадження стрілкових функцій: _коротший запис функцій_ та _незв'язування_ `this`.

### Коротший запис функцій

У деяких функційних патернах коротший запис функцій – вітається. Порівняйте:

```js
const a = ["Гідроген", "Гелій", "Літій", "Берилій"];

const a2 = a.map(function (s) {
  return s.length;
});

console.log(a2); // [8, 5, 5, 7]

const a3 = a.map((s) => s.length);

console.log(a3); // [8, 5, 5, 7]
```

### Немає окремого this

До стрілкових функцій кожна нова функція визначала власне значення [`this`](/uk/docs/Web/JavaScript/Reference/Operators/this) (новий об'єкт у випадку конструктора, undefined при виклику функції в [суворому режимі](/uk/docs/Web/JavaScript/Reference/Strict_mode), базовий об'єкт, якщо функція викликана як "метод об'єкта" тощо). Така логіка виявилась менш ніж ідеальною в умовах програмування об'єктноорієнтованого стилю.

```js
function Person() {
  // Конструктор Person() визначає `this` як самого себе.
  this.age = 0;

  setInterval(function growUp() {
    // В несуворому режимі функція growUp() визначає `this`
    // як глобальний об'єкт, а це не те саме, що `this`,
    // визначене конструктором Person().
    this.age++;
  }, 1000);
}

const p = new Person();
```

В ECMAScript 3/5 цю проблему розв'язували, присвоюючи значення `this` змінній, над котрою могло відбутися замикання.

```js
function Person() {
  const self = this; // Іноді замість `self` обирають `that`.
  // Оберіть щось одне й будьте послідовними.
  self.age = 0;

  setInterval(function growUp() {
    // Функція зворотного виклику звертається до змінної `self`,
    // чиїм значенням є очікуваний об'єкт.
    self.age++;
  }, 1000);
}
```

Інший варіант: можна було використати [зв'язану функцію](/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/bind), щоб у функцію `growUp()` потрапило коректне значення `this`.

Стрілкова функція не має власного `this`; використовується значення `this` із контексту виконання навколо неї. Отже, в наступному коді `this` всередині функції, переданої в `setInterval`, матиме таке саме значення, що й `this` у функції навколо неї:

```js
function Person() {
  this.age = 0;

  setInterval(() => {
    this.age++; // `this` коректно вказує на об'єкт особи
  }, 1000);
}

const p = new Person();
```

{{PreviousNext("Web/JavaScript/Guide/Loops_and_iteration", "Web/JavaScript/Guide/Expressions_and_operators")}}
