---
title: Робота з об'єктами
slug: Web/JavaScript/Guide/Working_with_Objects
tags:
  - Beginner
  - Comparing object
  - Document
  - Guide
  - JavaScript
  - Object
  - "l10n:priority"
---
{{jsSidebar("JavaScript Guide")}} {{PreviousNext("Web/JavaScript/Guide/Keyed_collections", "Web/JavaScript/Guide/Using_Classes")}}

JavaScript збудовано на основі простої, заснованої на об'єктах парадигми. Об'єкт — це колекція властивостей, а властивість — це зв'язок між назвою (або іменем чи _ключем_) та значенням. Значенням властивості може бути функція — таку властивість називають методом. Додатково до об'єктів, уже визначених в браузері, можна створювати також власні об'єкти. Ця глава описує, як використовувати об'єкти, властивості, функції й методи, та як створювати власні об'єкти.

## Огляд об'єктів

Об'єкти в JavaScript, так само як і в багатьох інших мовах програмування, можна порівняти з об'єктами в реальному житті. Ідею об'єктів у JavaScript можна розуміти на прикладі реальних, предметних матеріальних речей.

У JavaScript, об'єкт — це окрема сутність, зі властивостями й типом. Її можна порівняти зі, наприклад, чашкою. Чашка — це об'єкт, із властивостями. Чашка має колір, дизайн, масу, матеріал, з якого її зроблено тощо. Так само й об'єкти JavaScript можуть мати властивості, що визначають їхні характеристики.

## Об'єкти та властивості

Об'єкт у JavaScript має властивості, пов'язані з ним. Властивість об'єкта можна пояснити як змінну, прикріплену до об'єкта. Властивості об'єкта — практично такі самі, як і звичайні змінні в JavaScript, за винятком їхнього прикріплення до об'єктів. Властивості об'єкта визначають характеристики об'єкта. До властивостей об'єкта можна доступитися за допомогою простого запису через крапку:

```js
objectName.propertyName
```

Як і всі змінні в JavaScript, ім'я об'єкта (яке може бути звичайною змінною) та ім'я властивості — чутливі до регістра. Встановлення властивості виконується шляхом присвоєння їй якогось значення. Наприклад, створімо об'єкт під назвою `myCar`, і надамо йому властивостей, що називаються `make`, `model`, та `year`, як наведено далі:

```js
const myCar = new Object();
myCar.make = 'Форд';
myCar.model = 'Мустанг';
myCar.year = 1969;
```

Наведений вище приклад можна також переписати за допомогою **[ініціалізатора об'єкта](#initsializatory-obiektiv)**, який є обгорнутим у фігурні дужки (`{}`) списком зі нуля чи більше розділених комами пар із назви властивості й відповідного їй значення:

```js
const myCar = {
  make: 'Форд',
  model: 'Мустанг',
  year: 1969
};
```

Неприсвоєні властивості об'єкта є {{jsxref("undefined", "невизначеними")}} (а не [`null` (пустими)](/uk/docs/Web/JavaScript/Reference/Operators/null)).

```js
myCar.color; // undefined
```

До властивостей об'єктів у JavaScript також можна доступитися за допомогою квадратних дужок (більше про це у розділі про [засоби доступу до властивостей](/uk/docs/Web/JavaScript/Reference/Operators/Property_Accessors)). Об'єкти часто називають _асоціативними масивами_, адже кожна властивість прив'язана до певного рядкового значення, за допомогою якого можна звернутися до неї. Таким чином, до властивостей об'єкта `myCar` можна доступитися, наприклад, ось так:

```js
myCar['make'] = 'Форд';
myCar['model'] = 'Мустанг';
myCar['year'] = 1969;
```

Назва властивості об'єкта може бути будь-яким дійсним у JavaScript рядком, або ж будь-чим, що можна _перетворити_ на рядок, включно зі порожнім рядком. Проте, будь-яка назва властивості, яка не є дійсним ідентифікатором в JavaScript, не може бути вжита при записі через крапку. Наприклад, до назви властивості, що: містить пробіл чи дефіс, починається цифрою, чи знаходиться всередині змінної — можна звернутися лише шляхом запису через квадратні дужки. Такий запис також дуже корисний, коли назви властивостей визначаються динамічно, тобто коли їх неможливо визначити до запуску. Наприклад — як це наведено нижче:

```js
// Одразу створено чотири змінних, розділених комами,
// і присвоєно їм значення
const myObj = {},
      str = 'myString',
      rand = Math.random(),
      anotherObj = {};

// Тепер створюються додаткові властивості.
myObj.type              = 'Синтаксис із крапкою для ключа під назвою "type"';
myObj['date created']   = 'Цей ключ містить пробіл';
myObj[str]              = 'Цей ключ міститься у змінній "str"';
myObj[rand]             = 'Тут ключ — це випадкове число';
myObj[anotherObj]       = 'Цей ключ — це об\'єкт "anotherObj"';
myObj['']               = 'Цей ключ є порожнім рядком';

console.log(myObj);
console.log(myObj.myString);

/*
[Log] Object
    : "Цей ключ є порожнім рядком"
    0.8916485437228595: "Тут ключ — це випадкове число"
    [object Object]: "Цей ключ — це об'єкт \"anotherObj\""
    date created: "Цей ключ містить пробіл"
    myString: "Цей ключ міститься у змінній \"str\""
    type: "Синтаксис із крапкою для ключа під назвою \"type\""
*/

// зверніть увагу: послідовність властивостей у переліку, виведеному в консоль, не збігається з порядком, у якому їх було створено.

// [Log] Цей ключ міститься у змінній "str"
```

Імена властивостей об'єктів у JavaScript (keys) можуть бути лише рядками або символами: всі ключі, записані у квадратних дужках, буде перетворено на рядки, якщо вони не є символами. Наприклад, у наведеному вище коді, коли ключ `anotherObj` додається до `myObj`, JavaScript викликає метод {{jsxref("Object.toString", "toString()")}} об'єкта `anotherObj`, і далі використовує отриманий в результаті рядок як новий ключ.

Також можна доступатися до властивостей, використовуючи рядкове значення, збережене у змінній. Змінну слід передавати за допомогою квадратних дужок. У наведеному раніше прикладі змінна `str` містить `"myString"`, і це значення `"myString"` і є назвою властивості. А отже, `myObj.str` поверне `undefined`.

```js
str = 'myString';
myObj[str] = 'Цей ключ лежить у змінній str';

console.log(myObj.str); //[Log] undefined

console.log(myObj[str]); //[Log] Цей ключ лежить у змінній str
console.log(myObj.myString); //[Log] Цей ключ лежить у змінній str
```

Це дає змогу звертатися до будь-якої властивості, визначеної під час виконання:

```js
let propertyName = 'make';
myCar[propertyName] = 'Форд';

// шляхом зміни вмісту змінної можна звертатися до різних властивостей 
propertyName = 'model';
myCar[propertyName] = 'Мустанг';

console.log(myCar);

// [Log] {make: 'Форд', model: 'Мустанг'}
```

Можна застосовувати запис через квадратні дужки вкупі з [`for...in`](/uk/docs/Web/JavaScript/Reference/Statements/for...in) для перебирання всіх перелічуваних властивостей об'єкта. Для ілюстрації того, як це працює, нижче наведено функцію, яка показує властивості об'єкта, якщо до неї передати в аргументах сам об'єкт і його назву:

```js
function showProps(obj, objName) {
  let result = '';
  for (const i in obj) {
    // obj.hasOwn вжитий, аби пропустити властивості, взяті з прототипного ланцюжка об'єкта, та показати лише "власні властивості"
    if (Object.hasOwn(obj, i)) {
      result += `${objName}.${i} = ${obj[i]}\n`;
    }
  }
  console.log(result);
}
```

Термін "власна властивість" позначає властивості об'єкта, за винятком тих, що знаходяться в ланцюжку прототипів. Таким чином, виклик функції `showProps(myCar, 'myCar')` надрукує наступне:

```
myCar.make = Форд
myCar.model = Мустанг
myCar.year = 1969
```

## Перелічення властивостей об'єкта

Існують три нативні способи перебрати чи отримати список властивостей об'єкта:

- Цикли [`for...in`](/uk/docs/Web/JavaScript/Reference/Statements/for...in). Цей спосіб проходить по всіх перелічуваних рядкових властивостях самого об'єкта, а також його ланцюжка прототипів.
- {{jsxref("Object.keys", "Object.keys(myObj)")}}. Цей метод повертає масив, що містить лише імена власних перелічуваних властивостей (так звані "ключі") об'єкта `myObj`, проте без тих, що знаходяться в прототипному ланцюжку.
- {{jsxref("Object.getOwnPropertyNames", "Object.getOwnPropertyNames(myObj)")}}. Цей метод повертає масив, що містить рядкові імена всіх власних властивостей об'єкта `myObj`, незалежно від того, чи є вони перелічуваними, чи ні.

Не існує нативного способу отримати перелік "прихованих" властивостей (тих властивостей у прототипному ланцюжку, які недоступні через об'єкт, оскільки ближче в прототипному ланцюжку є інша властивість з ідентичним ім'ям). Проте цього можна досягти, послуговуючись наступною функцією:

```js
function listAllProperties(myObj) {
  let objectToInspect = myObj;
  let result = [];

  while(objectToInspect !== null) {
    result = result.concat(Object.getOwnPropertyNames(objectToInspect));
    objectToInspect = Object.getPrototypeOf(objectToInspect)
  }

  return result;
}
```

## Створення нових об'єктів

JavaScript має декілька заздалегідь визначених об'єктів. На додачу – можна також створювати власні об'єкти. Свої об'єкти можна створити, застосувавши [ініціалізатор об'єкта](/uk/docs/Web/JavaScript/Reference/Operators/Object_initializer). Окрім цього, можна також спершу створити функцію-конструктор, і потім реалізувати новий об'єкт шляхом звертання до функції у поєднанні з оператором `new`.

### Вживання об'єктних ініціалізаторів

Застосування ініціалізаторів об'єктів також іноді називають створенням об'єктів за допомогою літерала. Термін "об'єктний ініціалізатор" сумісний з термінологією, прийнятою в середовищі C++.

Синтаксис створення об'єкта за допомогою об'єктного ініціалізатора має такий вигляд:

```js
const obj = {
  property1: value1,   // назва властивості може бути ідентифікатором
  2: value2,   // або числом
  'property n': value3    // чи рядком
};
```

…де `obj` — це назва нового об'єкта, кожна назва властивості до двокрапки — ідентифікатор (або ім'я, або число, або рядковий літерал), та кожний `valueN` — вираз, чиє значення присвоюється назві властивості. Назва `obj` та присвоєння не є обов'язковими: немає сенсу створювати змінну, якщо немає потреби звертатися до цього об'єкта деінде. (Зауважте, що може виникнути потреба обгорнути об'єктний літерал в дужки, якщо об'єкт знаходиться в місці, де очікується вираз, аби компілятор не сприймав літерал за блокову інструкцію.)

Об'єктні ініціалізатори — це вирази, і кожний такий ініціалізатор призводить до створення нового об'єкта в місці, де виконується інструкція, до складу якої він входить. Ідентичні об'єктні ініціалізатори породжують різні об'єкти, які не будуть рівними дорівнювати одне одному під час порівняння. Об'єкти створюються так, наче було виконано виклик `new Object()`, а саме, об'єкти, отримані з виразів об'єктних літералів є примірниками `Object`.

Наступні інструкції створюють об'єкт і присвоюють його змінній `x` тоді й лише тоді, якщо вираз `cond` є істинним:

```js
let x;
if (cond) {
  x = {greeting: 'Гей там'};
}
```

Наступний приклад створює об'єкт `myHonda` з трьома властивостями. Зауважте, що властивість `engine` — це також об'єкт зі своїми власними властивостями.

```js
const myHonda = {color: 'red', wheels: 4, engine: {cylinders: 4, size: 2.2}};
```

Також за допомогою об'єктних ініціалізаторів можна створювати масиви. Більше про це в розділі [літерали масивів](/uk/docs/Web/JavaScript/Guide/Grammar_and_types#literaly-masyviv).

### Застосування функції-конструктора

Окрім цього, можна створювати об'єкти за допомогою таких двох кроків:

1. Означити тип об'єкта шляхом написання функції-конструктора. Існує загальноприйнята домовленість називати конструктори з великої літери, з гарним обґрунтуванням.
2. Створити примірник об'єкта за допомогою `new`.

Аби означити тип об'єкта, слід створити для нього функцію, яка вказує його назву, властивості та методи. Для прикладу, припустімо, що нам потрібно створити об'єктний тип для автомобілів. Нехай це тип об'єктів називатиметься `Car`, і він матиме властивості для позначення виробника, моделі та року випуску. Для виконання цього можна написати наступну функцію:

```js
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
```

Зауважте, як використовується `this` для присвоєння значень властивостям об'єкта, на основі даних, переданих до функції.

Тепер можна створити об'єкт під назвою `myCar`, як це показано нижче:

```js
const myCar = new Car('Eagle', 'Talon TSi', 1993);
```

Ця інструкція створює `myCar`, і присвоює передані значення його властивостям. Після цього значення `myCar.make` дорівнює рядку "Eagle", `myCar.model` дорівнює 'Talon TSi', а `myCar.year` — ціле число 1993, і так далі. Порядок аргументів і параметрів повинен залишатись незмінним.

Викликаючи `new`, можна створити довільну кількість об'єктів `Car`. Наприклад:

```js
const kenscar = new Car('Nissan', '300ZX', 1992);
const vpgscar = new Car('Mazda', 'Miata', 1990);
```

Об'єкт може містити властивість, яка сама є іншим об'єктом. Наприклад, припустімо, що нам потрібно означити об'єкт під назвою `Person`, як це показано нижче:

```js
function Person(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
}
```

…далі реалізуємо два нових об'єкти `Person`:

```js
const rand = new Person('Rand McKinnon', 33, 'M');
const ken = new Person('Ken Jones', 39, 'M');
```

Потім перепишемо означення типу `Car` так, щоб воно містило властивість `owner`, яка приймає об'єкт `Person`, як наведено далі:

```js
function Car(make, model, year, owner) {
  this.make = make;
  this.model = model;
  this.year = year;
  this.owner = owner;
}
```

Далі реалізуймо нові об'єкти за допомогою наступного коду:

```js
const car1 = new Car('Eagle', 'Talon TSi', 1993, rand);
const car2 = new Car('Nissan', '300ZX', 1992, ken);
```

Зауважте, як замість передачі буквально рядка чи цілого числа під час створення нових об'єктів, наведені вище інструкції передають об'єкти `rand` та `ken` як аргументи для позначення власника авто. Далі, за потреби взнати ім'я власника автомобіля `car2`, можна доступитися до наступної властивості:

```js
car2.owner.name
```

Слід зазначити, що завжди можна додати до створеного раніше об'єкта нову властивість. Наприклад, така інструкція

```js
car1.color = 'black';
```

…додає властивість `color` до об'єкта `car1`, і присвоює їй значення `'black'`. Проте це ніяк не впливає на інші об'єкти. Аби додати нову властивість до всіх об'єктів певного типу, доведеться додати цю властивість до означення об'єкта типу `Car`.

### Застосування метода `Object.create`

Також можна створювати об'єкти шляхом застосування методу {{jsxref("Object.create()")}}. Цей метод може бути дуже корисним, адже він дає можливість вказати прототип для об'єкта, який створюється, без необхідності оголошувати окрему функцію-конструктор.

```js
// Об'єкт тварини Animal, зі своїми властивостями та інкапсульованим методом
const Animal = {
  type: 'Безхребетні', // Усталене значення властивості
  displayType() {  // Метод, що виводитиме тип тварини
    console.log(this.type);
  }
};

// Створюється новий тип тварини під назвою animal1
const animal1 = Object.create(Animal);
animal1.displayType(); // Вивід: Безхребетні

// Створюється новий тип тварини під назвою fish
const fish = Object.create(Animal);
fish.type = 'Риби';
fish.displayType(); // Вивід: Риби
```

## Успадкування

Всі об'єкти в JavaScript успадковують властивість від принаймні одного іншого об'єкта. Об'єкт, від якого успадковуються властивості, називається прототипом, а знайти успадковані властивості можна в об'єкті `prototype` конструктора. Докладніше про це в розділі [Успадкування та ланцюжок прототипів](/uk/docs/Web/JavaScript/Inheritance_and_the_prototype_chain).

## Індексування властивостей об'єкта

До властивості об'єкта можна звернутися або за її іменем, або за порядковим номером — індексом. Якщо вперше означити властивість за її іменем — то звертатися до неї слід за цим іменем, і якщо властивість була означена за індексом — доведеться звертатися до неї саме за індексом.

Це обмеження діє, коли об'єкт із властивостями створюється за допомогою конструктора (як це було показано раніше, на об'єктах типу `Car`), і коли кожна окрема властивість означається явно (наприклад — `myCar.color = 'red'`). Якщо вперше означити властивість об'єкта за індексом, як от `myCar[5] = '25 mpg'` — надалі звертатися до властивості можна буде лише так: `myCar[5]`.

Винятком з цього правила є подібні до масивів об'єкти — похідні з HTML, такі як об'єкт `document.forms`. До елементів у таких масивоподібних об'єктах можна звертатися або за їхнім порядковим номером (який ґрунтується на тому, в якій послідовності вони знаходяться в документі), або за їхнім ім'ям (якщо воно вказане). Наприклад, якщо другий тег `<form>` в документі має атрибут `name="myForm"`, до нього можна звернутися або за допомогою `document.forms[1]`, або `document.forms['myForm']` чи `document.forms.myForm`.

## Означення властивостей об'єктного типу

До раніше означеного об'єктного типу можна додати нову властивість, використавши властивість `prototype`. У такий спосіб додається властивість, яку поділяють всі об'єкти вказаного типу, а не лише один його примірник. Наведений нижче код додає властивість `color` до всіх об'єктів типу `Car`, і далі присвоює значення властивості `color` об'єкта `car1`.

```js
Car.prototype.color = null;
car1.color = 'black';
```

Докладніше про це в розділі [Успадкування та ланцюжок прототипів](/uk/docs/Web/JavaScript/Inheritance_and_the_prototype_chain).

## Означення методів

_Метод_ — це функція, асоційована з певним об'єктом. Іншими словами, метод — це така властивість об'єкта, яка є функцією. Означення методів відбувається так само, як і означення звичайних функцій, за винятком того, що вони повинні присвоюватися властивостям об'єкта. Докладніше про це в розділі [означення методів](/uk/docs/Web/JavaScript/Reference/Functions/Method_definitions). Наприклад:

```js
objectName.methodName = functionName;

const myObj = {
  myMethod: function(params) {
    // щось робить
  },

  // Це також працює!
  myOtherMethod(params) {
    // робить щось інше
  }
};
```

…де `objectName` — це наявний об'єкт, `methodName` — ім'я, присвоєне методові, а `functionName` — ідентифікатор вже наявної функції.

Далі можна викликати цей метод в контексті об'єкта, як показано нижче:

```js
object.methodName(params);
```

Також можна означити метод для всього об'єктного типу, додавши таке означення у конструкторі об'єкта. Наприклад, можна додати визначення функції, яка б форматувала і показувала властивості означених раніше об'єктів `Car`:

```js
function displayCar() {
  const result = `Чудова ${this.model} від ${this.make}, ${this.year} року випуску`;
  prettyPrint(result);
}
```

…де `prettyPrint` — це функція для виведення горизонтальної лінії з рядком тексту. Зауважте, як використано `this` для звернення до об'єкта, якому належить метод.

Цю функцію можна зробити методом об'єкта `Car`, додавши таку інструкцію до означення об'єкта:

```js
this.displayCar = displayCar;
```

Таким чином, повне означення об'єкта `Car` зараз мало б такий вигляд:

```js
function Car(make, model, year, owner) {
  this.make = make;
  this.model = model;
  this.year = year;
  this.owner = owner;
  this.displayCar = displayCar;
}
```

Після цього можна викликати метод `displayCar` на кожному з об'єктів, ось так:

```js
car1.displayCar();
car2.displayCar();
```

## Застосування `this` для вказівки на об'єкт

JavaScript містить особливе ключове слово [`this`](/uk/docs/Web/JavaScript/Reference/Operators/this), яке можна вживати всередині метода для вказівки на поточний об'єкт. Наприклад, припустімо, є два об'єкти, `Manager` та `Intern`. Кожний з об'єктів має свої властивості `name`, `age` та `job`. Всередині функції `sayHi()`, зверніть увагу, є конструкція `this.name`. Щойно додана до цих двох об'єктів, ця функція може бути викликатись і друкувати рядок `'Привіт, мене звати'`, куди додається значення властивості `name` з відповідного об'єкта. Так, як це показано нижче:

```js
const Manager = {
  name: "Іван",
  age: 27,
  job: "Розробник програмного забезпечення"
}
const Intern = {
  name: "Олег",
  age: 21,
  job: "Розробник програмного забезпечення — інтерн"
}

function sayHi() {
  console.log(`Привіт, мене звати ${this.name}`)
}

// додаємо функцію sayHi до обох об'єктів
Manager.sayHi = sayHi;
Intern.sayHi = sayHi;

Manager.sayHi(); // Привіт, мене звати Іван
Intern.sayHi(); // Привіт, мене звати Олег
```

Тут `this` посилається на об'єкт, в контексті якого його вжито. Можна створити нову функцію під назвою `howOldAmI()`, що друкує речення, яке каже, скільки особі років.

```js
function howOldAmI() {
  console.log(`Мені ${this.age} років.`);
}
Manager.howOldAmI = howOldAmI;
Manager.howOldAmI(); // Мені 27 років.
```

## Означення гетерів та сетерів

[Гетер](/uk/docs/Web/JavaScript/Reference/Functions/get) (від _get_ — отримати) — це метод, який отримує значення певної властивості. А [сетер](/uk/docs/Web/JavaScript/Reference/Functions/set) (від _set_ — встановити) — метод, який, відповідно, встановлює значення певної властивості. Можна визначати гетери й сетери на будь-якому вбудованому об'єкті, чи на означеному користувачем об'єкті, якщо такі об'єкти допускають додавання нових властивостей.

Гетери й сетери можуть бути:

- або означені всередині [об'єктних ініціалізаторів](#initsializatory-obiektiv),
- або будь-коли пізніше додані до будь-якого об'єкта за допомогою метода для додавання гетера чи сетера.

Все, що потрібно зробити, аби додати гетер чи сетер через [об'єктний ініціалізатор](#initsializatory-obiektiv) — це вказати перед методом гетера префікс `get`, а перед сетером, відповідно, — `set`. Звісно, метод гетера не повинен приймати вхідних параметрів, тоді як метод сетера повинен очікувати на один і лише один параметр (нове значення для встановлення). Приміром:

```js
const myObj = {
  a: 7,
  get b() {
    return this.a + 1;
  },
  set c(x) {
    this.a = x / 2;
  }
};

console.log(myObj.a); // 7
console.log(myObj.b); // 8 <-- Ось тут починає діяти метод гетера b().
myObj.c = 50;         //   <-- А тут діє метод сетера c(x)
console.log(myObj.a); // 25
```

Об'єкт `myObj` містить такі властивості:

- `myObj.a` — число
- `myObj.b` — гетер, який додає 1 до значення `myObj.a` і повертає результат
- `myObj.c` — сетер, який встановлює значенням `myObj.a` половину того числа, яке присвоюється до `myObj.c`

Зауважте, що ті назви функцій гетерів і сетерів, які означаються всередині об'єктного літерала за допомогою "\[gs]et _property_()", самі не є назвами гетерів, навіть якщо синтаксис `[gs]et propertyName(){ }` може вказувати на протилежне.

Також можна додавати гетери й сетери до об'єкта будь-коли після його створення, за допомогою методу {{jsxref("Object.defineProperties()")}}. Перший параметр цього методу — це об'єкт, на якому потрібно додати гетер чи сетер. Другий параметр - це об'єкт, чиї імена властивостей є назвами гетерів чи сетерів, а значення властивостей містять об'єкти з означенням функції гетера чи сетера. Ось приклад, як можна означити такі само гетер і сетер, які було вжито в попередньому прикладі:

```js
const myObj = { a: 0 };

Object.defineProperties(myObj, {
  b: { get() { return this.a + 1; } },
  c: { set(x) { this.a = x / 2; } },
});

myObj.c = 10; // Запускає сетер, який присвоює властивості 'a' значення 10 / 2 (5)
console.log(myObj.b); // Запускає гетер, який віддає a + 1, тобто 6
```

Яку з цих двох форм обрати — залежить від стилю програмування та конкретного завдання під руками. Якщо для означення прототипу вже використано об'єктний ініціалізатор — скоріш за все, варто обрати першу форму. Ця форма компактніша і дещо природніша. Проте, якщо потрібно додати гетери й сетери постфактум, оскільки не ми писали прототип, чи конкретний об'єкт — єдиним варіантом залишається друга форма. Друга форма, ймовірно, найкраще ілюструє динамічну природу JavaScript — хоча це може робити код складнішим для прочитання і розуміння.

## Видалення властивостей

Неуспадковану властивість можна видалити шляхом використання оператора [`delete`](/uk/docs/Web/JavaScript/Reference/Operators/delete). Наступний код ілюструє, як видалити властивість:

```js
// Створюється новий об'єкт myobj, із двома властивостями a та b.
const myobj = new Object();
myobj.a = 5;
myobj.b = 12;

// Видаляється властивість a, залишаючи об'єкт myobj із самою лише властивістю b.
delete myobj.a;
console.log ('a' in myobj); // виводить: "false"
```

## Порівняння об'єктів

Об'єкти в JavaScript є посилальним типом. Два окремі об'єкти ніколи не будуть рівними, навіть якщо вони мають ідентичні властивості. Істинним буде лише порівняння об'єкта із самим собою.

```js
// Дві змінні, два окремі об'єкти з однаковими властивостями
const fruit = {name: 'apple'};
const fruitbear = {name: 'apple'};

fruit == fruitbear; // повертає false
fruit === fruitbear; // повертає false
```

```js
// Дві змінні, єдиний об'єкт
const fruit = {name: 'apple'};
const fruitbear = fruit;  // До fruitbear присвоюється посилання об'єкта fruit

// Тут fruit та fruitbear вказують на один об'єкт
fruit == fruitbear; // повертає true
fruit === fruitbear; // повертає true

fruit.name = 'grape';
console.log(fruitbear); // вивід: { name: "grape" }, замість { name: "apple" }
```

Більше інформації про оператори порівняння можна знайти у розділі [операторів рівності](/uk/docs/Web/JavaScript/Reference/Operators#operatory-rivnosti).

## Дивіться також

- Для заглиблення в тему прочитайте про [Успадкування та ланцюжок прототипів](/uk/docs/Web/JavaScript/Inheritance_and_the_prototype_chain).
- Більше інформації про класи (інший спосіб створення об'єктів) є в довіднику [Класи JavaScript](/uk/docs/Web/JavaScript/Reference/Classes).

{{PreviousNext("Web/JavaScript/Guide/Regular_Expressions", "Web/JavaScript/Guide/Using_Classes")}}
