---
title: Вирази та оператори
slug: Web/JavaScript/Guide/Expressions_and_operators
page-type: guide
---

{{jsSidebar("JavaScript Guide")}} {{PreviousNext("Web/JavaScript/Guide/Functions", "Web/JavaScript/Guide/Numbers_and_dates")}}

Цей розділ описує вирази та оператори JavaScript, включно з операторами присвоєння, порівняння, арифметичними, бітовими, логічними, рядковими, тернарним і так далі.

На високому рівні, _вираз_ – це дійсна одиниця коду, що обчислюється до значення. Є два типи виразів: ті, котрі мають побічні ефекти (як то присвоєння значень), і ті, котрі суто _обчислюються_.

Вираз `x = 7` є прикладом першого типу. Цей вираз вживає _оператор_ `=` для присвоєння змінній `x` значення семи. Сам вираз обчислюється в `7`.

Вираз `3 + 4` є прикладом другого типу. Цей вираз вживає оператор `+` для додавання `3` і `4` докупи й вироблення значення `7`. Проте якщо такий вираз не є частиною більшої конструкції (наприклад, [оголошення змінної](/uk/docs/Web/JavaScript/Guide/Grammar_and_types#oholoshennia) виду `const z = 3 + 4`), то його результат буде негайно відкинутий; зазвичай це буває помилкою програміста, адже обчислення не виробляє жодних ефектів.

Як показують приклади вище, усі складні вирази об'єднуються _операторами_, як то `=` і `+`. У цій частині – знайомство з наступними операторами:

- [Оператори присвоєння](#operatory-prysvoiennia)
- [Оператори порівняння](#operatory-porivniannia)
- [Арифметичні оператори](#aryfmetychni-operatory)
- [Бітові оператори](#bitovi-operatory)
- [Логічні оператори](#lohichni-operatory)
- [Оператори BigInt](#operatory-bigint)
- [Рядкові оператори](#riadkovi-operatory)
- [Умовний (тернарний) оператор](#umovnyi-ternarnyi-operator)
- [Оператор коми](#operator-komy)
- [Унарні оператори](#unarni-operatory)
- [Оператори відношення](#operatory-vidnoshennia)

Ці оператори об'єднують операнди, котрі або сформовані операторами вищого пріоритету, або одним із [базових виразів](#bazovi-vyrazy). Повний і розгорнутий список операторів та виразів доступний також у [довіднику](/uk/docs/Web/JavaScript/Reference/Operators).

_Пріоритет_ операторів визначає порядок, в якому вони застосовуються при обчисленні виразу. Наприклад:

```js
const x = 1 + 2 * 3;
const y = 2 * 3 + 1;
```

Попри те, що `*` і `+` зустрічаються в різному порядку, обидва вирази дадуть `7`, тому що `*` має пріоритет над `+`, тож поєднаний `*` вираз завжди буде обчислений першим. Пріоритет операторів можна відкинути за допомогою дужок (що утворює [згрупований вираз](#operator-hrupuvannia) — один з базових виразів). Повну таблицю пріоритетів операторів, а також різні каверзи – шукайте на сторінці [Довідки пріоритету операторів](/uk/docs/Web/JavaScript/Reference/Operators/Operator_precedence#tablytsia).

JavaScript має і _бінарні_, і _унарні_ оператори, а також один особливий тернарний оператор – умовний оператор.
Бінарний оператор вимагає двох операндів, одного перед оператором і одного після:

```plain
operand1 operator operand2
```

Наприклад, `3 + 4` або `x * y`. Така форма зветься _інфіксним_ бінарним оператором, тому що оператор розміщений між двома операндами. Усі бінарні оператори в JavaScript є інфіксними.

Унарні оператори вимагають одного операнда – або перед, або після оператора:

```plain
operator operand
operand operator
```

Наприклад, `x++` або `++x`. Форма `operator operand` зветься _префіксним_ унарним оператором, а форма `operand operator` – _постфіксним_ унарним оператором. `++` і `--` – єдині постфіксні оператори в JavaScript; уся решта операторів, як то `!`, `typeof` тощо, – є префіксними.

## Оператори присвоєння

Оператор присвоєння присвоює значення своєму лівому операндові на основі значення правого операнда. Простий оператор присвоєння – це знак дорівнює(`=`), він присвоює значення свого правого операнда лівому операндові.
Тобто `x = f()` – це вираз присвоєння, котрий присвоює значення `f()` змінній `x`.

Крім нього, є складені оператори присвоєння, котрі є скороченнями операцій, перелічених у наступній таблиці:

| Назва                                                                                                                 | Оператор-скорочення | Значення           |
| --------------------------------------------------------------------------------------------------------------------- | ------------------- | ------------------ |
| [Присвоєння](/uk/docs/Web/JavaScript/Reference/Operators/Assignment)                                                  | `x = f()`           | `x = f()`          |
| [Присвоєння з додаванням](/uk/docs/Web/JavaScript/Reference/Operators/Addition_assignment)                            | `x += f()`          | `x = x + f()`      |
| [Присвоєння з відніманням](/uk/docs/Web/JavaScript/Reference/Operators/Subtraction_assignment)                        | `x -= f()`          | `x = x - f()`      |
| [Присвоєння з множенням](/uk/docs/Web/JavaScript/Reference/Operators/Multiplication_assignment)                       | `x *= f()`          | `x = x * f()`      |
| [Присвоєння з діленням](/uk/docs/Web/JavaScript/Reference/Operators/Division_assignment)                              | `x /= f()`          | `x = x / f()`      |
| [Присвоєння зі взяттям остачі від ділення](/uk/docs/Web/JavaScript/Reference/Operators/Remainder_assignment)          | `x %= f()`          | `x = x % f()`      |
| [Присвоєння з піднесенням до степеня](/uk/docs/Web/JavaScript/Reference/Operators/Exponentiation_assignment)          | `x **= f()`         | `x = x ** f()`     |
| [Присвоєння зі зсувом уліво](/uk/docs/Web/JavaScript/Reference/Operators/Left_shift_assignment)                       | `x <<= f()`         | `x = x << f()`     |
| [Присвоєння зі зсувом управо](/uk/docs/Web/JavaScript/Reference/Operators/Right_shift_assignment)                     | `x >>= f()`         | `x = x >> f()`     |
| [Присвоєння з беззнаковим зсувом управо](/uk/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift_assignment) | `x >>>= f()`        | `x = x >>> f()`    |
| [Присвоєння з бітовою кон'юнкцією](/uk/docs/Web/JavaScript/Reference/Operators/Bitwise_AND_assignment)                | `x &= f()`          | `x = x & f()`      |
| [Присвоєння з бітовою виключною диз'юнкцією](/uk/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR_assignment)      | `x ^= f()`          | `x = x ^ f()`      |
| [Присвоєння з бітовою диз'юнкцією](/uk/docs/Web/JavaScript/Reference/Operators/Bitwise_OR_assignment)                 | `x \|= f()`         | `x = x \| f()`     |
| [Присвоєння з логічною кон'юнкцією](/uk/docs/Web/JavaScript/Reference/Operators/Logical_AND_assignment)               | `x &&= f()`         | `x && (x = f())`   |
| [Присвоєння з логічною диз'юнкцією](/uk/docs/Web/JavaScript/Reference/Operators/Logical_OR_assignment)                | `x \|\|= f()`       | `x \|\| (x = f())` |
| [Присвоєння з null-злиттям](/uk/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_assignment)                | `x ??= f()`         | `x ?? (x = f())`   |

### Присвоєння властивостям

Якщо вираз обчислюється до [об'єкта](/uk/docs/Web/JavaScript/Guide/Working_with_objects), то ліва сторона виразу присвоєння може виконувати присвоєння властивостям цього виразу.
Наприклад:

```js
const obj = {};

obj.x = 3;
console.log(obj.x); // Виводить 3.
console.log(obj); // Виводить { x: 3 }.

const key = "y";
obj[key] = 5;
console.log(obj[key]); // Виводить 5.
console.log(obj); // Виводить { x: 3, y: 5 }.
```

Більше інформації про об'єкти – в [Роботі з об'єктами](/uk/docs/Web/JavaScript/Guide/Working_with_objects).

Якщо вираз не обчислюється до об'єкта, то присвоєння властивостям такого виразу – не виконуються.

```js
const val = 0;
val.x = 3;

console.log(val.x); // Виводить undefined.
console.log(val); // Виводить 0.
```

У [суворому режимі](/uk/docs/Web/JavaScript/Reference/Strict_mode#vykydannia-pomylok) код вище викидає помилку, тому що не можна присвоювати властивості примітивам.

Є помилкою присвоєння значень незмінним властивостям або властивостям виразів без властивостей (`null` і `undefined`).

### Деструктурування

Корисний для складних присвоєнь синтаксис [присвоєння з деструктуруванням](/uk/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) – це вираз JavaScript, котрий дає змогу видобути дані з масивів та об'єктів за допомогою синтаксису, котрий є дзеркальним відображенням конструювання масивів та об'єктних літералів.

Без деструктурування для видобуття з масивів і об'єктів кількох значень необхідні кілька інструкцій:

```js
const foo = ["один", "два", "три"];

// без деструктурування
const one = foo[0];
const two = foo[1];
const three = foo[2];
```

Завдяки деструктуруванню можна видобувати кілька значень в окремі змінні за допомогою однієї інструкції:

```js
const [one, two, three] = foo;
```

### Обчислення та вкладеність

Загалом, присвоєння вживаються в межах оголошень змінних (тобто вкупі з [`const`][], [`let`][] чи [`var`][]) або ж як окремі інструкції).

```js
// Оголошується змінна x, а потім ініціалізується результатом f().
// Результат виразу присвоєння x = f() – відкидається.
let x = f();

x = g(); // Повторно присвоює змінній x результат g().
```

[`const`]: /uk/docs/Web/JavaScript/Reference/Statements/const
[`let`]: /uk/docs/Web/JavaScript/Reference/Statements/let
[`var`]: /uk/docs/Web/JavaScript/Reference/Statements/var

А проте, подібно до інших виразів, вирази присвоєння виду `x = f()` обчислюються до значення результату. Хоч зазвичай цей результат не використовується, він може бути використаний іншим виразом.

Утворення ланцюжків присвоєнь або присвоєнь, вкладених в інші вирази, може призвести до неочікуваної поведінки. Через це частина посібників зі стилю JavaScript коду [не радить утворювати з присвоєнь ланцюжки або вкладеність](https://github.com/airbnb/javascript/blob/master/readme.md#variables--no-chain-assignment).
Попри це, іноді ланцюжки та вкладеність присвоєнь можуть траплятися, тому важливо розуміти, як вони працюють.

При додаванні присвоєння в ланцюжок або вкладеність, результат такого присвоєння сам може бути присвоєний іншій змінній. Він може бути виведений, вписаний в літерал масиву або виклик функції, і так далі.

```js-nolint
let x;
const y = (x = f()); // Або рівносильне: const y = x = f();
console.log(y); // Виводить повернене значення присвоєння x = f().

console.log(x = f()); // Безпосередньо виводить повернене значення.

// Вираз присвоєння може бути вкладений в будь-якому місці,
// в якому вирази загалом дозволені,
// як то елементи літералів масивів або аргументи викликів функцій.
console.log([0, x = f(), 0]);
console.log(f(0, x = f(), 0));
```

Результат обчислення відповідає виразові справа від знака `=` у колонці "Значення" таблиці вище. Це означає, що `x = f()` обчислюється в те, чим є результат `f()`, `x += f()` обчислюється в суму `x + f()`, `x **= f()` обчислюється в піднесення до степеня `x ** f()`, і так далі.

Що до логічних присвоєнь, `x &&= f()`, `x ||= f()` і `x ??= f()`, то повернене значення – значення логічної операції без присвоєння, тобто `x && f()`, `x || f()` та `x ?? f()` відповідно.

При утворенні ланцюжків з таких виразів без дужок, або інакшого групування операторів – наприклад, в літералах масивів, вирази присвоєння **групуються справа наліво** (вони мають [праву асоціативність](https://en.wikipedia.org/wiki/Operator_associativity)), але **обчислюються зліва направо**.

Зверніть увагу на те, що для всіх операторів присвоєння, крім самого `=`, результівне значення – завжди засноване на значеннях операндів _до_ операції.

Наприклад, оголошені такі функції – `f` і `g`, а також змінні `x` та `y`:

```js
function f() {
  console.log("F!");
  return 2;
}
function g() {
  console.log("G!");
  return 3;
}
let x, y;
```

Погляньте на ці три приклади:

```js-nolint
y = x = f();
y = [f(), x = g()];
x[f()] = g();
```

#### Приклад обчислення №1

Запис `y = x = f()` – рівносильний щодо `y = (x = f())`, адже оператор присвоєння `=` має [праву асоціативність](https://en.wikipedia.org/wiki/Operator_associativity).
Проте обчислюється він зліва направо:

1. Починається обчислення виразу присвоєння `y = x = f()`.
   1. `y` зліва цього присвоєння обчислюється в посилання на змінну `y`.
   2. Починається обчислення виразу `x = f()`.
      1. `x` зліва цього присвоєння обчислюється в посилання на змінну `x`.
      2. Виклик функції `f()` виводить у консоль "F!", а тоді обчислюється в число `2`.
      3. Цей результат `2` з `f()` – присвоюється `x`.
   3. Вираз присвоєння `x = f()` завершив виконання; його результат став новим значенням `x`, а саме – `2`.
   4. Цей результат `2` й собі присвоюється `y`.
2. Вираз присвоєння `y = x = f()` завершив виконання; його результат став новим значенням `y` – котре виявилося `2`. `x` і `y` присвоєно значення `2`, а консоль вивела "F!".

#### Приклад обчислення №2

`y = [ f(), x = g() ]` так само обчислюється зліва направо:

1. Починається обчислення виразу присвоєння `y = [ f(), x = g() ]`.
   1. `y` зліва цього присвоєння обчислюється в посилання на змінну `y`.
   2. Починається обчислення вбудованого літерала масиву `[ f(), x = g() ]`.
      1. Виклик функції `f()` виводить у консоль "F!", а тоді обчислюється в число `2`.
      2. Починається обчислення виразу присвоєння `x = g()`.
         1. `x` зліва цього присвоєння обчислюється в посилання на змінну `x`.
         2. Виклик функції `g()` виводить у консоль "G!" , а тоді обчислюється в число `3`.
         3. Цей результат `3` з `g()` – присвоюється `x`.
      3. Вираз присвоєння `x = g()` завершив виконання; його результат став новим значенням `x`, а саме – `3`. Це результівне `3` стає новим елементом вбудованого літерала масиву (після `2` з `f()`).
   3. Вбудований літерал масиву `[ f(), x = g() ]` завершив виконання; його результат – масив з двома значеннями: `[ 2, 3 ]`.
   4. Цей масив `[ 2, 3 ]` присвоюється `y`.
2. Вираз присвоєння `y = [ f(), x = g() ]` завершив виконання; його результат стає новим значенням `y` – котре виявилося `[ 2, 3 ]`. Таким чином, `x` присвоєно `3`, `y` присвоєно `[ 2, 3 ]`, а консоль вивела "F!", а потім "G!".

#### Приклад обчислення №3

Вираз `x[f()] = g()` так само обчислюється зліва направо. (Цей приклад виходить з припущення, що `x` уже присвоєний якийсь об'єкт. Більше про об'єкти читайте в [Роботі з об'єктами](/uk/docs/Web/JavaScript/Guide/Working_with_objects).)

1. Починається обчислення виразу `x[f()] = g()`.
   1. Починається обчислення звертання до властивості `x[f()]` зліва цього присвоєння.
      1. `x` у цьому звертанні до властивості обчислюється в посилання на змінну `x`.
      2. Потім виклик функції `f()` виводить "F!" у консоль і обчислюється в число `2`.
   2. Звертання до властивості `x[f()]` у цьому присвоєнні завершує виконання; його результатом є посилання на змінну властивість: `x[2]`.
   3. Потім виклик функції `g()` виводить "G!" у консоль, а тоді обчислюється в число `3`.
   4. Тепер `3` присвоюється `x[2]`. (Цей крок має успіх лише за умови того, що `x` присвоєно [об'єкт](/uk/docs/Web/JavaScript/Guide/Working_with_objects).)
2. Вираз присвоєння `x[f()] = g()` завершує виконання; його результатом є нове значення `x[2]`, а саме – `3`. Тепер `x[2]` присвоєно `3`, а консоль вивела "F!", і потім – "G!".

### Слід уникати ланцюжків присвоєння

Ланцюжки присвоєнь і вкладання присвоєнь в інші вирази можуть призводити до дивної поведінки. Через це [заведено уникати ланцюжків присвоєння в межах однієї інструкції](https://github.com/airbnb/javascript/blob/master/readme.md#variables--no-chain-assignment).

Якщо конкретніше, то постановка ланцюжка змінних в інструкціях [`const`][], [`let`][] і [`var`][] нерідко _не_ працює. Лише зовнішня (найлівіша) змінна оголошується; решта змінних в межах такого ланцюжка присвоєння _не_ оголошуються інструкцією `const`, `let` чи `var`.
Наприклад:

```js-nolint
const z = y = x = f();
```

Ця інструкція нібито оголошує змінні `x`, `y` і `z`.
Проте фактично вона оголошує лише `z`.
`y` і `x` є або недійсними посиланнями на відсутні змінні (в [суворому режимі](/uk/docs/Web/JavaScript/Reference/Strict_mode)) або, що іще гірше, призводять до неявного створення [глобальних змінних](/uk/docs/Glossary/Global_variable) `x` і `y`, коли в [недбалому режимі](/uk/docs/Glossary/Sloppy_mode).

## Оператори порівняння

Оператор порівняння порівнює свої операнди й повертає логічне значення, засноване на тому, чи є істинним порівняння.
Операнди можуть бути числовими, рядковими, логічними або [об'єктними](/uk/docs/Web/JavaScript/Guide/Working_with_objects) значеннями.
Рядки порівнюються на основі стандартного лексикографічного порядку, за допомогою значень Unicode.
У більшості випадків, якщо два операнди мають різні типи, то JavaScript намагається перетворити їх до відповідного типу задля порівняння.
Ця поведінка загалом призводить до числового порівняння операндів.
Єдиний виняток щодо перетворень типів при порівнянні включає оператори `===` і `!==`, які виконують порівняння строгої рівності й строгої нерівності.
Ці оператори не намагаються перетворити операнди до сумісних типів перед їх порівнянням.
Наступна таблиця описує оператори порівняння відносно такого коду:

```js
const var1 = 3;
const var2 = 4;
```

<table class="standard-table">
  <caption>
    Оператори порівняння
  </caption>
  <thead>
    <tr>
      <th scope="col">Оператор</th>
      <th scope="col">Опис</th>
      <th scope="col">Приклади, що повертають true</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href="/uk/docs/Web/JavaScript/Reference/Operators/Equality">Рівності</a> (<code>==</code>)
      </td>
      <td>Повертає <code>true</code>, якщо операнди дорівнюють одне одному.</td>
      <td>
        <code>3 == var1</code>
        <p><code>"3" == var1</code></p>
        <code>3 == '3'</code>
      </td>
    </tr>
    <tr>
      <td>
        <a href="/uk/docs/Web/JavaScript/Reference/Operators/Inequality">Нерівності</a> (<code>!=</code>)
      </td>
      <td>Повертає <code>true</code>, якщо операнди не дорівнюють одне одному.</td>
      <td>
        <code>var1 != 4<br />var2 != "3"</code>
      </td>
    </tr>
    <tr>
      <td>
        <a href="/uk/docs/Web/JavaScript/Reference/Operators/Strict_equality">Строгої рівності</a> (<code>===</code>)
      </td>
      <td>
        Повертає <code>true</code>, якщо операнди дорівнюють одне одному й мають один і той же тип. Дивіться також {{jsxref("Object.is")}} і <a href="/uk/docs/Web/JavaScript/Equality_comparisons_and_sameness">тотожність у JS</a>.
      </td>
      <td><code>3 === var1</code></td>
    </tr>
    <tr>
      <td>
        <a href="/uk/docs/Web/JavaScript/Reference/Operators/Strict_inequality">Строгої нерівності</a> (<code>!==</code>)
      </td>
      <td>
        Повертає <code>true</code>, якщо операнди належать до одного типу, але не дорівнюють одне одному, або належать до різних типів.
      </td>
      <td>
        <code>var1 !== "3"<br />3 !== '3'</code>
      </td>
    </tr>
    <tr>
      <td>
        <a href="/uk/docs/Web/JavaScript/Reference/Operators/Greater_than">Більше</a> (<code>></code>)
      </td>
      <td>
        Повертає <code>true</code>, якщо лівий операнд більший за правий.
      </td>
      <td>
        <code>var2 > var1<br />"12" > 2</code>
      </td>
    </tr>
    <tr>
      <td>
        <a href="/uk/docs/Web/JavaScript/Reference/Operators/Greater_than_or_equal">Більше або дорівнює</a>
        (<code>>=</code>)
      </td>
      <td>
        Повертає <code>true</code>, якщо лівий операнд більший або дорівнює правому.
      </td>
      <td>
        <code>var2 >= var1<br />var1 >= 3</code>
      </td>
    </tr>
    <tr>
      <td>
        <a href="/uk/docs/Web/JavaScript/Reference/Operators/Less_than">Менше</a>
        (<code>&#x3C;</code>)
      </td>
      <td>
        Повертає <code>true</code>, якщо лівий операнд менший за правий.
      </td>
      <td>
        <code>var1 &#x3C; var2<br />"2" &#x3C; 12</code>
      </td>
    </tr>
    <tr>
      <td>
        <a href="/uk/docs/Web/JavaScript/Reference/Operators/Less_than_or_equal">Менше або дорівнює</a>
        (<code>&#x3C;=</code>)
      </td>
      <td>
        Повертає <code>true</code>, якщо лівий операнд менший або дорівнює правому.
      </td>
      <td>
        <code>var1 &#x3C;= var2<br />var2 &#x3C;= 5</code>
      </td>
    </tr>
  </tbody>
</table>

> **Примітка:** `=>` – це не оператор порівняння, а запис у [стрілкових функціях](/uk/docs/Web/JavaScript/Reference/Functions/Arrow_functions).

## Арифметичні оператори

Арифметичні оператори приймають як операнди числові значення (або літерали, або змінні), а повертають – єдине числове значення.
Стандартні арифметичні операції – це додавання (`+`), віднімання (`-`), множення (`*`) та ділення (`/`).
Ці оператори працюють так, як і в більшості решти мов програмування, коли застосовуються до дробових чисел (а саме, зверніть увагу на те, що ділення на нуль повертає {{jsxref("Infinity", "нескінченність")}}). Наприклад:

```js
1 / 2; // 0.5
1 / 2 === 1.0 / 2.0; // це істинно
```

На додачу до стандартних арифметичних операцій (`+`, `-`, `*`, `/`), JavaScript пропонує арифметичні операції, перелічені в наступній таблиці:

<table class="fullwidth-table">
  <caption>
    Арифметичні операції
  </caption>
  <thead>
    <tr>
      <th scope="col">Оператор</th>
      <th scope="col">Опис</th>
      <th scope="col">Приклад</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href="/uk/docs/Web/JavaScript/Reference/Operators/Remainder">Остача від ділення</a> (<code>%</code>)
      </td>
      <td>
        Бінарний оператор. Повертає ціле число, котре є остачею від ділення двох операндів.
      </td>
      <td>12 % 5 returns 2.</td>
    </tr>
    <tr>
      <td>
        <a href="/uk/docs/Web/JavaScript/Reference/Operators/Increment">Інкремент</a> (<code>++</code>)
      </td>
      <td>
        Унарний оператор. Додає до свого операнда одиницю. Бувши вжитим як префіксний оператор
        (<code>++x</code>), повертає значення свого операнда після додавання одиниці, а якщо як постфіксний (<code>x++</code>), то до додавання одиниці.
      </td>
      <td>
        Якщо <code>x</code> має значення 3, то <code>++x</code> присвоює <code>x</code> значення 4 і повертає 4, натомість <code>x++</code> повертає 3, і лише після цього присвоює <code>x</code> значення 4.
      </td>
    </tr>
    <tr>
      <td>
        <a href="/uk/docs/Web/JavaScript/Reference/Operators/Decrement">Декремент</a> (<code>--</code>)
      </td>
      <td>
        Унарний оператор. Віднімає від свого операнда одиницю. Повернене значення – аналогічне до поверненого значення оператора інкременту.
      </td>
      <td>
        Якщо <code>x</code> має значення 3, то <code>--x</code> присвоює <code>x</code> значення 2 і повертає 2, натомість <code>x--</code> повертає 3, і лише після цього присвоює <code>x</code> значення 2.
      </td>
    </tr>
    <tr>
      <td>
        <a href="/uk/docs/Web/JavaScript/Reference/Operators/Unary_negation">Унарна протилежність</a> (<code>-</code>)
      </td>
      <td>Унарний оператор. Повертає протилежність до свого операнда.</td>
      <td>Якщо <code>x</code> має значення 3, то <code>-x</code> повертає -3.</td>
    </tr>
    <tr>
      <td>
        <a href="/uk/docs/Web/JavaScript/Reference/Operators/Unary_plus">Унарний плюс</a> (<code>+</code>)
      </td>
      <td>
        Унарний оператор. Намагається <a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Number#zvedennia-do-chysla">перетворити свій операнд на число</a>, якщо він ним не є.
      </td>
      <td>
        <p><code>+"3"</code> повертає <code>3</code>.</p>
        <p><code>+true</code> повертає <code>1</code>.</p>
      </td>
    </tr>
    <tr>
      <td>
        <a href="/uk/docs/Web/JavaScript/Reference/Operators/Exponentiation">Піднесення до степеня</a> (<code>**</code>)
      </td>
      <td>
        Обчислює піднесення числа <code>base</code> до степеня <code>exponent</code>, тобто <code>base^exponent</code>
      </td>
      <td>
        <code>2 ** 3</code> повертає <code>8</code>.<br /><code>10 ** -1</code>
        повертає <code>0.1</code>.
      </td>
    </tr>
  </tbody>
</table>

## Бітові оператори

Бітові оператори розглядають свої операнди як набори з 32 бітів (нулів та одиниць), а не як десяткові, шістнадцяткові або вісімкові числа. Наприклад, десяткове число дев'ять має двійкове представлення 1001. Бітові оператори виконують свої операції над таким двійковим представленням, але повертають звичайні числові значення JavaScript.

Наступна таблиця містить підсумок бітових операторів JavaScript.

| Оператор                                                                                           | Застосування | Опис                                                                                                                                                    |
| -------------------------------------------------------------------------------------------------- | ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [Бітова кон'юнкція](/uk/docs/Web/JavaScript/Reference/Operators/Bitwise_AND)                       | `a & b`      | Повертає одиницю в кожній бітовій позиції, в якій відповідні біти обох операндів – одиниці.                                                             |
| [Бітова диз'юнкція](/uk/docs/Web/JavaScript/Reference/Operators/Bitwise_OR)                        | `a \| b`     | Повертає нуль в кожній бітовій позиції, в якій відповідні біти обох операндів – нулі.                                                                   |
| [Бітова виключна диз'юнкція](/uk/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR)              | `a ^ b`      | Повертає нуль у кожній бітовій позиції, в якій відповідні біти – однакові (Повертає одиницю в кожній бітовій позиції, в якій відповідні біти – різні).] |
| [Бітове заперечення](/uk/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT)                      | `~ a`        | Міняє біти свого операнда на протилежні.                                                                                                                |
| [Зсув уліво](/uk/docs/Web/JavaScript/Reference/Operators/Left_shift)                               | `a << b`     | Зсуває `a` у двійковому представленні на `b` бітів уліво, вставляючи нулі справа.                                                                       |
| [Зсув управо зі збереженням знаку](/uk/docs/Web/JavaScript/Reference/Operators/Right_shift)        | `a >> b`     | Зсуває `a` у двійковому представленні на `b` бітів управо, відкидаючи висунуті біти.                                                                    |
| [Зсув управо з додаванням нулів](/uk/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift) | `a >>> b`    | Зсуває `a` у двійковому представленні на `b` бітів управо, відкидаючи висунуті біти, і доставляючи зліва нулі.                                          |

### Бітові логічні оператори

Концептуально бітові логічні оператори працюють так:

- Операнди перетворюються на тридцятидвобітні цілі числа, виражені послідовностями бітів (нулів та одиниць). Найважливіші біти чисел, котрі мають більш ніж 32 біти, відкидаються. Наприклад, наступне ціле число, котре має понад 32 біти, перетворюється на 32-бітове ціле:

  ```plain
  До:    1110 0110 1111 1010 0000 0000 0000 0110 0000 0000 0001
  Після:                1010 0000 0000 0000 0110 0000 0000 0001
  ```

- Кожний біт першого операнда зіставляється з відповідним бітом другого операнда: перший біт до першого біта, другий біт до другого біта – і так далі.
- Оператор застосовується до кожної пари бітів, а результат збирається з бітових результатів.

Наприклад, двійкове представлення дев'яти – 1001, а двійкове представлення п'ятнадцяти – 1111. Таким чином, коли до цих значень застосувати бітові оператори, то результати будуть такі:

| Вираз     | Результат | Двійковий опис                                    |
| --------- | --------- | ------------------------------------------------- |
| `15 & 9`  | `9`       | `1111 & 1001 = 1001`                              |
| `15 \| 9` | `15`      | `1111 \| 1001 = 1111`                             |
| `15 ^ 9`  | `6`       | `1111 ^ 1001 = 0110`                              |
| `~15`     | `-16`     | `~ 0000 0000 … 0000 1111 = 1111 1111 … 1111 0000` |
| `~9`      | `-10`     | `~ 0000 0000 … 0000 1001 = 1111 1111 … 1111 0110` |

Зверніть увагу на те, що всі 32 біти – змінюються на протилежні за допомогою оператора бітового заперечення, і що значення з найважливішим (крайнім зліва) бітом 1 представляють від'ємні числа (доповнювальне представлення). `~x` обчислюється в таке ж значення, що й `-x - 1`.

### Оператори бітового зсуву

Оператори бітового зсуву приймають два операнди: перший – число до зсуву, а другий – це число бітових позицій, на яке буде зсунутий перший операнд. Напрям операції зсуву визначається застосованим оператором.

Оператори зсуву перетворюють свої операнди на тридцятидвобітні цілі числа й повертають результат або типу{{jsxref("Number")}}, або {{jsxref("BigInt")}}, а саме: якщо тип лівого операнда – {{jsxref("BigInt")}}, то вони повертають {{jsxref("BigInt")}}, інакше – {{jsxref("Number")}}.

Оператори зсуву перелічені в наступній таблиці.

<table class="fullwidth-table">
  <caption>
    Оператори бітового зсуву
  </caption>
  <thead>
    <tr>
      <th scope="col">Оператори</th>
      <th scope="col">Опис</th>
      <th scope="col">Приклад</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href="/uk/docs/Web/JavaScript/Reference/Operators/Left_shift">Зсув уліво</a><br />(<code>&#x3C;&#x3C;</code>)
      </td>
      <td>
        Цей оператор зсуває перший операнд на задану кількість бітів уліво. Надлишкові біти зліва – відкидаються. Справа – доставляються нулі.
      </td>
      <td>
        <code>9&#x3C;&#x3C;2</code> видає 36, тому що 1001, зсунуте на 2 біти уліво, стає 100100, тобто 36.
      </td>
    </tr>
    <tr>
      <td>
        <a href="/uk/docs/Web/JavaScript/Reference/Operators/Right_shift">Зсув управо зі збереженням знаку</a> (<code>>></code>)
      </td>
      <td>
        Цей оператор зсуває перший операнд на задану кількість бітів управо. Надлишкові біти справа – відкидаються. Зліва доставляються копії крайнього лівого біта.
      </td>
      <td>
        <code>9>>2</code> видає 2, тому що 1001, зсунуте на 2 бітів управо, стає 10, тобто 2. Аналогічно, <code>-9>>2</code> видає -3, тому що знак зберігається.
      </td>
    </tr>
    <tr>
      <td>
        <a href="/uk/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift">Зсув управо з додаванням нулів</a> (<code>>>></code>)
      </td>
      <td>
        Цей оператор зсуває перший операнд на задану кількість бітів управо. Надлишкові біти справа – відкидаються. Зліва – доставляються нульові біти.
      </td>
      <td>
        <code>19>>>2</code> видає 4, адже 10011, зсунуте на 2 біти управо, стає 100, тобто 4. У випадку невід'ємних чисел зсув управо із додаванням нулів і зсув управо зі збереженням знаку видають однакові результати.
      </td>
    </tr>
  </tbody>
</table>

## Логічні оператори

Логічні оператори здебільшого застосовуються на булевих (логічних) значеннях; коли це так, то вони повертають булеві значення.
Проте оператори `&&` і `||` фактично повертають значення одного з переданих операндів, тож коли ці оператори застосовуються до небулевих значень, то ці оператори можуть повернути небулеві значення.
Логічні оператори описані в наступній таблиці.

<table class="fullwidth-table">
  <caption>
    Логічні оператори
  </caption>
  <thead>
    <tr>
      <th scope="col">Оператор</th>
      <th scope="col">Застосування</th>
      <th scope="col">Опис</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <a href="/uk/docs/Web/JavaScript/Reference/Operators/Logical_AND">Логічна кон'юнкція</a> (<code>&#x26;&#x26;</code>)
      </td>
      <td><code>expr1 &#x26;&#x26; expr2</code></td>
      <td>
        Повертає <code>expr1</code>, якщо це значення може бути перетворено на <code>false</code>, інакше – повертає <code>expr2</code>. Таким чином, бувши застосованим до булевих значень, оператор <code>&#x26;&#x26;</code> повертає <code>true</code>, якщо обидва операнди – true, інакше – повертає <code>false</code>.
      </td>
    </tr>
    <tr>
      <td>
        <a href="/uk/docs/Web/JavaScript/Reference/Operators/Logical_OR">Логічна диз'юнкція </a>(<code>||</code>)
      </td>
      <td><code>expr1 || expr2</code></td>
      <td>
        Повертає <code>expr1</code>, якщо це значення може бути перетворено на <code>true</code>, інакше повертає <code>expr2</code>. Таким чином, бувши застосованим до булевих значень, оператор <code>||</code> повертає <code>true</code>, якщо будь-який з операндів – true, якщо ж обидва вони – false, то повертає <code>false</code>.
      </td>
    </tr>
    <tr>
      <td>
        <a href="/uk/docs/Web/JavaScript/Reference/Operators/Logical_NOT">Логічне заперечення</a> (<code>!</code>)
      </td>
      <td><code>!expr</code></td>
      <td>
        Повертає <code>false</code>, якщо єдиний операнд оператора може бути перетворений на <code>true</code>, інакше – повертає <code>true</code>.
      </td>
    </tr>
  </tbody>
</table>

Прикладами виразів, котрі можуть бути перетворені на `false`, є ті вирази, котрі обчислюються в null, 0, NaN, порожній рядок ("") та undefined.

Наступний код демонструє приклади застосування оператора `&&` (логічної кон'юнкції).

```js
const a1 = true && true; // t && t повертає true
const a2 = true && false; // t && f повертає false
const a3 = false && true; // f && t повертає false
const a4 = false && 3 === 4; // f && f повертає false
const a5 = "Кіт" && "Пес"; // t && t повертає Пес
const a6 = false && "Кіт"; // f && t повертає false
const a7 = "Кіт" && false; // t && f повертає false
```

Наступний код демонструє приклади застосування оператора || (логічної диз'юнкції).

```js
const o1 = true || true; // t || t повертає true
const o2 = false || true; // f || t повертає true
const o3 = true || false; // t || f повертає true
const o4 = false || 3 === 4; // f || f повертає false
const o5 = "Кіт" || "Пес"; // t || t повертає Кіт
const o6 = false || "Кіт"; // f || t повертає Кіт
const o7 = "Кіт" || false; // t || f повертає Кіт
```

Наступний код демонструє приклади застосування оператора ! (логічного заперечення).

```js
const n1 = !true; // !t повертає false
const n2 = !false; // !f повертає true
const n3 = !"Кіт"; // !t повертає false
```

### Закорочення обчислення

Оскільки логічні вирази обчислюються зліва направо, то вони перевіряються на змогу "закоротити" обчислення, згідно з наступними правилами:

- `false && щось` – із закороченням обчислюється в false.
- `true || щось` – із закороченням обчислюється в true.

Правила логіки гарантують, що такі обчислення завжди є коректними. Зверніть увагу на те, що частина _щось_ виразів вище – не обчислюється, тож жодні побічні ефекти цих частин – не подіють.

Зверніть увагу на те, що в сучасному коді можна застосувати [оператор null-злиття](/uk/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing) (`??`), котрий працює подібно до `||`, але повертає другий вираз лише тоді, коли перший вираз є "[null-подібним](/uk/docs/Glossary/Nullish)", тобто [`null`](/uk/docs/Web/JavaScript/Reference/Operators/null) або [`undefined`](/uk/docs/Web/JavaScript/Reference/Global_Objects/undefined).
Таким чином, це кращий варіант для надання усталених значень у тих випадках, коли `''` і `0` є дійсними значеннями першого виразу.

## Оператори BigInt

Більшість операторів, котрі можуть бути застосовані до двох чисел, може бути застосована також до значень [`BigInt`](/uk/docs/Web/JavaScript/Reference/Global_Objects/BigInt).

```js
// Додавання BigInt
const a = 1n + 2n; // 3n
// Ділення BigInts округлюється в бік нуля
const b = 1n / 2n; // 0n
// Бітові операції над BigInts не обрізають число з жодного боку
const c = 40000000000000000n >> 2n; // 10000000000000000n
```

Винятком є [беззнаковий зсув управо (`>>>`)](/uk/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift), котрий не визначений для значень BigInt. Це пов'язано з тим, що BigInt не має фіксованої ширини, тож технічно цей тип не має "крайнього зліва біта".

```js
const d = 8n >>> 2n; // TypeError: BigInts have no unsigned right shift, use >> instead
```

Значення BigInt і числа не є взаємозамінними – їх не можна змішувати при обчисленнях.

```js example-bad
const a = 1n + 2; // TypeError: Cannot mix BigInt and other types
```

Це пов'язано з тим, що BigInt не є ані підмножиною, ані надмножиною чисел. Значення BigInt мають вищу точність, ніж звичайні числа, при представленні великих цілих, але не можуть представляти дроби, тож неявне перетворення в обидва боки може призвести до втрати точності. Слід використовувати явне перетворення для позначення того, чи повинна операція відбуватися над звичайними числами, чи над BigInt.

```js example-good
const a = Number(1n) + 2; // 3
const b = 1n + BigInt(2); // 3n
```

Можна порівнювати BigInt з числами.

```js
const a = 1n > 2; // false
const b = 3 > 2n; // true
```

## Рядкові оператори

На додачу до операторів порівняння, котрі можна застосовувати до рядкових значень, оператор зчеплення (+) зчіплює два рядкові значення докупи, повертаючи новий рядок, котрий є сполученням двох рядків – операндів.

Наприклад,

```js
console.log("my " + "string"); // консоль виводить рядок "my string".
```

Оператор присвоєння зі скороченням `+=` також може використовуватись для зчеплення рядків.

Наприклад,

```js
let mystring = "alpha";
mystring += "bet"; // обчислюється в "alphabet" й присвоює це значення mystring.
```

## Умовний (тернарний) оператор

[Умовний оператор](/uk/docs/Web/JavaScript/Reference/Operators/Conditional_operator) – це єдиний оператор JavaScript, котрий приймає три операнди. Він може приймати одне з двох значень, залежно від умови. Запис – наступний:

```js-nolint
condition ? val1 : val2
```

Якщо `condition` істинна, то оператор має значення `val1`.
Інакше – він має значення `val2`. Умовний оператор можна використовувати всюди, де можна було б використати стандартний оператор.

Наприклад,

```js
const status = age >= 18 ? "adult" : "minor";
```

Ця інструкція присвоює значення "adult" змінній `status`, якщо `age` має значення вісімнадцяти або більше. Інакше, змінній `status` присвоюється значення "minor".

## Оператор коми

[Оператор коми](/uk/docs/Web/JavaScript/Reference/Operators/Comma_operator) (`,`) обчислює обидва свої операнди й повертає значення останнього з них.
Цей оператор перш за все використовується в циклі `for`, аби мати змогу оновлювати декілька змінних при кожній ітерації циклу.
Вживання оператора коми вважається недоброю практикою, коли це не є необхідністю.
Нерідко замість цього можна й варто використати дві окремі інструкції.

Наприклад, якщо `a` – це двовимірний масив з 10 елементами в кожному підмасиві, то наступний код використовує оператор коми, аби оновити дві змінні за раз.
Цей код виводить значення діагональних елементів масиву:

```js
const x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
const a = [x, x, x, x, x];

for (let i = 0, j = 9; i <= j; i++, j--) {
  //                              ^
  console.log(`a[${i}][${j}]= ${a[i][j]}`);
}
```

## Унарні оператори

Унарна операція – це операція лише з одним операндом.

### delete

Оператор [`delete`](/uk/docs/Web/JavaScript/Reference/Operators/delete) видаляє властивість об'єкта.
Запис – наступний:

```js
delete object.property;
delete object[propertyKey];
delete objectName[index];
```

де `object` – це назва об'єкта, `property` – його наявна властивість, а `propertyKey` – рядок або символ, що вказує на наявну властивість.

Коли оператор `delete` має успіх, то прибирає з об'єкта властивість.
Спроба звернутись до неї після цього видасть `undefined`.
Оператор `delete` повертає `true`, якщо операція можлива, і `false`, якщо вона неможлива.

```js
delete Math.PI; // повертає false (не можна видаляти неналаштовні властивості)

const myObj = { h: 4 };
delete myObj.h; // повертає true (визначені користувачем властивості видаляти можна)
```

#### Видалення елементів масиву

Оскільки масиви є лишень об'єктами, технічно можливо застосувати до них оператор `delete`.
Проте це вважається недоброю практикою, так робити не варто.
Коли видаляється властивість масиву, то це не впливає на його довжину, а решта елементів не отримує нових індексів.
Для прибирання елемента з масиву краще просто записати замість нього значення `undefined`.
Задля фактичного змінювання масиву слід використовувати різні методи масиву, як то [`splice`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Array/splice).

### typeof

[Оператор `typeof`](/uk/docs/Web/JavaScript/Reference/Operators/typeof) повертає рядок, котрий вказує на тип необчисленого операнда.
`operand` – це рядок, змінна, ключове слово або об'єкт, тип якого буде повернений.
Дужки – необов'язкові.

Припустімо, що оголошені наступні змінні:

```js
const myFun = new Function("5 + 2");
const shape = "round";
const size = 1;
const foo = ["Apple", "Mango", "Orange"];
const today = new Date();
```

Оператор `typeof` поверне для них наступні результати:

```js
typeof myFun; // повертає "function"
typeof shape; // повертає "string"
typeof size; // повертає "number"
typeof foo; // повертає "object"
typeof today; // повертає "object"
typeof doesntExist; // повертає "undefined"
```

Для ключових слів `true` і `null` оператор `typeof` повертає наступні результати:

```js
typeof true; // повертає "boolean"
typeof null; // повертає "object"
```

Для числа або рядка:

```js
typeof 62; // повертає "number"
typeof "Hello world"; // повертає "string"
```

Для значень властивостей оператор `typeof` повертає тип значення, котре така властивість містить:

```js
typeof document.lastModified; // повертає "string"
typeof window.length; // повертає "number"
typeof Math.LN2; // повертає "number"
```

Для методів і функцій оператор `typeof` повертає таке:

```js
typeof blur; // повертає "function"
typeof eval; // повертає "function"
typeof parseInt; // повертає "function"
typeof shape.split; // повертає "function"
```

Для наперед визначених об'єктів:

```js
typeof Date; // повертає "function"
typeof Function; // повертає "function"
typeof Math; // повертає "object"
typeof Option; // повертає "function"
typeof String; // повертає "function"
```

### void

[Оператор `void`](/uk/docs/Web/JavaScript/Reference/Operators/void) позначає вираз як такий, що повинен бути обчислений без повернення значення. `expression` – це вираз JavaScript для обчислення.
Дужки навколо виразу – необов'язкові, але краще їх використовувати, аби уникати проблем з пріоритетом.

## Оператори відношення

Оператори відношення порівнюють свої операнди й повертають булеве значення на основі істинності порівняння.

### in

[Оператор `in`](/uk/docs/Web/JavaScript/Reference/Operators/in) повертає `true`, якщо дана властивість існує в даному об'єкті.
Запис – наступний:

```js-nolint
propNameOrNumber in objectName
```

де `propNameOrNumber` – це рядковий, числовий або символьний вираз, що представляє назву властивості або індекс масиву, а `objectName` – це назва об'єкта.

Наступні приклади демонструють кілька варіантів використання оператора `in`.

```js
// Масиви
const trees = ["redwood", "bay", "cedar", "oak", "maple"];
0 in trees; // повертає true
3 in trees; // повертає true
6 in trees; // повертає false
"bay" in trees; // повертає false
// (необхідно задати число-індекс, а не значення за цим індексом)
"length" in trees; // повертає true (length – це властивість масива)

// вбудовані об'єкти
"PI" in Math; // повертає true
const myString = new String("coral");
"length" in myString; // повертає true

// Власні об'єкти
const mycar = { make: "Honda", model: "Accord", year: 1998 };
"make" in mycar; // повертає true
"model" in mycar; // повертає true
```

### instanceof

[Оператор `instanceof`](/uk/docs/Web/JavaScript/Reference/Operators/instanceof) повертає `true`, якщо даний об'єкт належить до даного об'єктного типу. Запис – наступний:

```js-nolint
objectName instanceof objectType
```

де `objectName` – це назва об'єкта до порівняння з `objectType`, а `objectType` – об'єктний тип, наприклад, {{jsxref("Date")}} або {{jsxref("Array")}}.

Використовувати `instanceof` слід тоді, коли необхідно перевірити тип об'єкта під час виконання.
Наприклад, при перехопленні винятків, може бути потреба обробляти по-різному викинуті винятки, залежно від їх типу.

Наприклад, наступний код використовує `instanceof` для з'ясування того, чи є `theDay` об'єктом `Date`. Оскільки `theDay` є об'єктом `Date`, то інструкції всередині інструкції `if` – виконуються.

```js
const theDay = new Date(1995, 12, 17);
if (theDay instanceof Date) {
  // інструкції до виконання
}
```

## Базові вирази

Усі оператори, зрештою, працюють з одним чи багатьма базовими виразами. Серед цих базових виразів – [ідентифікатори](/uk/docs/Web/JavaScript/Guide/Grammar_and_types#oholoshennia) й [літерали](/uk/docs/Web/JavaScript/Guide/Grammar_and_types#literaly), однак є й кілька інших різновидів. Ці різновиди стисло вводяться нижче, а їхня семантика детально описана у відповідних розділах довідки.

### this

[Ключове слово `this`](/uk/docs/Web/JavaScript/Reference/Operators/this) слід використовувати для звертання до поточного об'єкта.
Загалом, `this` вказує на об'єкт, з якого викликається метод.
`this` слід вживати із записом крапки або квадратних дужок:

```js
this["propertyName"];
this.propertyName;
```

Припустімо, що функція під назвою `validate` валідує властивість `value` об'єкта, отримавши об'єкт та межі допустимого діапазону для `value`:

```js
function validate(obj, lowval, hival) {
  if (obj.value < lowval || obj.value > hival) {
    console.log("Недійсне значення!");
  }
}
```

`validate` можна викликати в кожному обробнику подій `onChange` елемента форми, використовуючи `this` для передачі цього елемента, як це показано в наступному прикладі:

```html
<p>Введіть число між 18 і 99:</p>
<input type="text" name="age" size="3" onChange="validate(this, 18, 99);" />
```

### Оператор групування

Оператор групування `( )` контролює пріоритет обчислення у виразах. Наприклад, можна відкинути першість множення й ділення перед додаванням і відніманням - і обчислити спершу додавання.

```js-nolint
const a = 1;
const b = 2;
const c = 3;

// усталений пріоритет
a + b * c     // 7
// усталено обчислюється так
a + (b * c)   // 7

// тепер нав'язуємо пріоритет
// додавання перед множенням
(a + b) * c   // 9

// що рівносильно
a * c + b * c // 9
```

### new

[Оператор `new`](/uk/docs/Web/JavaScript/Reference/Operators/new) можна використовувати для створення примірника власного об'єктного типу або одного із вбудованих об'єктних типів. Робиться це так:

```js
const objectName = new ObjectType(param1, param2, /* …, */ paramN);
```

### super

[Ключове слово `super`](/uk/docs/Web/JavaScript/Reference/Operators/super) використовується для виклику функцій на батьківському об'єкті.
Корисно, наприклад, при використанні [класів](/uk/docs/Web/JavaScript/Reference/Classes) – викликати батьківський конструктор.

```js-nolint
super(args); // викликається батьківський конструктор.
super.functionOnParent(args);
```

{{PreviousNext("Web/JavaScript/Guide/Functions", "Web/JavaScript/Guide/Numbers_and_dates")}}
