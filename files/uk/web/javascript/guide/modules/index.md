---
title: Модулі JavaScript
slug: Web/JavaScript/Guide/Modules
tags:
  - Guide
  - JavaScript
  - Modules
  - export
  - import
browser-compat:
  - javascript.statements.import
  - javascript.statements.export
---

{{JSSidebar("JavaScript Guide")}}{{Previous("Web/JavaScript/Guide/Meta_programming")}}

Ці настанови дають всі необхідні знання для початку використання синтаксису модулів JavaScript.

## Контекст появи модулів

Програми на JavaScript спершу були доволі дрібними: більшість застосування JavaScript полягала в ізольованих сценарних операціях, доданні дрібки інтерактивності до вебсторінок, де це необхідно, тож великі сценарії загалом не були потрібні. Перемотка на кілька років – і ось цілі застосунки працюють в браузерах, з купою JavaScript, а крім того, JavaScript використовується в інших контекстах ([Node.js](/uk/docs/Glossary/Node.js), наприклад).

Таким чином, протягом останніх років з'явився зміст подумати про надання механізмів розбиття програм на JavaScript на окремі модулі, котрі можуть бути імпортовані при потребі. Node.js вже тривалий час має таку можливість, крім того, є низка бібліотек і фреймворків JavaScript, що дають змогу користуватись модулями (наприклад, модульні системи на основі [CommonJS](https://uk.wikipedia.org/wiki/CommonJS) і [AMD](https://github.com/amdjs/amdjs-api/blob/master/AMD.md), як то [RequireJS (англ.)](https://requirejs.org/), а геть нещодавно – [Webpack (англ.)](https://webpack.js.org/) і [Babel (англ.)](https://babeljs.io/)).

Добрі новини полягають в тому, що сучасні браузери почали підтримувати функціональність модулів нативно, і це те, про що розповідає вся ця стаття. Це може бути лише доброю штукою: браузери можуть оптимізувати завантаження модулів, роблячи його більш ефективним, ніж потреба використати бібліотеку й виконувати всю надлишкову обробку на клієнтському боці й зайві ходки в мережу.

Використання нативних модулів JavaScript залежить від інструкцій {{JSxRef("Statements/import", "import")}} і {{JSxRef("Statements/export", "export")}}; їх підтримка в браузері показана в таблиці сумісності нижче.

## Сумісність із браузерами

{{Compat}}

## Введення прикладу

Для демонстрації використання модулів ми створили [простий набір прикладів](https://github.com/mdn/js-examples/tree/master/module-examples), доступний на GitHub. Ці приклади демонструють простий набір модулів, що створюють на вебсторінці елемент [`<canvas>`](/uk/docs/Web/HTML/Element/canvas), а потім малюють (і повідомляють про це інформацію) на полотні різні фігури.

Вони доволі тривіальні, але навмисно були залишені простими, щоб ясно демонструвати модулі.

> **Примітка:** При потребі завантажити приклади й запустити їх локально – їх треба запускати через локальний вебсервер.

## Структура базового прикладу

В нашому першому прикладі (дивіться [basic-modules](https://github.com/mdn/js-examples/tree/master/module-examples/basic-modules)) присутня наступна файлова структура:

```plain
index.html
main.js
modules/
    canvas.js
    square.js
```

> **Примітка:** Всі приклади цих настанов по суті мають однакову структуру; структура вище повинна стати доволі звичною.

Два модулі директорії модулів описані нижче:

- `canvas.js` — містить функції, пов'язані з налаштуванням полотна:

  - `create()` — створює полотно із заданими `width` і `height` всередині обгортки [`<div>`](/uk/docs/Web/HTML/Element/div) із заданим ID, котрий, своєю чергою, додається в кінець заданого батьківського елемента. Повертає об'єкт, що містить 2D контекст полотна й ID обгортки.
  - `createReportList()` — створює невпорядкований список, доданий в кінець вказаного елемента-обгортки, котрий може бути використаний для виведення звітних даних. Повертає ID списку.

- `square.js` — містить:

  - `name` — сталу, що містить рядок 'square'.
  - `draw()` — малює на заданому полотні квадрат, що має задані розмір, положення й колір. Повертає об'єкт, що містить розмір, положення й колір квадрата.
  - `reportArea()` — вписує площу квадрата в особливий звітний список, отримавши його довжину.
  - `reportPerimeter()` — вписує периметр квадрата в особливий звітний список, отримавши його довжину.

### Крок убік — .mjs проти .js

Протягом цієї статті ми використовували для модульних файлів розширення `.js`, однак в інших ресурсах можна зустріти використання розширення `.mjs`. Наприклад, [документація V8 радить використовувати саме .mjs (англ.)](https://v8.dev/features/modules#mjs). Причини для цього:

- Покращення очевидності, тобто таке розширення робить очевидним те, які файли є модулями, а які – звичайним JavaScript.
- Певність щодо того, що модульні файли розбираються як модулі такими середовищами виконання, як [Node.js (англ.)](https://nodejs.org/api/esm.html#esm_enabling), й інструментами складання, як то [Babel (англ.)](https://babeljs.io/docs/en/options#sourcetype).

Проте ми вирішили надалі використовувати `.js`, принаймні поки що. Аби модулі коректно працювали в браузері, треба пересвідчитися, що сервер видає їх з заголовком `Content-Type`, що містить MIME тип JavaScript, як то `text/javascript`. Без цього буде помилка строгої перевірки типу MIME і слова "The server responded with a non-JavaScript MIME type", і браузер такий JavaScript не запускатиме. Більшість серверів самі по собі встановлюють коректний тип для файлів `.js`, але не для файлів `.mjs`. Серед серверів, що уже видають файли `.mjs` коректно – [GitHub Pages](https://pages.github.com/) і [`http-server`](https://github.com/http-party/http-server#readme) для Node.js.

У форматі `.mjs` немає проблеми, якщо ви вже використовуєте відповідне середовище, або якщо ще ні, але розумієте, що робите, і маєте доступ (тобто можете налаштувати свій сервер на встановлення коректного [`Content-Type`](/uk/docs/Web/HTTP/Headers/Content-Type) для файлів `.mjs`). Утім, це може викликати спантеличення, якщо ви не контролюєте сервер, з котрого видаються файли, або публікуєте файли для публічного використання, як ми.

Для потреб навчання й переносності ми вирішили залишити розширення `.js`.

Якщо ви справді цінуєте очевидність використання `.mjs` для модулів на противагу `.js` для "звичайних" файлів JavaScript, але не хочете зіткнутися з проблемою, описаною вище, можна завжди використовувати `.mjs` під час розробки, перетворюючи на `.js` під час кроку складання.

Також варто зазначити, що:

- Частина інструментів може ніколи не підтримувати `.mjs`.
- Атрибут `<script type="module">` використовується для позначення, що вказівка відбувається на модуль, як це видно нижче.

## Експорт можливостей модуля

Перше, що слід зробити для отримання доступу до можливостей модуля, – експортувати їх. Це робиться за допомогою інструкції {{JSxRef("Statements/export", "export")}}.

Найлегший спосіб її застосувати – розташувати перед будь-якими сутностями, котрі хочеться експортувати з модуля, наприклад:

```js
export const name = "square";

export function draw(ctx, length, x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, length, length);

  return { length, x, y, color };
}
```

Можна експортувати, `var`, `let`, `const`, і – як побачимо згодом – класи. Вони мусять бути сутностями зовнішнього рівня; не можна застосувати `export`, наприклад, всередині функції.

Зручніший спосіб експортувати все, що хочеться експортувати, – використати єдину інструкцію експорту в кінці файлу модуля, після якої – розділений комами список можливостей до експорту, загорнутий в фігурні дужки. Наприклад:

```js
export { name, draw, reportArea, reportPerimeter };
```

## Імпорт можливостей до сценарію

Після експортування певних можливостей модуля треба імпортувати їх до сценарію, щоб мати змогу ці можливості використовувати. Найпростіший спосіб це зробити – такий:

```js
import { name, draw, reportArea, reportPerimeter } from "./modules/square.js";
```

Спершу інструкція {{JSxRef("Statements/import", "import")}}, далі – розділений комами список можливостей до імпорту, загорнутий в фігурні дужки, далі – ключове слово `from`, потім – шлях до файлу модуля, відносний щодо кореня сайту, в прикладі `basic-modules` такий шлях буде `/js-examples/module-examples/basic-modules`.

Проте тут шлях записаний трохи інакше – за допомогою синтаксису крапки (`.`), котра вказує на "поточне розташування", після крапки ж – решта шляху до шуканого файлу. Це набагато краще за написання щоразу всього відносного шляху, адже так коротше, і так URL стає більш переносною: приклад працюватиме й далі, якщо перенести його в інше місце в ієрархії сайту.

Тож, наприклад:

```bash
/js-examples/module-examples/basic-modules/modules/square.js
```

стає

```bash
./modules/square.js
```

В дії такі рядки можна побачити в [`main.js`](https://github.com/mdn/js-examples/blob/master/module-examples/basic-modules/main.js).

> **Примітка:** В певних модульних системах можна опустити розширення файлу і `/`, `./` чи `../` на початку (наприклад, `'modules/square'`). Це не працює в браузерному середовищі, оскільки може призвести до декількох мережевих запитів.

Після імпортування можливостей до сценарію їх можна використовувати так, ніби вони визначені в тому самому файлі. Наступний код розташований у `main.js`, під рядками імпорту:

```js
const myCanvas = create("myCanvas", document.body, 480, 320);
const reportList = createReportList(myCanvas.id);

const square1 = draw(myCanvas.ctx, 50, 50, 100, "blue");
reportArea(square1.length, reportList);
reportPerimeter(square1.length, reportList);
```

> **Примітка:** Попри те, що імпортовані можливості доступні в файлі, вони є доступними лише для читання представленнями експортованих можливостей. Не можна змінити імпортовану змінну, але можна змінювати властивості, подібно як із `const`. Крім того, такі можливості імпортуються як живі прив'язування, а отже, на відміну від `const`, вони можуть змінювати значення, хоч зв'язування, як і `const`, змінити неможливо.

## Застосування модуля до HTML

Тепер треба застосувати модуль `main.js` до сторінки HTML. Це вельми подібно до того, як застосовується до сторінки звичайний сценарій, за винятком кількох відмінностей.

Перш за все треба додати до елемента [`<script>`](/uk/docs/Web/HTML/Element/script) `type="module"`, аби оголосити сценарій як модуль. Для імпорту сценарію `main.js` застосовуємо таке:

```html
<script type="module" src="main.js"></script>
```

Також сценарій модуля можна вбудувати безпосередньо в файл HTML, розташувавши код JavaScript всередині тіла елемента `<script>`:

```html
<script type="module">
  /* Тут код модуля JavaScript */
</script>
```

Сценарій, в котрий імпортуються можливості модуля, по суті діє як модуль верхнього рівня. Якщо це упустити, то Firefox, наприклад, дає помилку "SyntaxError: import declarations may only appear at top level of a module".

Інструкції `import` і `export` можна використовувати лише в модулях, але не у звичайних сценаріях.

## Інші відмінності між модулями й звичайними сценаріями

- Слід звернути увагу на локальне тестування: якщо спробувати завантажити файл HTML локально (тобто з URL `file://`), то трапляться помилки CORS, у зв'язку з вимогами безпеки модулів JavaScript. Тестування треба проводити за допомогою сервера.
- Крім того, зверніть увагу, що поведінка частин сценарію, визначених всередині модулів, коли порівняти зі звичайними сценаріями, може відрізнятися. Це пов'язано з тим, що модулі автоматично застосовують {{JSxRef("Strict_mode", "суворий режим", "", 1)}}.
- Немає потреби застосовувати атрибут `defer` (дивіться [`<script>` attributes](/uk/docs/Web/HTML/Element/script#atrybuty)) при завантаженні модульного сценарію; завантаження модулів автоматично відкладається.
- Модулі виконуються лише раз, навіть якщо до них звертаються декілька тегів `<script>`.
- І останнє, але не менш важливе, слід прояснити: можливості модулів імпортуються в область видимості одного сценарію – вони не доступні в глобальній області. Таким чином, імпортовані можливості доступні лише в тому сценарії, в котрий імпортовані, і не вийде звернутися до них з консолі JavaScript, наприклад. Синтаксичні помилки виводитимуться в DevTools, але не вийде застосувати певні методики зневадження, котрі могло б хотітися.

Визначені в модулі змінні обмежені модулем, якщо явно не прикріплені до глобального об'єкта. З іншого боку, глобально описані змінні доступні всередині модуля. Наприклад, в наступному коді:

```html
<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8" />
    <title></title>
    <link rel="stylesheet" href="" />
  </head>
  <body>
    <div id="main"></div>
    <script>
      // Інструкція var створює глобальну змінну
      var text = "Привіт";
    </script>
    <script type="module" src="./render.js"></script>
  </body>
</html>
```

```js
/* render.js */
document.getElementById("main").innerText = text;
```

Сторінка покаже `Привіт`, адже глобальні змінні `text` і `document` – доступні в модулі. (Крім того, зауважте в цьому модулі, що модуль не обов'язково потребує інструкцій імпорту чи експорту: єдина необхідна річ – щоб точка входу мала `type="module"`.)

## Усталений експорт проти іменованого експорту

Експортована вище функціональність складалася з **іменованого експорту**: до кожної сутності (чи це функція, `const` тощо) було звертання за її ім'ям при експорті, і те саме ім'я використовувалося для звертання до неї також при імпорті.

Також є різновид експорту, що зветься **усталеним експортом** — він розроблений для спрощення використання єдиної функції, наданої модулем, а також допомагає модулям JavaScript взаємодіяти з наявними модульними системами CommonJS та AMD (як це файно описано в [Поглиблено про ES6: Модулі (англ.)](https://hacks.mozilla.org/2015/08/es6-in-depth-modules/) від Джейсона Орендорффа; шукайте "Default exports").

Погляньмо на приклад у поясненні того, як він працює. В нашому basic-modules `square.js` є функція, що зветься `randomSquare()`, котра створює квадрат випадкових кольору, розміру й розташування. Треба експортувати її як усталений експорт, тож в кінці файлу дописуємо таке:

```js
export default randomSquare;
```

Зверніть увагу на відсутність фігурних дужок.

Замість цього можна дописати `export default` перед функцією й описати її як анонімну, отак:

```js
export default function (ctx) {
  // …
}
```

У файлі `main.js` – імпорт усталеної функції за допомогою такого рядка:

```js
import randomSquare from "./modules/square.js";
```

Знову таки, зверніть увагу на відсутність фігурних дужок. Це пов'язано з тим, що дозволений лише один усталений експорт на модуль, і відомо, що `randomSquare` є таким експортом. Рядок вище по суті є скороченням наступного:

```js
import { default as randomSquare } from "./modules/square.js";
```

> **Примітка:** Синтаксис as для перейменування експортованих сутностей пояснений нижче, в розділі [Імпорт та експорт з перейменуванням](#import-ta-eksport-z-pereimenuvanniam).

## Уникання конфліктів іменування

Поки що, схоже, модулі з малюванням фігур на полотні працювали нормально. Але що буде, якщо спробувати додати модуль, котрий малює іншу фігуру, як то круг чи трикутник? Напевне, для таких фігур також були б відповідні функції, як то `draw()`, `reportArea()` тощо; якщо спробувати імпортувати інші функції з таким самим іменем в той самий модульний файл верхнього рівня, то будуть конфлікти й помилки.

На щастя, існує низка способів це обійти. Вони розглядаються в наступних розділах.

## Імпорт та експорт з перейменуванням

Всередині фігурних дужок інструкцій `import` і `export` можна використовувати ключове слово `as` вкупі з новим іменем можливості, аби змінити її ім'я, що використовуватиметься в модулі верхнього рівня.

Тож, наприклад, обидва наступні зразки роблять одне й те ж, хоч і в трохи різний спосіб:

```js
// у module.js
export { function1 as newFunctionName, function2 as anotherNewFunctionName };

// у main.js
import { newFunctionName, anotherNewFunctionName } from "./modules/module.js";
```

```js
// у module.js
export { function1, function2 };

// у main.js
import {
  function1 as newFunctionName,
  function2 as anotherNewFunctionName,
} from "./modules/module.js";
```

Погляньмо на робочий приклад. В нашій директорії [renaming](https://github.com/mdn/js-examples/tree/master/module-examples/renaming) – така сама модульна система, як в попередньому прикладі, крім того, що додалися модулі `circle.js` і `triangle.js`, для малювання й звітування про круги та трикутники.

Всередині кожного з цих модулів експортуються можливості з тими самим іменами, а отже – такою інструкцією `export` внизу:

```js
export { name, draw, reportArea, reportPerimeter };
```

При їх імпорті в `main.js`, якщо спробувати

```js
import { name, draw, reportArea, reportPerimeter } from "./modules/square.js";
import { name, draw, reportArea, reportPerimeter } from "./modules/circle.js";
import { name, draw, reportArea, reportPerimeter } from "./modules/triangle.js";
```

То браузер викине помилку, як то "SyntaxError: redeclaration of import name" (Firefox).

Натомість треба перейменувати імпорт, щоб кожна можливість стала неповторною:

```js
import {
  name as squareName,
  draw as drawSquare,
  reportArea as reportSquareArea,
  reportPerimeter as reportSquarePerimeter,
} from "./modules/square.js";

import {
  name as circleName,
  draw as drawCircle,
  reportArea as reportCircleArea,
  reportPerimeter as reportCirclePerimeter,
} from "./modules/circle.js";

import {
  name as triangleName,
  draw as drawTriangle,
  reportArea as reportTriangleArea,
  reportPerimeter as reportTrianglePerimeter,
} from "./modules/triangle.js";
```

Зверніть увагу, що замість цього проблему можна вирішити в файлах модулів, наприклад:

```js
// у square.js
export {
  name as squareName,
  draw as drawSquare,
  reportArea as reportSquareArea,
  reportPerimeter as reportSquarePerimeter,
};
```

```js
// у main.js
import {
  squareName,
  drawSquare,
  reportSquareArea,
  reportSquarePerimeter,
} from "./modules/square.js";
```

І це працювало б просто так само. Який стиль використовувати – вирішувати вам, проте є зміст залишити код модулів у спокої й вносити зміни в імпорт. Це має особливий зміст при імпорті сторонніх модулів, над котрими немає контролю.

## Створення об'єкта модуля

Методика вище працює нормально, але є дещо недоладна й багатослівна. Іще кращий підхід – імпортування можливостей кожного модуля в об'єкт модуля. Це робить наступна синтаксична форма:

```js
import * as Module from "./modules/module.js";
```

Це згрібає всі інструкції експорту в `module.js` і робить відповідні можливості членами об'єкта `Module`, по суті роблячи його простором імен. Тож, наприклад:

```js
Module.function1();
Module.function2();
```

Знову таки, погляньмо на робочий приклад. Якщо зайти в нашу директорію [module-objects](https://github.com/mdn/js-examples/tree/master/module-examples/module-objects), то там той самий приклад, але переписаний для використання переваг такого нового синтаксису. В модулях експорт оформлений в наступний простий спосіб:

```js
export { name, draw, reportArea, reportPerimeter };
```

Імпорт, з іншого боку, має такий вигляд:

```js
import * as Canvas from "./modules/canvas.js";

import * as Square from "./modules/square.js";
import * as Circle from "./modules/circle.js";
import * as Triangle from "./modules/triangle.js";
```

В кожному випадку можна звертатись до імпортованих можливостей модуля через вказане ім'я об'єкта, наприклад:

```js
const square1 = Square.draw(myCanvas.ctx, 50, 50, 100, "blue");
Square.reportArea(square1.length, reportList);
Square.reportPerimeter(square1.length, reportList);
```

Відтак, можна писати код, так само як раніше (поки там, де це потрібно, включаються імена об'єктів), а запис імпорту – набагато стисліший.

## Модулі та класи

Як було зауважено вище, також можна експортувати й імпортувати класи; це іще один варіант для уникання конфліктів у коді, і це особливо корисно, коли код модуля вже написаний в об'єктноорієнтованому стилі.

Приклад модуля малювання фігур, переписаний на класи ES, можна побачити в нашій директорії [classes](https://github.com/mdn/js-examples/tree/master/module-examples/classes). Наприклад, файл [`square.js`](https://github.com/mdn/js-examples/blob/master/module-examples/classes/modules/square.js) тепер вміщує усю свою функціональність в одному класі:

```js
class Square {
  constructor(ctx, listId, length, x, y, color) {
    // …
  }

  draw() {
    // …
  }

  // …
}
```

котрий далі експортується:

```js
export { Square };
```

Тим часом в [`main.js`](https://github.com/mdn/js-examples/blob/master/module-examples/classes/main.js) цей клас імпортується, ось так:

```js
import { Square } from "./modules/square.js";
```

А потім клас використовується для малювання квадрата:

```js
const square1 = new Square(myCanvas.ctx, myCanvas.listId, 50, 50, 100, "blue");
square1.draw();
square1.reportArea();
square1.reportPerimeter();
```

## Агрегування модулів

Трапляються випадки, коли хочеться агрегувати модулі докупи. Може бути декілька рівнів залежностей, де захочеться все спростити, поєднавши декілька підмодулів у одному батьківському модулі. Це можливо в батьківському модулі за допомогою синтаксису експорту наступного вигляду:

```js
export * from "x.js";
export { name } from "x.js";
```

Приклад є у нашій директорії [module-aggregation](https://github.com/mdn/js-examples/tree/master/module-examples/module-aggregation). В цьому прикладі (заснованому на попередньому прикладі з класами) є додатковий модуль, що зветься `shapes.js`, котрий агрегує всю функціональність з `circle.js`, `square.js` і `triangle.js` докупи. Крім того, підмодулі перенесені до піддиректорії всередині директорії `modules`, названої `shapes`. Тож структура модулів у цьому прикладі:

```plain
modules/
  canvas.js
  shapes.js
  shapes/
    circle.js
    square.js
    triangle.js
```

В кожному з підмодулів експорт має однакову форму, наприклад:

```js
export { Square };
```

Далі – агрегування. В модулі [`shapes.js`](https://github.com/mdn/js-examples/blob/master/module-examples/module-aggregation/modules/shapes.js) є наступні рядки:

```js
export { Square } from "./shapes/square.js";
export { Triangle } from "./shapes/triangle.js";
export { Circle } from "./shapes/circle.js";
```

Вони згрібають експорт з окремих підмодулів і роблять його доступним з модуля `shapes.js`.

> **Примітка:** Експорт, до котрого звертається `shapes.js`, по суті перенаправляється крізь цей файл і насправді в ньому не існує, тож ви не зможете написати в самому файлі жодного корисного спорідненого коду.

Тож тепер у файлі `main.js` можна отримати доступ до класів усіх трьох модулів, замінивши

```js
import { Square } from "./modules/square.js";
import { Circle } from "./modules/circle.js";
import { Triangle } from "./modules/triangle.js";
```

на наступний єдиний рядок:

```js
import { Square, Circle, Triangle } from "./modules/shapes.js";
```

## Динамічне завантаження модулів

Нещодавнє оновлення функціональності модулів JavaScript – динамічне завантаження модулів. Воно дає змогу динамічно завантажувати модулі лише тоді, коли вони потрібні, без потреби завантажувати все одразу. Це дає певні очевидні переваги щодо ефективності; далі – пояснення того, як це працює.

Ця нова функціональність дозволяє викликати [`import()`](/uk/docs/Web/JavaScript/Reference/Operators/import) як функцію, передавши їй шлях до модуля як параметр. Такий виклик поверне {{JSxRef("Promise")}}, котрий сповнюється об'єктом модуля (дивіться [Створення об'єкта модуля](#stvorennia-obiekta-modulia)), котрий дає доступ до експорту цього об'єкта. Наприклад:

```js
import("./modules/myModule.js").then((module) => {
  // Певні дії з модулем.
});
```

Погляньмо на приклад. В директорії [dynamic-module-imports](https://github.com/mdn/js-examples/tree/master/module-examples/dynamic-module-imports) є іще один приклад на основі прикладу з класами. Проте цього разу при завантаженні прикладу на полотні нічого не малюється. Натомість включені три кнопки – "Circle", "Square" і "Triangle", котрі, бувши натисненими, динамічно завантажують необхідний модуль, а потім використовують його для малювання відповідної фігури.

В цьому прикладі зміни внесені лише до файлів [`index.html`](https://github.com/mdn/js-examples/blob/master/module-examples/dynamic-module-imports/index.html) і [`main.js`](https://github.com/mdn/js-examples/blob/master/module-examples/dynamic-module-imports/main.js): експорт модулів – такий самий, як до того.

У `main.js` за допомогою [`document.querySelector()`](/uk/docs/Web/API/Document/querySelector) отримано посилання на кожну кнопку, наприклад:

```js
const squareBtn = document.querySelector(".square");
```

Потім до кожної кнопки прикріплюється слухач подій, щоб коли кнопка була натиснена, відповідний модуль динамічно завантажувався і застосовувався для малювання фігури:

```js
squareBtn.addEventListener("click", () => {
  import("./modules/square.js").then((Module) => {
    const square1 = new Module.Square(
      myCanvas.ctx,
      myCanvas.listId,
      50,
      50,
      100,
      "blue"
    );
    square1.draw();
    square1.reportArea();
    square1.reportPerimeter();
  });
});
```

Зверніть увагу, що у зв'язку з тим, що сповнення промісу повертає об'єкт модуля, клас стає підможливістю об'єкта, а отже – треба звертатися до конструктора з `Module.` на початку, наприклад: `Module.Square( /* … */ )`.

Іще одна перевага динамічного імпорту – те, що він доступний завжди, навіть у сценарних середовищах. Таким чином, якщо вже є тег `<script>` у HTML, котрий не має `type="module"`, все одно можна повторно використати код, що поширюється в модулях, динамічно імпортувавши його.

```html
<script>
  import("./modules/square.js").then((module) => {
    // Певні дії з модулем.
  });
  // Інший код, котрий діє в глобальній області видимості,
  // поки не готовий для переписування на модулі.
  var btn = document.querySelector(".square");
</script>
```

## await верхнього рівня

Await верхнього рівня – доступна в модулях можливість. Це означає, що може використовуватися ключове слово `await`. Це дає модулям змогу діяти як великі [асинхронні функції](/uk/docs/Learn/JavaScript/Asynchronous/Introducing), тобто код може виконуватися до використання в батьківських модулях, але без блокування завантаження сусідніх модулів.

Погляньмо на приклад. Усі файли й описаний в розділі код доступні в директорії [`top-level-await`](https://github.com/mdn/js-examples/tree/master/module-examples/top-level-await), котра є похідною від попередніх прикладів.

По-перше, палітра кольорів оголошується в окремому файлі [`colors.json`](https://github.com/mdn/js-examples/blob/master/module-examples/top-level-await/data/colors.json):

```json
{
  "yellow": "#F4D03F",
  "green": "#52BE80",
  "blue": "#5499C7",
  "red": "#CD6155",
  "orange": "#F39C12"
}
```

Потім створюється модуль на ім'я [`getColors.js`](https://github.com/mdn/js-examples/blob/master/module-examples/top-level-await/modules/getColors.js), котрий застосовує fetch-запит для завантаження файлу [`colors.json`](https://github.com/mdn/js-examples/blob/master/module-examples/top-level-await/data/colors.json) і повернення даних як об'єкта.

```js
// fetch-запит
const colors = fetch("../data/colors.json").then((response) => response.json());

export default await colors;
```

Зверніть увагу на останній рядок з експортом.

Ключове слово `await` застосовується до вказівки експортувати сталу `colors`. А отже – інші модулі, котрі включатимуть цей, очікуватимуть завантаження й розбору `colors`, щоб мати змогу використовувати залежність.

Включімо цей модуль до файлу [`main.js`](https://github.com/mdn/js-examples/blob/master/module-examples/top-level-await/main.js):

```js
import colors from "./modules/getColors.js";
import { Canvas } from "./modules/canvas.js";

const circleBtn = document.querySelector(".circle");

// …
```

Застосуймо `colors` замість рядків, що раніше застосовувалися для виклику функцій фігур:

```js
const square1 = new Module.Square(
  myCanvas.ctx,
  myCanvas.listId,
  50,
  50,
  100,
  colors.blue
);

const circle1 = new Module.Circle(
  myCanvas.ctx,
  myCanvas.listId,
  75,
  200,
  100,
  colors.green
);

const triangle1 = new Module.Triangle(
  myCanvas.ctx,
  myCanvas.listId,
  100,
  75,
  190,
  colors.yellow
);
```

Це корисно, бо код у [`main.js`](https://github.com/mdn/js-examples/blob/master/module-examples/top-level-await/main.js) не виконається, поки не завершиться код у [`getColors.js`](https://github.com/mdn/js-examples/blob/master/module-examples/top-level-await/modules/getColors.js). Проте це не завадить завантаженню інших модулів. Наприклад, модуль [`canvas.js`](https://github.com/mdn/js-examples/blob/master/module-examples/top-level-await/modules/canvas.js) завантажуватиметься далі, поки виконується отримання `colors`.

## Написання "ізоморфних" модулів

Запровадження модулів заохочує екосистему JavaScript поширювати й повторно використовувати код у модульному стилі. Проте це не обов'язково означає, що певний код JavaScript може працювати в будь-якому середовищі. Припустімо, ви знайшли модуль, що обчислює геші SHA паролів користувача. Чи можна його використати у браузерному фронтенді? Чи можна його використати на Node.js сервері? Відповідь: буває по різному.

Модулі мають доступ до глобальних змінних, як показано вище. Якщо модуль звертається до глобальних значень, як то `window`, то він може працювати в браузері, але викине помилку на Node.js сервері, адже `window` там немає. Подібно до цього, якщо кодові потрібен для роботи доступ до `process`, то такий код може використовуватись лише в Node.js.

Для максимізації перевикористовності модуля нерідко радять робити код "ізоморфним" – тобто демонструвати однакову поведінку в усіх середовищах виконання. Загалом цього досягають у три способи:

- Розділення модулів на "ядро" і "зв'язування". У "ядрі" слід зосередитися на щирій логіці JavaScript, як то обчисленні гешу, жодної DOM, звертань до мережі, файлової системи – і відкрити доступ до корисних функцій. У "зв'язуванні" можна зчитувати й змінювати глобальний контекст. Наприклад, "браузерне зв'язування" може вирішити отримати значення з поля введення, а "зв'язування Node" – отримати його з `process.env`, але значення з обох місць передаються до однієї функції ядра й обробляються однаково. Ядро може бути імпортоване в кожному середовищі й використовуватися однаково, тим часом лише зв'язування, котре зазвичай є легковагим, мусить бути специфічним щодо платформи.
- Визначити, чи існує певне глобальне значення, перед його використанням. Наприклад, якщо ви перевіряєте `typeof window === "undefined"`, то знаєте, що, мабуть, знаходитесь в середовищі Node.js і не повинні звертатися до DOM.

  ```js
  // myModule.js
  let password;
  if (typeof process !== "undefined") {
    // Виконання в Node.js; отримувати з `process.env`
    password = process.env.PASSWORD;
  } else if (typeof window !== "undefined") {
    // Виконання в браузері; отримувати з поля введення
    password = document.getElementById("password").value;
  }
  ```

  Краще, якщо дві гілки фактично зводяться до однакової поведінки ("ізоморфної"). Якщо неможливо надати однакову функціональність, або якщо це включає завантаження суттєвого обсягу коду, значна частина якого залишається невикористаною, краще натомість зробити різні "зв'язування".

- Застосувати поліфіл для надання відсутніх можливостей. Наприклад, при потребі використати функцію [`fetch`](/uk/docs/Web/API/Fetch_API), доступної в Node.js лише від версії 18, можна використати подібний API, наприклад, наданий [`node-fetch`](https://www.npmjs.com/package/node-fetch). Це можна зробити умовно, за допомогою динамічного імпорту:

  ```js
  // myModule.js
  if (typeof fetch === "undefined") {
    // Виконання в Node.js; застосувати node-fetch
    globalThis.fetch = (await import("node-fetch")).default;
  }
  // …
  ```

  Змінна [`globalThis`](/uk/docs/Web/JavaScript/Reference/Global_Objects/globalThis) є глобальним об'єктом, доступним у всіх середовищах, корисним, коли треба отримувати чи створювати в модулях глобальні змінні.

Такі практики не є унікальними для модулів. І все ж, у зв'язку з тенденцією до повторного використання коду та модульності заохочується кросплатформність коду, щоб ним могли насолодитися якомога більше людей. Середовища виконання штибу Node.js також енергійно реалізовують API вебтехнологій, де це можливо, щоб покращити сумісність з вебтехнологіями.

## Розв'язання проблем

Кілька порад, котрі можуть допомогти у випадку проблем з роботою модулів. Ласкаво просимо доповнювати список!

- Згадували про це вище, але повторимо: файли `.mjs` повинні завантажуватися з типом MIME `text/javascript` (або іншим сумісним з JavaScript типом MIME, але рекомендований – `text/javascript`), інакше – буде помилка строгої перевірки типу MIME "The server responded with a non-JavaScript MIME type".
- Якщо пробувати завантажити файл HTML локально (тобто з URL `file://`), будуть помилки CORS, пов'язані з вимогами безпеки модулів JavaScript. Тестування треба виконувати через сервер. GitHub pages – ідеальні, адже на додачу віддають файли `.mjs` з коректним типом MIME.
- У зв'язку з тим, що `.mjs` є нестандартним файловим розширенням, частина операційних систем можуть його не розпізнавати чи намагатися замінити чимось іншим. Наприклад, з'ясовано, що macOS без жодних сповіщень додає `.js` в кінець файлів `.mjs`, а потім автоматично приховує файлове розширення. Тож усі файли насправді ставали, наприклад, `x.mjs.js`. Після вимикання автоматичного приховування файлових розширень і навчання системи приймати `.mjs` – все запрацювало нормально.

## Дивіться також

- [Використання модулів JavaScript у Вебі (англ.)](https://v8.dev/features/modules#mjs), від Едді Османі та Матіаса Байненса
- [Модулі ES: мультяшне заглиблення (англ.)](https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/), допис на Hacks від Лін Кларк
- [Заглиблення в ES6: Модулі (англ.)](https://hacks.mozilla.org/2015/08/es6-in-depth-modules/), допис на Hacks від Джейсона Орендорффа
- Книга Акселя Раушмаєра [Дослідження JS: Модулі (англ.)](https://exploringjs.com/es6/ch_modules.html)

{{Previous("Web/JavaScript/Guide/Meta_programming")}}
