---
title: Використання промісів
slug: Web/JavaScript/Guide/Using_promises
tags:
  - Guide
  - Intermediate
  - JavaScript
  - Promise
  - Promises
  - asynchronous
  - "l10n:priority"
---

{{jsSidebar("JavaScript Guide")}}{{PreviousNext("Web/JavaScript/Guide/Using_Classes", "Web/JavaScript/Guide/Iterators_and_Generators")}}

{{jsxref("Promise")}} – це об'єкт, що представляє завершення або невдачу асинхронної операції. Оскільки більшість людей користуються вже створеними промісами, цей посібник спершу пояснить використання повернених промісів, а потім – як їх створювати.

По суті проміс – це повернений об'єкт, до котрого приєднуються функції зворотного виклику, замість їх передачі до функцій.

Уявіть функцію, `createAudioFileAsync()`, котра асинхронно породжує звуковий файл згідно з заданою конфігурацією, і дві функції зворотного виклику, одна з котрих викликається, якщо файл успішно створений, а інша – якщо трапляється помилка.

Ось трохи коду, що використовує `createAudioFileAsync()`:

```js
function successCallback(result) {
  console.log(`Аудіофайл готовий за URL: ${result}`);
}

function failureCallback(error) {
  console.error(`Помилка породження аудіофайлу: ${error}`);
}

createAudioFileAsync(audioSettings, successCallback, failureCallback);
```

Якби `createAudioFileAsync()` була переписана для повертання промісу, натомість до неї прикріплювали б функції зворотного виклику:

```js
createAudioFileAsync(audioSettings).then(successCallback, failureCallback);
```

Така домовленість має декілька переваг. Нижче – огляд кожної з них

## Гарантії

На відміну від старомодних _переданих_ функцій зворотного виклику, проміс приносить певні гарантії:

- Функції зворотного виклику, додані за допомогою [`then()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/then), ніколи не будуть викликані до [завершення обробки поточного повідомлення](/uk/docs/Web/JavaScript/EventLoop#povne-vykonannia) циклом подій JavaScript.
- Ці функції зворотного виклику будуть закликані навіть якщо додані _після_ успіху чи невдачі асинхронної операції, котру представляє проміс.
- Кілька функцій зворотного виклику можна додати шляхом виклику [`then()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/then) декілька разів. Вони будуть викликані одна за одною, в тому порядку, в якому були додані.

Одна з чудових штук у використанні промісів – **утворення ланцюжків**.

## Утворення ланцюжків

Поширена потреба – виконати дві чи більше асинхронних операцій одну за одною, щоб кожна наступна операція починалася, коли успішно завершується попередня, з використанням результату попереднього кроку. Цього можна досягти шляхом створення **ланцюжка промісів**.

Ось магія: функція `then()` повертає **новий проміс**, не той самий, на котрому була викликана:

```js
const promise = doSomething();
const promise2 = promise.then(successCallback, failureCallback);
```

or

```js
const promise2 = doSomething().then(successCallback, failureCallback);
```

Другий проміс (`promise2`) представляє завершення не лише `doSomething()`, а й переданих `successCallback` чи `failureCallback`, котрі можуть бути іншими асинхронними функціями, що повертають проміси. Коли це саме так, то будь-які функції зворотного виклику, додані до `promise2`, ставляться в чергу за промісом, поверненим або `successCallback`, або `failureCallback`.

По суті кожний проміс представляє завершення одного з асинхронних кроків ланцюжка.

В старі часи виконання декількох асинхронних операцій по черзі призводило до класичної піраміди безнадії з функцій зворотного виклику:

```js
doSomething(function (result) {
  doSomethingElse(
    result,
    function (newResult) {
      doThirdThing(
        newResult,
        function (finalResult) {
          console.log(`Отриманий остаточний результат: ${finalResult}`);
        },
        failureCallback
      );
    },
    failureCallback
  );
}, failureCallback);
```

Натомість за допомогою сучасних функцій функції зворотного виклику прикріпляються до повернених промісів, утворюючи ланцюжок промісів:

```js
doSomething()
  .then(function (result) {
    return doSomethingElse(result);
  })
  .then(function (newResult) {
    return doThirdThing(newResult);
  })
  .then(function (finalResult) {
    console.log(`Отриманий остаточний результат: ${finalResult}`);
  })
  .catch(failureCallback);
```

Аргументи `then` є необов'язковими, і `catch(failureCallback)` є скороченим записом `then(null, failureCallback)`. Можна зустріти вираження їх за допомогою [стрілкових функцій](/uk/docs/Web/JavaScript/Reference/Functions/Arrow_functions):

```js
doSomething()
  .then((result) => doSomethingElse(result))
  .then((newResult) => doThirdThing(newResult))
  .then((finalResult) => {
    console.log(`Отриманий остаточний результат: ${finalResult}`);
  })
  .catch(failureCallback);
```

**Важливо:** Слід завжди повертати результати, інакше функції зворотного виклику не захоплять результат попереднього промісу (в стрілкових функціях `() => x` є коротким записом `() => { return x; }`). Якщо попередній обробник запустив проміс, але не повернув його, то неможливо відстежити залагодження такого проміса, і про проміс кажуть, що він "повис".

```js example-bad
doSomething()
  .then((url) => {
    // Я забув повернути це
    fetch(url);
  })
  .then((result) => {
    // result – undefined, тому що нічого не було повернено з
    // попереднього обробника.
    // Тепер неможливо дізнатися повернене значення виклику fetch(),
    // як і те, чи завершився цей виклик успіхом взагалі.
  });
```

Справи підуть куди гірше, якщо є стан перегонів: якщо проміс з попереднього обробника не був повернутий, то наступний обробник `then` буде викликаний зарано, і значення, котре він отримає, може бути неповним.

```js example-bad
const listOfIngredients = [];

doSomething()
  .then((url) => {
    // Я забув це повернути
    fetch(url)
      .then((res) => res.json())
      .then((data) => {
        listOfIngredients.push(data);
      });
  })
  .then(() => {
    console.log(listOfIngredients);
    // Завжди [], бо запит на отримання іще не був завершений.
  });
```

Таким чином, досвід підказує, що кожного разу, коли операція зустрічає проміс, його слід повернути й делегувати його обробку наступному обробникові `then`.

```js example-good
const listOfIngredients = [];

doSomething()
  .then((url) =>
    fetch(url)
      .then((res) => res.json())
      .then((data) => {
        listOfIngredients.push(data);
      })
  )
  .then(() => {
    console.log(listOfIngredients);
  });

// АБО

doSomething()
  .then((url) => fetch(url))
  .then((res) => res.json())
  .then((data) => {
    listOfIngredients.push(data);
  })
  .then(() => {
    console.log(listOfIngredients);
  });
```

### Ланцюжок промісів після catch

Можна утворювати ланцюжок промісів _після_ невдачі, тобто `catch`, котрий корисний для виконання нових дій навіть тоді, коли в ланцюжку провалилось виконання однієї з операцій. Приклад:

```js
new Promise((resolve, reject) => {
  console.log("Початок");

  resolve();
})
  .then(() => {
    throw new Error("Щось не вийшло");

    console.log("Дії такі");
  })
  .catch(() => {
    console.error("Дії сякі");
  })
  .then(() => {
    console.log("Дії незалежно від того, що відбувалося раніше");
  });
```

Цей код виведе наступний текст:

```plain
Початок
Дії сякі
Дії незалежно від того, що відбувалося раніше
```

> **Примітка:** Текст "Дії такі" не виводиться, адже помилка "Щось не вийшло" спричинила відмову.

## Поширення помилки

Можливо, ви пригадуєте повторення `failureCallback` тричі в піраміді загибелі вище; порівняйте з лишень одним разом в кінці ланцюжка промісів:

```js
doSomething()
  .then((result) => doSomethingElse(result))
  .then((newResult) => doThirdThing(newResult))
  .then((finalResult) =>
    console.log(`Отриманий остаточний результат: ${finalResult}`)
  )
  .catch(failureCallback);
```

Якщо стався виняток, браузер шукатиме в ланцюжку згори вниз обробники `.catch()` або `onRejected`. Це по суті засновано на тому, як працює синхронний код:

```js
try {
  const result = syncDoSomething();
  const newResult = syncDoSomethingElse(result);
  const finalResult = syncDoThirdThing(newResult);
  console.log(`Отриманий остаточний результат: ${finalResult}`);
} catch (error) {
  failureCallback(error);
}
```

Кульмінацією цієї симетрії з синхронним кодом є синтаксис [`async`/`await`](/uk/docs/Web/JavaScript/Reference/Statements/async_function):

```js
async function foo() {
  try {
    const result = await doSomething();
    const newResult = await doSomethingElse(result);
    const finalResult = await doThirdThing(newResult);
    console.log(`Отриманий остаточний результат: ${finalResult}`);
  } catch (error) {
    failureCallback(error);
  }
}
```

Він збудований на промісах, наприклад, `doSomething()` – та сама функція, що й раніше. Про цей синтаксис докладніше прочитати можна [тут (англ.)](https://web.dev/javascript-async-functions/).

Проміси розв'язують фундаментальну проблему з пірамідою безнадії функцій зворотного виклику, перехоплюючи всі помилки, навіть викинуті винятки й помилки програмування. Це критично для функційної композиції асинхронних операцій.

## Події відхилення промісів

Щоразу, коли відхиляється проміс, у глобальну область видимості надсилається одна з двох подій (загалом, це або [`window`](/uk/docs/Web/API/Window), або, якщо це трапилося у вебворкері, це [`Worker`](/uk/docs/Web/API/Worker) чи інший інтерфейс, заснований на воркері). Ці дві події:

- [`rejectionhandled`](/uk/docs/Web/API/Window/rejectionhandled_event)
  - : Надсилається, коли проміс відхилено, після обробки відхилення у виконавці функцією `reject`.
- [`unhandledrejection`](/uk/docs/Web/API/Window/unhandledrejection_event)
  - : Надсилається, коли проміс відхилено, але немає обробника відхилення.

В обох випадках подія (типу [`PromiseRejectionEvent`](/uk/docs/Web/API/PromiseRejectionEvent)) містить властивість [`promise`](/uk/docs/Web/API/PromiseRejectionEvent/promise), котра вказує, який проміс був відхилений, та властивість [`reason`](/uk/docs/Web/API/PromiseRejectionEvent/reason), котра надає причину, через яку він був відхилений.

Ці події дають змогу запропонувати запасну обробку помилок у промісах, а також допомагають зневаджувати проблеми з управлінням промісами. Ці обробники є глобальними для кожного контексту, тому всі помилки підуть в одні й ті самі обробники подій, незалежно від їх джерела.

Випадок їх особливої корисності: коли триває написання коду для [Node.js](/uk/docs/Glossary/Node.js), поширена ситуація, коли модулі проєкту мають необроблені відхилені проміси, виведені в консоль середовищем Node.js. Їх можна захоплювати для аналізу й обробки власним кодом, або просто уникати того, щоб вони захаращували вивід, шляхом додавання обробника для події Node.js `unhandledRejection` (зверніть увагу на різницю в регістрі літер імені), отак:

```js
process.on("unhandledRejection", (reason, promise) => {
  /* Можливо, варто почати з додавання коду для дослідження
   * значень "promise" і "reason" values. */
});
```

На Node.js для запобігання виведенню помилки в консоль (усталеної реакції, що відбулась би інакше) додати такого слухача `process.on()` – усе що потрібно; немає потреби в чомусь рівносильному методові браузерного середовища[`preventDefault()`](/uk/docs/Web/API/Event/preventDefault).

Проте якщо додати такого слухача `process.on`, але без коду всередині нього, що обробляє відхилені проміси, ці проміси просто впадуть на землю й будуть тихо проігноровані. Тож в ідеалі слід додати в слухача код, що досліджує кожний відхилений проміс і пересвідчується, що відхилення не було спричинено реальною вадою коду.

## Створення проміса навколо старого API з функціями зворотного виклику

{{jsxref("Promise")}} може бути створений з нуля за допомогою його конструктора. Це повинно бути необхідно лише для обгортання старих API.

В ідеальному світі усі асинхронні функції зразу повертали б проміси. На жаль, частина API досі очікують на функції зворотного виклику на випадок успіху чи невдачі, передані в старий спосіб. Найочевидніший приклад – функція [`setTimeout()`](/uk/docs/Web/API/setTimeout):

```js
setTimeout(() => saySomething("Минуло 10 секунд"), 10 * 1000);
```

Змішування старих функцій зворотного виклику й промісів – проблемне. Якщо `saySomething()` зазнає невдачі або містить помилку програмування, ніщо це не перехопить. Винна в цьому буде `setTimeout`.

На щастя, `setTimeout` можна загорнути в проміс. Найкращий підхід – обгортати проблемні функції на найнижчому з можливих рівнів, а потім ніколи не викликати їх більше напряму:

```js
const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

wait(10 * 1000)
  .then(() => saySomething("10 секунд"))
  .catch(failureCallback);
```

По суті конструктор промісів приймає функцію-виконавця, котра дає змогу вручну вирішити або відхилити проміс. Оскільки `setTimeout()` насправді не знає невдач, тут reject опущено.

## Композиція

{{jsxref("Promise.resolve()")}} і {{jsxref("Promise.reject()")}} – скорочення для ручного створення зразу вирішеного або відхиленого проміса, відповідно. Іноді це буває корисно.

{{jsxref("Promise.all()")}} і {{jsxref("Promise.race()")}} – два інструменти композиції для паралельного запуску асинхронних операцій.

Запустити операції паралельно й чекати, поки всі вони виконаються, можна отак:

```js
Promise.all([func1(), func2(), func3()]).then(([result1, result2, result3]) => {
  /* використання result1, result2 і result3 */
});
```

Важливо зауважити, що якщо один з промісів масиву відхилиться, то `Promise.all()` викине помилку й перерве решту операцій. Це може призвести до неочікуваних стану чи поведінки. {{jsxref("Promise.allSettled()")}} – іще один інструмент композиції, що перед своїм вирішенням пересвідчується, що усі операції завершилися.

Послідовна композиція можлива за допомогою дещо хитрого JavaScript:

```js
[func1, func2, func3]
  .reduce((p, f) => p.then(f), Promise.resolve())
  .then((result3) => {
    /* використання result3 */
  });
```

По суті масив асинхронних функцій зводиться до ланцюжка промісів. Код вище рівносильний наступному:

```js
Promise.resolve()
  .then(func1)
  .then(func2)
  .then(func3)
  .then((result3) => {
    /* використання result3 */
  });
```

Це можна перетворити на повторно використовну функцію композиції, що поширено в функційному програмуванні:

```js
const applyAsync = (acc, val) => acc.then(val);
const composeAsync =
  (...funcs) =>
  (x) =>
    funcs.reduce(applyAsync, Promise.resolve(x));
```

Функція `composeAsync()` прийме як аргументи будь-яку кількість функцій, а поверне – нову функцію, котра приймає початкове значення, котре буде пропущено через увесь конвеєр композиції:

```js
const transformData = composeAsync(func1, func2, func3);
const result3 = transformData(data);
```

Послідовна композиція також може бути реалізована більш стисло за допомогою async/await:

```js
let result;
for (const f of [func1, func2, func3]) {
  result = await f(result);
}
/* використання останнього результату (тобто result3) */
```

## Хронометраж

Для уникнення сюрпризів функції, передані в [`then()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/then), ніколи не викликаються синхронно, навіть для вже вирішеного промісу

```js
Promise.resolve().then(() => console.log(2));
console.log(1); // 1, 2
```

Замість негайного виконання передана функція ставиться в чергу мікрозавдань, а отже – вона спрацьовує пізніше (лише після того, як відбувається вихід з функції, котра її створила, і коли стек виконання JavaScript порожній), лишень перед тим, як контроль повертається циклові подій; тобто доволі скоро:

```js
const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

wait(0).then(() => console.log(4));
Promise.resolve()
  .then(() => console.log(2))
  .then(() => console.log(3));
console.log(1); // 1, 2, 3, 4
```

### Задачі й мікрозавдання

Функції зворотного виклику промісів обробляються як [мікрозавдання](/uk/docs/Web/API/HTML_DOM_API/Microtask_guide), натомість функції зворотного виклику [`setTimeout()`](/uk/docs/Web/API/setTimeout) обробляються як прості задачі.

```js
const promise = new Promise(function (resolve, reject) {
  console.log("Функція зворотного виклику промісу");
  resolve();
}).then(function (result) {
  console.log("Функція зворотного виклику промісу (.then)");
});

setTimeout(function () {
  console.log("цикл подій: проміс (сповнений)", promise);
}, 0);

console.log("Проміс (в очікуванні)", promise);
```

Код вище виведе:

```plain
Функція зворотного виклику промісу
Проміс (в очікуванні) Promise {<pending>}
Функція зворотного виклику промісу (.then)
цикл подій: проміс (сповнений) Promise {<fulfilled>}
```

Подробиці доступні в [Задачах і мікрозавданнях](/uk/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth#zadachi-y-mikrozavdannia).

## Вкладення

Прості ланцюжки промісів найкраще залишати без вкладеності, адже вкладеність може бути наслідком бездумної композиції. Дивіться [поширені помилки](#poshyreni-pomylky).

Вкладення – контрольна структура для обмеження області дії інструкцій `catch`. А саме, вкладений `catch` перехоплює лише невдачі у власній області та нижче, але не помилки вище за нього в ланцюжку поза вкладеною областю. З удалим використанням це дає змогу отримати чудову точність у відновленні після помилок:

```js
doSomethingCritical()
  .then((result) =>
    doSomethingOptional(result)
      .then((optionalResult) => doSomethingExtraNice(optionalResult))
      .catch((e) => {})
  ) // Ігнорувати, якщо не вийшло з необов'язковими штуками; продовжувати.
  .then(() => moreCriticalStuff())
  .catch((e) => console.error(`Критична відмова: ${e.message}`));
```

Зверніть увагу, що необов'язкові кроки тут вкладені, унаслідок не відступу, а сумнівного розташування навколо них зовнішніх `(` й `)`.

Внутрішня нейтралізувальна інструкція `catch` перехоплює невдачі лише з `doSomethingOptional()` і `doSomethingExtraNice()`, після чого код відновлює дію з `moreCriticalStuff()`. Більш важливо, що якщо зазнає невдачі `doSomethingCritical()`, то його помилка перехоплюється лише остаточною (зовнішньою) `catch`.

## Поширені помилки

Нижче – трохи поширених помилок, за появою яких слід слідкувати при компонуванні ланцюжків промісів. Кілька з них – у наступному прикладі:

```js example-bad
// Поганий приклад! Знайдіть 3 помилки!

doSomething()
  .then(function (result) {
    // Забули повернути проміс зі внутрішнього ланцюжка + непотрібна вкладеність
    doSomethingElse(result).then((newResult) => doThirdThing(newResult));
  })
  .then(() => doFourthThing());
// Забули закрити ланцюжок, додавши catch!
```

Перша помилка – не зв'язувати все правильно в ланцюжок. Так виходить, коли створюється новий проміс, але його забули повернути. Як наслідок, ланцюжок розірваний, або радше є два незалежні ланцюжки, що виконуються наввипередки. Це означає, що `doFourthThing()` не чекатиме завершення `doSomethingElse()` чи `doThirdThing()`, а запуститься паралельно до них, що, ймовірно, не було наміром автора коду. Крім того, окремі ланцюжки мають окрему обробку помилок, що веде до неперехоплених помилок.

Друга помилка – непотрібна вкладеність, котра дає змогу зробити першу помилку. Також вкладеність обмежує область дії внутрішніх обробників помилок, що, якщо зроблено ненавмисно, може призвести до неперехоплених помилок. Варіантом цієї помилки є [антипатерн конструктора промісів (англ.)](https://stackoverflow.com/questions/23803743/what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it), котрий поєднує вкладеність з даремним використанням конструктора промісів для обгортання коду, що вже використовує проміси.

Третя помилка – забути закрити ланцюжок, додавши `catch`. Незакриті ланцюжки промісів у більшості браузерів призводять до неперехоплених відхилень промісів.

Досвід підказує, що слід завжди або повертати, або закривати ланцюжки промісів, і щойно отримано новий проміс, його слід негайно повертати, щоб усе сплощити:

```js example-good
doSomething()
  .then(function (result) {
    // Коли використовується повний вираз функції: повернути проміс
    return doSomethingElse(result);
  })
  // Коли використовується стрілкова функція: опустити дужки й неявно повернути результат
  .then((newResult) => doThirdThing(newResult))
  // Навіть якщо попередній проміс ланцюжка повертає результат, наступному
  // не обов'язково цей результат використовувати. Можна передати обробник,
  // котрий не приймає жодного результату.
  .then((/* результат проігноровано */) => doFourthThing())
  // Завжди закінчуйте ланцюжок промісів обробником перехоплення, аби уникнути
  // будь-яких необроблених відхилень!
  .catch((error) => console.error(error));
```

Зверніть увагу, що `() => x` є скороченим записом `() => { return x; }`.

Тепер маємо один детерміністичний ланцюжок, з доброю обробкою помилок.

Використання [`async`/`await`](/uk/docs/Web/JavaScript/Reference/Statements/async_function) спрямоване на розв'язання більшості, якщо не всіх цих проблем – з єдиною новою проблемою: найпоширеніша помилка з таким синтаксисом – забути додати ключове слово [`await`](/uk/docs/Web/JavaScript/Reference/Statements/async_function).

## Коли проміси й задачі стикаються

Коли трапляється ситуація, в якій проміси й задачі (як то події чи функції зворотного виклику) спрацьовують у непередбачуваному порядку, можливо, може бути корисним використання мікрозавдання для перевірки статусу чи балансування промісів, коли проміси створюються умовно.

Якщо здається, що допомогти розв'язати проблему можуть мікрозавдання, дивіться [посібник з мікрозавдань](/uk/docs/Web/API/HTML_DOM_API/Microtask_guide), аби дізнатися, як використати [`queueMicrotask()`](/uk/docs/Web/API/queueMicrotask) для постановки функції в чергу як мікрозавдання.

## Дивіться також

- {{jsxref("Promise.prototype.then()")}}
- [`async`/`await`](/uk/docs/Web/JavaScript/Reference/Statements/async_function)
- [Специфікація Promises/A+ (англ.)](https://promisesaplus.com/)
- [Venkatraman.R - JS Promise (Частина 1, Основи (англ.))](https://medium.com/@ramsunvtech/promises-of-promise-part-1-53f769245a53)
- [Venkatraman.R - JS Promise (Частина 2 - Використання Q.js, When.js і RSVP.js (англ.))](https://medium.com/@ramsunvtech/js-promise-part-2-q-js-when-js-and-rsvp-js-af596232525c#.dzlqh6ski)
- [Venkatraman.R - Інструменти для юніттестування промісів (англ.)](https://tech.io/playgrounds/11107/tools-for-promises-unittesting/introduction)
- [Нолан Лоусон: Маємо проблему з промісами – Поширені помилки з промісами (англ.)](https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html)

{{PreviousNext("Web/JavaScript/Guide/Using_Classes", "Web/JavaScript/Guide/Iterators_and_Generators")}}
