---
title: Глибоке копіювання
slug: Glossary/Deep_copy
page-type: glossary-definition
---

{{GlossarySidebar}}

**Глибока копія** об'єкта – це копія, чиї властивості не поділяють посилань (що вказують на ті самі значення) з властивостями об'єкта-джерела, з якого була зроблена копія. Як наслідок, коли змінити або джерело, або копію, то можна мати певність, що інший об'єкт змінюватися не буде. Така логіка відрізняється від логіки {{Glossary("shallow copy", "поверхневого копіювання")}}, в якій зміни вкладених властивостей у джерелі або копії можуть призвести також до змін іншого об'єкта.

Два об'єкти `o1` і `o2` є _структурно еквівалентними_, якщо їхня видима поведінка – однакова. Ця поведінка включає наступне:

1. Властивості `o1` і `o2` мають одні й ті ж значення в тому самому порядку.
2. Значення їхніх властивостей є структурно еквівалентними.
3. Їхні ланцюжки прототипів структурно еквівалентні (хоча, коли розглядається структурна еквівалентність, то об'єкти зазвичай є простими об'єктами, тобто вони обидва успадковують від `Object.prototype`).

Структурно еквівалентні об'єкти можуть бути або одним і тим же об'єктом (`o1 === o2`), або _копіями_ (`o1 !== o2`). Оскільки еквівалентні примітивні значення завжди однакові при порівнянні, то їх не можна скопіювати.

Глибокі копії можна більш формально визначити так:

1. Вони не є одним об'єктом (`o1 !== o2`).
2. Властивості `o1` і `o2` мають однакові назви в тому самому порядку.
3. Значення їхніх властивостей є глибокими копіями одне одних.
4. Їхні ланцюжки прототипів структурно еквівалентні.

Глибокі копії можуть мати або не мати скопійовані ланцюжки прототипів (і нерідко не мають). Але два об'єкти зі структурно нееквівалентними ланцюжками прототипів (наприклад, один є масивом, а інший – простим об'єктом) ніколи не є копіями одне одного.

Копія об'єкта, всі властивості якого мають примітивні значення, вписується у визначення як глибокої копії, так і {{Glossary("shallow copy", "поверхневої копії")}}. Проте дещо безглуздо говорити про глибину такої копії, адже вона не має вкладених властивостей, а зазвичай про глибоке копіювання говорять у контексті змін вкладених властивостей.

У JavaScript стандартні вбудовані операції копіювання об'єктів ([синтаксис розгортання](/uk/docs/Web/JavaScript/Reference/Operators/Spread_syntax), [`Array.prototype.concat()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Array/concat), [`Array.prototype.slice()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Array/slice), [`Array.from()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Array/from) і [`Object.assign()`](/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)) не створюють глибоких копій (замість цього вони створюють поверхневі копії).

Один зі способів створити глибоку копію об'єкта JavaScript, якщо він може бути {{Glossary("serialization", "серіалізований")}}, – скористатися {{jsxref("JSON.stringify()")}} для перетворення об'єкта на рядок JSON, а потім {{jsxref("JSON.parse()")}} для перетворення рядка назад на (геть новий) об'єкт JavaScript:

```js
const ingredientsList = ["локшина", { list: ["яйця", "борошно", "вода"] }];
const ingredientsListDeepCopy = JSON.parse(JSON.stringify(ingredientsList));
```

Оскільки глибока копія не поділяє посилань зі своїм об'єктом-джерелом, то всі зміни, що вносяться до глибокої копії, не впливають на об'єкт-джерело.

```js
// Змінити значення властивості 'list' в ingredientsListDeepCopy.
ingredientsListDeepCopy[1].list = ["рисове борошно", "вода"];
// Властивість 'list' не змінюється в ingredients_list.
console.log(ingredientsList[1].list);
// Array(3) [ "яйця", "борошно", "вода" ]
```

Проте попри те, що об'єкт у коді вище достатньо простий, щоб бути {{Glossary("serialization", "серіалізованим")}}, чимало об'єктів JavaScript не можна серіалізувати взагалі – наприклад, [функції](/uk/docs/Web/JavaScript/Guide/Functions) (із їхніми замиканнями), [символи](/uk/docs/Web/JavaScript/Reference/Global_Objects/Symbol), об'єкти, що представляють елементи HTML в [API DOM HTML](/uk/docs/Web/API/HTML_DOM_API), рекурсивні дані та багато інших ситуацій. Виклик `JSON.stringify()` для серіалізації об'єктів у таких випадках призведе до помилки. Тому немає способу створити глибокі копії таких об'єктів.

API Вебу [`structuredClone()`](/uk/docs/Web/API/structuredClone) також створює глибокі копії, маючи при цьому перевагу в тому, що дозволяє [переносним об'єктам](/uk/docs/Web/API/Web_Workers_API/Transferable_objects) у джерелі _переноситися_ до нової копії, а не просто клонуватися. Він також обробляє більше типів даних, наприклад, `Error`. Але слід зауважити, що `structuredClone()` не є можливістю мови JavaScript – це можливість браузерів та інших середовищ виконання JavaScript, які мають реалізацію API Вебу. І виклик `structuredClone()` для клонування несеріалізовного об'єкта призведе до помилки так само, як і виклик `JSON.stringify()` для серіалізації.

## Дивіться також

- Споріднені терміни глосарія:
  - {{glossary("Shallow copy", "Поверхневе копіювання")}}
- [`window.structuredClone()`](/uk/docs/Web/API/structuredClone)
